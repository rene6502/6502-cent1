
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass --nostart --tab-size 2 --line-numbers --list basic.lst --output basic.bin basic.asm
; Sat Nov 13 19:12:25 2021

;Line		;Offset	;Hex						;Monitor				;Source

:1			;******  Processing input file: basic.asm

47			=$00																		LAB_WARM          = $00       ; BASIC warm start entry point
48			=1																			Wrmjpl            = LAB_WARM+1; BASIC warm start vector jump low byte
49			=2																			Wrmjph            = LAB_WARM+2; BASIC warm start vector jump high byte
51			=$0a																		Usrjmp            = $0A       ; USR function JMP address
52			=11																			Usrjpl            = Usrjmp+1  ; USR function JMP vector low byte
53			=12																			Usrjph            = Usrjmp+2  ; USR function JMP vector high byte
54			=$0d																		Nullct            = $0D       ; nulls output after each line
55			=$0e																		TPos              = $0E       ; BASIC terminal position byte
56			=$0f																		TWidth            = $0F       ; BASIC terminal width byte
57			=$10																		Iclim             = $10       ; input column limit
58			=$11																		Itempl            = $11       ; temporary integer low byte
59			=18																			Itemph            = Itempl+1  ; temporary integer high byte
62			=$11																		nums_1            = Itempl    ; number to bin/hex string convert MSB
63			=18																			nums_2            = nums_1+1  ; number to bin/hex string convert
64			=19																			nums_3            = nums_1+2  ; number to bin/hex string convert LSB
66			=$5b																		Srchc             = $5B       ; search character
67			=$5b																		Temp3             = Srchc     ; temp byte used in number routines
68			=$5c																		Scnquo            = $5C       ; scan-between-quotes flag
69			=$5c																		Asrch             = Scnquo    ; alt search character
71			=$5b																		XOAw_l            = Srchc     ; eXclusive OR, OR and AND word low byte
72			=$5c																		XOAw_h            = Scnquo    ; eXclusive OR, OR and AND word high byte
74			=$5d																		Ibptr             = $5D       ; input buffer pointer
75			=$5d																		Dimcnt            = Ibptr     ; # of dimensions
76			=$5d																		Tindx             = Ibptr     ; token index
78			=$5e																		Defdim            = $5E       ; default DIM flag
79			=$5f																		Dtypef            = $5F       ; data type flag, $FF=string, $00=numeric
80			=$60																		Oquote            = $60       ; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
81			=$60																		Gclctd            = $60       ; garbage collected flag
82			=$61																		Sufnxf            = $61       ; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
83			=$62																		Imode             = $62       ; input mode flag, $00=INPUT, $80=READ
85			=$63																		Cflag             = $63       ; comparison evaluation flag
87			=$64																		TabSiz            = $64       ; TAB step size (was input flag)
89			=$65																		next_s            = $65       ; next descriptor stack address
93			=$66																		last_sl           = $66       ; last descriptor stack address low byte
94			=$67																		last_sh           = $67       ; last descriptor stack address high byte (always $00)
96			=$68																		des_sk            = $68       ; descriptor stack start address (temp strings)
100			=$71																		ut1_pl            = $71       ; utility pointer 1 low byte
101			=114																		ut1_ph            = ut1_pl+1  ; utility pointer 1 high byte
102			=$73																		ut2_pl            = $73       ; utility pointer 2 low byte
103			=116																		ut2_ph            = ut2_pl+1  ; utility pointer 2 high byte
105			=$71																		Temp_2            = ut1_pl    ; temp byte for block move
107			=$75																		FACt_1            = $75       ; FAC temp mantissa1
108			=118																		FACt_2            = FACt_1+1  ; FAC temp mantissa2
109			=119																		FACt_3            = FACt_2+1  ; FAC temp mantissa3
111			=118																		dims_l            = FACt_2    ; array dimension size low byte
112			=119																		dims_h            = FACt_3    ; array dimension size high byte
114			=$78																		TempB             = $78       ; temp page 0 byte
116			=$79																		Smeml             = $79       ; start of mem low byte       (Start-of-Basic)
117			=122																		Smemh             = Smeml+1   ; start of mem high byte      (Start-of-Basic)
118			=$7b																		Svarl             = $7B       ; start of vars low byte      (Start-of-Variables)
119			=124																		Svarh             = Svarl+1   ; start of vars high byte     (Start-of-Variables)
120			=$7d																		Sarryl            = $7D       ; var mem end low byte        (Start-of-Arrays)
121			=126																		Sarryh            = Sarryl+1  ; var mem end high byte       (Start-of-Arrays)
122			=$7f																		Earryl            = $7F       ; array mem end low byte      (End-of-Arrays)
123			=128																		Earryh            = Earryl+1  ; array mem end high byte     (End-of-Arrays)
124			=$81																		Sstorl            = $81       ; string storage low byte     (String storage (moving down))
125			=130																		Sstorh            = Sstorl+1  ; string storage high byte    (String storage (moving down))
126			=$83																		Sutill            = $83       ; string utility ptr low byte
127			=132																		Sutilh            = Sutill+1  ; string utility ptr high byte
128			=$85																		Ememl             = $85       ; end of mem low byte         (Limit-of-memory)
129			=134																		Ememh             = Ememl+1   ; end of mem high byte        (Limit-of-memory)
130			=$87																		Clinel            = $87       ; current line low byte       (Basic line number)
131			=136																		Clineh            = Clinel+1  ; current line high byte      (Basic line number)
132			=$89																		Blinel            = $89       ; break line low byte         (Previous Basic line number)
133			=138																		Blineh            = Blinel+1  ; break line high byte        (Previous Basic line number)
135			=$8b																		Cpntrl            = $8B       ; continue pointer low byte
136			=140																		Cpntrh            = Cpntrl+1  ; continue pointer high byte
138			=$8d																		Dlinel            = $8D       ; current DATA line low byte
139			=142																		Dlineh            = Dlinel+1  ; current DATA line high byte
141			=$8f																		Dptrl             = $8F       ; DATA pointer low byte
142			=144																		Dptrh             = Dptrl+1   ; DATA pointer high byte
144			=$91																		Rdptrl            = $91       ; read pointer low byte
145			=146																		Rdptrh            = Rdptrl+1  ; read pointer high byte
147			=$93																		Varnm1            = $93       ; current var name 1st byte
148			=148																		Varnm2            = Varnm1+1  ; current var name 2nd byte
150			=$95																		Cvaral            = $95       ; current var address low byte
151			=150																		Cvarah            = Cvaral+1  ; current var address high byte
153			=$97																		Frnxtl            = $97       ; var pointer for FOR/NEXT low byte
154			=152																		Frnxth            = Frnxtl+1  ; var pointer for FOR/NEXT high byte
156			=$97																		Tidx1             = Frnxtl    ; temp line index
158			=$97																		Lvarpl            = Frnxtl    ; let var pointer low byte
159			=152																		Lvarph            = Frnxth    ; let var pointer high byte
161			=$99																		prstk             = $99       ; precedence stacked flag
163			=$9b																		comp_f            = $9B       ; compare function flag, bits 0,1 and 2 used
168			=$9c																		func_l            = $9C       ; function pointer low byte
169			=157																		func_h            = func_l+1  ; function pointer high byte
171			=$9c																		garb_l            = func_l    ; garbage collection working pointer low byte
172			=157																		garb_h            = func_h    ; garbage collection working pointer high byte
174			=$9e																		des_2l            = $9E       ; string descriptor_2 pointer low byte
175			=159																		des_2h            = des_2l+1  ; string descriptor_2 pointer high byte
177			=$a0																		g_step            = $A0       ; garbage collect step size
179			=$a1																		Fnxjmp            = $A1       ; jump vector for functions
180			=162																		Fnxjpl            = Fnxjmp+1  ; functions jump vector low byte
181			=163																		Fnxjph            = Fnxjmp+2  ; functions jump vector high byte
183			=162																		g_indx            = Fnxjpl    ; garbage collect temp index
185			=$a3																		FAC2_r            = $A3       ; FAC2 rounding byte
187			=$a4																		Adatal            = $A4       ; array data pointer low byte
188			=165																		Adatah            = Adatal+1  ; array data pointer high  byte
190			=$a4																		Nbendl            = Adatal    ; new block end pointer low byte
191			=165																		Nbendh            = Adatah    ; new block end pointer high  byte
193			=$a6																		Obendl            = $A6       ; old block end pointer low byte
194			=167																		Obendh            = Obendl+1  ; old block end pointer high  byte
196			=$a8																		numexp            = $A8       ; string to float number exponent count
197			=$a9																		expcnt            = $A9       ; string to float exponent count
199			=$a8																		numbit            = numexp    ; bit count for array element calculations
201			=$aa																		numdpf            = $AA       ; string to float decimal point flag
202			=$ab																		expneg            = $AB       ; string to float eval exponent -ve flag
204			=$aa																		Astrtl            = numdpf    ; array start pointer low byte
205			=$ab																		Astrth            = expneg    ; array start pointer high  byte
207			=$aa																		Histrl            = numdpf    ; highest string low byte
208			=$ab																		Histrh            = expneg    ; highest string high  byte
210			=$aa																		Baslnl            = numdpf    ; BASIC search line pointer low byte
211			=$ab																		Baslnh            = expneg    ; BASIC search line pointer high  byte
213			=$aa																		Fvar_l            = numdpf    ; find/found variable pointer low byte
214			=$ab																		Fvar_h            = expneg    ; find/found variable pointer high  byte
216			=$aa																		Ostrtl            = numdpf    ; old block start pointer low byte
217			=$ab																		Ostrth            = expneg    ; old block start pointer high  byte
219			=$aa																		Vrschl            = numdpf    ; variable search pointer low byte
220			=$ab																		Vrschh            = expneg    ; variable search pointer high  byte
222			=$ac																		FAC1_e            = $AC       ; FAC1 exponent
223			=173																		FAC1_1            = FAC1_e+1  ; FAC1 mantissa1
224			=174																		FAC1_2            = FAC1_e+2  ; FAC1 mantissa2
225			=175																		FAC1_3            = FAC1_e+3  ; FAC1 mantissa3
226			=176																		FAC1_s            = FAC1_e+4  ; FAC1 sign (b7)
228			=$ac																		str_ln            = FAC1_e    ; string length
229			=173																		str_pl            = FAC1_1    ; string pointer low byte
230			=174																		str_ph            = FAC1_2    ; string pointer high byte
232			=174																		des_pl            = FAC1_2    ; string descriptor pointer low byte
233			=175																		des_ph            = FAC1_3    ; string descriptor pointer high byte
235			=175																		mids_l            = FAC1_3    ; MID$ string temp length byte
237			=$b1																		negnum            = $B1       ; string to float eval -ve flag
238			=$b1																		numcon            = $B1       ; series evaluation constant count
240			=$b2																		FAC1_o            = $B2       ; FAC1 overflow byte
242			=$b3																		FAC2_e            = $B3       ; FAC2 exponent
243			=180																		FAC2_1            = FAC2_e+1  ; FAC2 mantissa1
244			=181																		FAC2_2            = FAC2_e+2  ; FAC2 mantissa2
245			=182																		FAC2_3            = FAC2_e+3  ; FAC2 mantissa3
246			=183																		FAC2_s            = FAC2_e+4  ; FAC2 sign (b7)
248			=$b8																		FAC_sc            = $B8       ; FAC sign comparison, Acc#1 vs #2
249			=$b9																		FAC1_r            = $B9       ; FAC1 rounding byte
251			=$b8																		ssptr_l           = FAC_sc    ; string start pointer low byte
252			=$b9																		ssptr_h           = FAC1_r    ; string start pointer high byte
254			=$b8																		sdescr            = FAC_sc    ; string descriptor pointer
256			=$ba																		csidx             = $BA       ; line crunch save index
257			=$ba																		Asptl             = csidx     ; array size/pointer low byte
258			=$bb																		Aspth             = $BB       ; array size/pointer high byte
260			=$ba																		Btmpl             = Asptl     ; BASIC pointer temp low byte
261			=$bb																		Btmph             = Aspth     ; BASIC pointer temp low byte
263			=$ba																		Cptrl             = Asptl     ; BASIC pointer temp low byte
264			=$bb																		Cptrh             = Aspth     ; BASIC pointer temp low byte
266			=$ba																		Sendl             = Asptl     ; BASIC pointer temp low byte
267			=$bb																		Sendh             = Aspth     ; BASIC pointer temp low byte
270			=$bc																		LAB_IGBY          = $BC       ; get next BASIC byte subroutine
272			=$c2																		LAB_GBYT          = $C2       ; get current BASIC byte subroutine
273			=$c3																		Bpntrl            = $C3       ; BASIC execute (get byte) pointer low byte
274			=196																		Bpntrh            = Bpntrl+1  ; BASIC execute (get byte) pointer high byte
279			=$d8																		Rbyte4            = $D8       ; extra PRNG byte
280			=217																		Rbyte1            = Rbyte4+1  ; most significant PRNG byte
281			=218																		Rbyte2            = Rbyte4+2  ; middle PRNG byte
282			=219																		Rbyte3            = Rbyte4+3  ; least significant PRNG byte
284			=$dc																		NmiBase           = $DC       ; NMI handler enabled/setup/triggered flags
292			=$df																		IrqBase           = $DF       ; IRQ handler enabled/setup/triggered flags
312			=$ef																		Decss             = $EF       ; number to decimal string start
313			=240																		Decssp1           = Decss+1   ; number to decimal string start
321			=$80																		TK_END            = $80             ; END token
322			=129																		TK_FOR            = TK_END+1        ; FOR token
323			=130																		TK_NEXT           = TK_FOR+1        ; NEXT token
324			=131																		TK_DATA           = TK_NEXT+1       ; DATA token
325			=132																		TK_INPUT          = TK_DATA+1       ; INPUT token
326			=133																		TK_DIM            = TK_INPUT+1      ; DIM token
327			=134																		TK_READ           = TK_DIM+1        ; READ token
328			=135																		TK_LET            = TK_READ+1       ; LET token
329			=136																		TK_DEC            = TK_LET+1        ; DEC token
330			=137																		TK_GOTO           = TK_DEC+1        ; GOTO token
331			=138																		TK_RUN            = TK_GOTO+1       ; RUN token
332			=139																		TK_IF             = TK_RUN+1        ; IF token
333			=140																		TK_RESTORE        = TK_IF+1         ; RESTORE token
334			=141																		TK_GOSUB          = TK_RESTORE+1    ; GOSUB token
335			=142																		TK_RETIRQ         = TK_GOSUB+1      ; RETIRQ token
336			=143																		TK_RETNMI         = TK_RETIRQ+1     ; RETNMI token
337			=144																		TK_RETURN         = TK_RETNMI+1     ; RETURN token
338			=145																		TK_REM            = TK_RETURN+1     ; REM token
339			=146																		TK_STOP           = TK_REM+1        ; STOP token
340			=147																		TK_ON             = TK_STOP+1       ; ON token
341			=148																		TK_NULL           = TK_ON+1         ; NULL token
342			=149																		TK_INC            = TK_NULL+1       ; INC token
343			=150																		TK_WAIT           = TK_INC+1        ; WAIT token
344			=151																		TK_LOAD           = TK_WAIT+1       ; LOAD token
345			=152																		TK_SAVE           = TK_LOAD+1       ; SAVE token
346			=153																		TK_DEF            = TK_SAVE+1       ; DEF token
347			=154																		TK_POKE           = TK_DEF+1        ; POKE token
348			=155																		TK_DOKE           = TK_POKE+1       ; DOKE token
349			=156																		TK_CALL           = TK_DOKE+1       ; CALL token
350			=157																		TK_DO             = TK_CALL+1       ; DO token
351			=158																		TK_LOOP           = TK_DO+1         ; LOOP token
352			=159																		TK_PRINT          = TK_LOOP+1       ; PRINT token
353			=160																		TK_CONT           = TK_PRINT+1      ; CONT token
354			=161																		TK_LIST           = TK_CONT+1       ; LIST token
355			=162																		TK_CLEAR          = TK_LIST+1       ; CLEAR token
356			=163																		TK_NEW            = TK_CLEAR+1      ; NEW token
357			=164																		TK_WIDTH          = TK_NEW+1        ; WIDTH token
358			=165																		TK_GET            = TK_WIDTH+1      ; GET token
359			=166																		TK_SWAP           = TK_GET+1        ; SWAP token
360			=167																		TK_BITSET         = TK_SWAP+1       ; BITSET token
361			=168																		TK_BITCLR         = TK_BITSET+1     ; BITCLR token
362			=169																		TK_IRQ            = TK_BITCLR+1     ; IRQ token
363			=170																		TK_NMI            = TK_IRQ+1        ; NMI token
367			=171																		TK_TAB            = TK_NMI+1        ; TAB token
368			=172																		TK_ELSE           = TK_TAB+1        ; ELSE token
369			=173																		TK_TO             = TK_ELSE+1       ; TO token
370			=174																		TK_FN             = TK_TO+1         ; FN token
371			=175																		TK_SPC            = TK_FN+1         ; SPC token
372			=176																		TK_THEN           = TK_SPC+1        ; THEN token
373			=177																		TK_NOT            = TK_THEN+1       ; NOT token
374			=178																		TK_STEP           = TK_NOT+1        ; STEP token
375			=179																		TK_UNTIL          = TK_STEP+1       ; UNTIL token
376			=180																		TK_WHILE          = TK_UNTIL+1      ; WHILE token
377			=181																		TK_OFF            = TK_WHILE+1      ; OFF token
381			=182																		TK_PLUS           = TK_OFF+1        ; + token
382			=183																		TK_MINUS          = TK_PLUS+1       ; - token
383			=184																		TK_MUL            = TK_MINUS+1      ; * token
384			=185																		TK_DIV            = TK_MUL+1        ; / token
385			=186																		TK_POWER          = TK_DIV+1        ; ^ token
386			=187																		TK_AND            = TK_POWER+1      ; AND token
387			=188																		TK_EOR            = TK_AND+1        ; EOR token
388			=189																		TK_OR             = TK_EOR+1        ; OR token
389			=190																		TK_RSHIFT         = TK_OR+1         ; RSHIFT token
390			=191																		TK_LSHIFT         = TK_RSHIFT+1     ; LSHIFT token
391			=192																		TK_GT             = TK_LSHIFT+1     ; > token
392			=193																		TK_EQUAL          = TK_GT+1         ; = token
393			=194																		TK_LT             = TK_EQUAL+1      ; < token
397			=195																		TK_SGN            = TK_LT+1         ; SGN token
398			=196																		TK_INT            = TK_SGN+1        ; INT token
399			=197																		TK_ABS            = TK_INT+1        ; ABS token
400			=198																		TK_USR            = TK_ABS+1        ; USR token
401			=199																		TK_FRE            = TK_USR+1        ; FRE token
402			=200																		TK_POS            = TK_FRE+1        ; POS token
403			=201																		TK_SQR            = TK_POS+1        ; SQR token
404			=202																		TK_RND            = TK_SQR+1        ; RND token
405			=203																		TK_LOG            = TK_RND+1        ; LOG token
406			=204																		TK_EXP            = TK_LOG+1        ; EXP token
407			=205																		TK_COS            = TK_EXP+1        ; COS token
408			=206																		TK_SIN            = TK_COS+1        ; SIN token
409			=207																		TK_TAN            = TK_SIN+1        ; TAN token
410			=208																		TK_ATN            = TK_TAN+1        ; ATN token
411			=209																		TK_PEEK           = TK_ATN+1        ; PEEK token
412			=210																		TK_DEEK           = TK_PEEK+1       ; DEEK token
413			=211																		TK_SADD           = TK_DEEK+1       ; SADD token
414			=212																		TK_LEN            = TK_SADD+1       ; LEN token
415			=213																		TK_STRS           = TK_LEN+1        ; STR$ token
416			=214																		TK_VAL            = TK_STRS+1       ; VAL token
417			=215																		TK_ASC            = TK_VAL+1        ; ASC token
418			=216																		TK_UCASES         = TK_ASC+1        ; UCASE$ token
419			=217																		TK_LCASES         = TK_UCASES+1     ; LCASE$ token
420			=218																		TK_CHRS           = TK_LCASES+1     ; CHR$ token
421			=219																		TK_HEXS           = TK_CHRS+1       ; HEX$ token
422			=220																		TK_BINS           = TK_HEXS+1       ; BIN$ token
423			=221																		TK_BITTST         = TK_BINS+1       ; BITTST token
424			=222																		TK_MAX            = TK_BITTST+1     ; MAX token
425			=223																		TK_MIN            = TK_MAX+1        ; MIN token
426			=224																		TK_PI             = TK_MIN+1        ; PI token
427			=225																		TK_TWOPI          = TK_PI+1         ; TWOPI token
428			=226																		TK_VPTR           = TK_TWOPI+1      ; VARPTR token
429			=227																		TK_LEFTS          = TK_VPTR+1       ; LEFT$ token
430			=228																		TK_RIGHTS         = TK_LEFTS+1      ; RIGHT$ token
431			=229																		TK_MIDS           = TK_RIGHTS+1     ; MID$ token
435			=$00																		PLUS_0            = $00       ; X or Y plus 0
436			=$01																		PLUS_1            = $01       ; X or Y plus 1
437			=$02																		PLUS_2            = $02       ; X or Y plus 2
438			=$03																		PLUS_3            = $03       ; X or Y plus 3
440			=$0100																	LAB_STAK          = $0100     ; stack bottom, no offset
442			=510																		LAB_SKFE          = LAB_STAK+$FE
444			=511																		LAB_SKFF          = LAB_STAK+$FF
448			=$0200																	ccflag            = $0200     ; BASIC CTRL-C flag, 00 = enabled, 01 = dis
449			=513																		ccbyte            = ccflag+1  ; BASIC CTRL-C byte
450			=514																		ccnull            = ccbyte+1  ; BASIC CTRL-C byte timeout
452			=515																		VEC_CC            = ccnull+1  ; ctrl c check vector
456			=517																		VEC_IN            = VEC_CC+2  ; input vector
457			=519																		VEC_OUT           = VEC_IN+2  ; output vector
458			=521																		VEC_LD            = VEC_OUT+2 ; load vector
459			=523																		VEC_SV            = VEC_LD+2  ; save vector
467			=545																		Ibuffs            = VEC_SV+$16
469			=616																		Ibuffe            = Ibuffs+$47; end of input buffer
471			=$0300																	Ram_base          = $0300     ; start of user RAM (set as needed, should be page aligned)
472			=$8000																	Ram_top           = $8000     ; end of user RAM+1 (set as needed, should be page aligned)
474			=16																			Stack_floor       = 16        ; bytes left free on stack for background interrupts
484			.8000																		LAB_COLD
485			.8000		a0 04						ldy #$04				      LDY   #PG2_TABE-PG2_TABS-1
487			.8002																		LAB_2D13
488			.8002		b9 05 a1				lda $a105,y			      LDA   PG2_TABS,Y        ; get byte
489			.8005		99 00 02				sta $0200,y			      STA   ccflag,Y          ; store in page 2
490			.8008		88							dey							      DEY                     ; decrement count
491			.8009		10 f7						bpl $8002				      BPL   LAB_2D13          ; loop if not done
493			.800b		a2 ff						ldx #$ff				      LDX   #$FF              ; set byte
494			.800d		86 88						stx $88					      STX   Clineh            ; set current line high byte (set immediate mode)
495			.800f		9a							txs							      TXS                     ; reset stack pointer
497			.8010		a9 4c						lda #$4c				      LDA   #$4C              ; code for JMP
498			.8012		85 a1						sta $a1					      STA   Fnxjmp            ; save for jump vector for functions
502			.8014		a2 1c						ldx #$1c				      LDX   #StrTab-LAB_2CEE  ; set byte count
503			.8016																		LAB_2D4E
504			.8016		bd 09 a1				lda $a109,x			      LDA   LAB_2CEE-1,X      ; get byte from table
505			.8019		95 bb						sta $bb,x				      STA   LAB_IGBY-1,X      ; save byte in page zero
506			.801b		ca							dex							      DEX                     ; decrement count
507			.801c		d0 f8						bne $8016				      BNE   LAB_2D4E          ; loop if not all done
511			.801e																		LAB_GMEM
512			.801e		a2 12						ldx #$12				      LDX   #EndTab-StrTab-1  ; set byte count-1
513			.8020																		TabLoop
514			.8020		bd 26 a1				lda $a126,x			      LDA   StrTab,X          ; get byte from table
515			.8023		95 00						sta $00,x				      STA   PLUS_0,X          ; save byte in page zero
516			.8025		ca							dex							      DEX                     ; decrement count
517			.8026		10 f8						bpl $8020				      BPL   TabLoop           ; loop if not all done
521			.8028		a9 00						lda #$00				      LDA   #$00              ; clear A
522			.802a		85 dc						sta $dc					      STA   NmiBase           ; clear NMI handler enabled flag
523			.802c		85 df						sta $df					      STA   IrqBase           ; clear IRQ handler enabled flag
524			.802e		85 b2						sta $b2					      STA   FAC1_o            ; clear FAC1 overflow byte
525			.8030		85 67						sta $67					      STA   last_sh           ; clear descriptor stack top item pointer high byte
527			.8032		a9 0e						lda #$0e				      LDA   #$0E              ; set default tab size
528			.8034		85 64						sta $64					      STA   TabSiz            ; save it
529			.8036		a9 03						lda #$03				      LDA   #$03              ; set garbage collect step size for descriptor stack
530			.8038		85 a0						sta $a0					      STA   g_step            ; save it
531			.803a		a2 68						ldx #$68				      LDX   #des_sk           ; descriptor stack start
532			.803c		86 65						stx $65					      STX   next_s            ; set descriptor stack pointer
533			.803e		20 93 88				jsr $8893				      JSR   LAB_CRLF          ; print CR/LF
534			.8041		a9 39						lda #$39				      LDA   #<LAB_MSZM        ; point to memory size message (low addr)
535			.8043		a0 a1						ldy #$a1				      LDY   #>LAB_MSZM        ; point to memory size message (high addr)
536			.8045		20 d4 88				jsr $88d4				      JSR   LAB_18C3          ; print null terminated string from memory
537			.8048		20 43 82				jsr $8243				      JSR   LAB_INLN          ; print "? " and get BASIC input
538			.804b		86 c3						stx $c3					      STX   Bpntrl            ; set BASIC execute pointer low byte
539			.804d		84 c4						sty $c4					      STY   Bpntrh            ; set BASIC execute pointer high byte
540			.804f		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; get last byte back
542			.8052		d0 1f						bne $8073				      BNE   LAB_2DAA          ; branch if not null (user typed something)
544			.8054		a0 00						ldy #$00				      LDY   #$00              ; else clear Y
547			.8056																		LAB_2D93
548			.8056		e6 11						inc $11					      INC   Itempl            ; increment temporary integer low byte
549			.8058		d0 08						bne $8062				      BNE   LAB_2D99          ; branch if no overflow
551			.805a		e6 12						inc $12					      INC   Itemph            ; increment temporary integer high byte
552			.805c		a5 12						lda $12					      LDA   Itemph            ; get high byte
553			.805e		c9 80						cmp #$80				      CMP   #>Ram_top         ; compare with top of RAM+1
554			.8060		f0 1d						beq $807f				      BEQ   LAB_2DB6          ; branch if match (end of user RAM)
556			.8062																		LAB_2D99
557			.8062		a9 55						lda #$55				      LDA   #$55              ; set test byte
558			.8064		91 11						sta ($11),y			      STA   (Itempl),Y        ; save via temporary integer
559			.8066		d1 11						cmp ($11),y			      CMP   (Itempl),Y        ; compare via temporary integer
560			.8068		d0 15						bne $807f				      BNE   LAB_2DB6          ; branch if fail
562			.806a		0a							asl a						      ASL                     ; shift test byte left (now $AA)
563			.806b		91 11						sta ($11),y			      STA   (Itempl),Y        ; save via temporary integer
564			.806d		d1 11						cmp ($11),y			      CMP   (Itempl),Y        ; compare via temporary integer
565			.806f		f0 e5						beq $8056				      BEQ   LAB_2D93          ; if ok go do next byte
567			.8071		d0 0c						bne $807f				      BNE   LAB_2DB6          ; branch if fail
569			.8073																		LAB_2DAA
570			.8073		20 b3 99				jsr $99b3				      JSR   LAB_2887          ; get FAC1 from string
571			.8076		a5 ac						lda $ac					      LDA   FAC1_e            ; get FAC1 exponent
572			.8078		c9 98						cmp #$98				      CMP   #$98              ; compare with exponent = 2^24
573			.807a		b0 a2						bcs $801e				      BCS   LAB_GMEM          ; if too large go try again
575			.807c		20 04 95				jsr $9504				      JSR   LAB_F2FU          ; save integer part of FAC1 in temporary integer
578			.807f																		LAB_2DB6
579			.807f		a5 11						lda $11					      LDA   Itempl            ; get temporary integer low byte
580			.8081		a4 12						ldy $12					      LDY   Itemph            ; get temporary integer high byte
585			.8083		c0 03						cpy #$03				      CPY   #>Ram_base+1      ; compare with start of RAM+$100 high byte
587			.8085		90 97						bcc $801e				      BCC   LAB_GMEM          ; if too small go try again
605			.8087		85 85						sta $85					      STA   Ememl             ; set end of mem low byte
606			.8089		84 86						sty $86					      STY   Ememh             ; set end of mem high byte
607			.808b		85 81						sta $81					      STA   Sstorl            ; set bottom of string space low byte
608			.808d		84 82						sty $82					      STY   Sstorh            ; set bottom of string space high byte
610			.808f		a0 00						ldy #$00				      LDY   #<Ram_base        ; set start addr low byte
611			.8091		a2 03						ldx #$03				      LDX   #>Ram_base        ; set start addr high byte
612			.8093		84 79						sty $79					      STY   Smeml             ; save start of mem low byte
613			.8095		86 7a						stx $7a					      STX   Smemh             ; save start of mem high byte
620			.8097		98							tya							      TYA                     ; clear A
621			.8098		91 79						sta ($79),y			      STA   (Smeml),Y         ; clear first byte
622			.809a		e6 79						inc $79					      INC   Smeml             ; increment start of mem low byte
631			.809c		20 93 88				jsr $8893				      JSR   LAB_CRLF          ; print CR/LF
632			.809f		20 53 83				jsr $8353				      JSR   LAB_1463          ; do "NEW" and "CLEAR"
633			.80a2		a5 85						lda $85					      LDA   Ememl             ; get end of mem low byte
634			.80a4		38							sec							      SEC                     ; set carry for subtract
635			.80a5		e5 79						sbc $79					      SBC   Smeml             ; subtract start of mem low byte
636			.80a7		aa							tax							      TAX                     ; copy to X
637			.80a8		a5 86						lda $86					      LDA   Ememh             ; get end of mem high byte
638			.80aa		e5 7a						sbc $7a					      SBC   Smemh             ; subtract start of mem high byte
639			.80ac		20 8f 9a				jsr $9a8f				      JSR   LAB_295E          ; print XA as unsigned integer (bytes free)
640			.80af		a9 48						lda #$48				      LDA   #<LAB_SMSG        ; point to sign-on message (low addr)
641			.80b1		a0 a1						ldy #$a1				      LDY   #>LAB_SMSG        ; point to sign-on message (high addr)
642			.80b3		20 d4 88				jsr $88d4				      JSR   LAB_18C3          ; print null terminated string from memory
643			.80b6		a9 5d						lda #$5d				      LDA   #<LAB_1274        ; warm start vector low byte
644			.80b8		a0 81						ldy #$81				      LDY   #>LAB_1274        ; warm start vector high byte
645			.80ba		85 01						sta $01					      STA   Wrmjpl            ; save warm start vector low byte
646			.80bc		84 02						sty $02					      STY   Wrmjph            ; save warm start vector high byte
647			.80be		6c 01 00				jmp ($0001)			      JMP   (Wrmjpl)          ; go do warm start
662			.80c1																		LAB_11CF
663			.80c1		20 0e 81				jsr $810e				      JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
665			.80c4		85 7f						sta $7f					      STA   Earryl            ; save new array mem end low byte
666			.80c6		84 80						sty $80					      STY   Earryh            ; save new array mem end high byte
672			.80c8																		LAB_11D6
673			.80c8		38							sec							      SEC                     ; set carry for subtract
674			.80c9		a5 a6						lda $a6					      LDA   Obendl            ; get block end low byte
675			.80cb		e5 aa						sbc $aa					      SBC   Ostrtl            ; subtract block start low byte
676			.80cd		a8							tay							      TAY                     ; copy MOD(block length/$100) byte to Y
677			.80ce		a5 a7						lda $a7					      LDA   Obendh            ; get block end high byte
678			.80d0		e5 ab						sbc $ab					      SBC   Ostrth            ; subtract block start high byte
679			.80d2		aa							tax							      TAX                     ; copy block length high byte to X
680			.80d3		e8							inx							      INX                     ; +1 to allow for count=0 exit
681			.80d4		98							tya							      TYA                     ; copy block length low byte to A
682			.80d5		f0 24						beq $80fb				      BEQ   LAB_120A          ; branch if length low byte=0
686			.80d7		38							sec							      SEC                     ; set carry for add + 1, two's complement
687			.80d8		49 ff						eor #$ff				      EOR   #$FF              ; invert low byte for subtract
688			.80da		65 a6						adc $a6					      ADC   Obendl            ; add block end low byte
690			.80dc		85 a6						sta $a6					      STA   Obendl            ; save corrected old block end low byte
691			.80de		b0 03						bcs $80e3				      BCS   LAB_11F3          ; branch if no underflow
693			.80e0		c6 a7						dec $a7					      DEC   Obendh            ; else decrement block end high byte
694			.80e2		38							sec							      SEC                     ; set carry for add + 1, two's complement
695			.80e3																		LAB_11F3
696			.80e3		98							tya							      TYA                     ; get MOD(block length/$100) byte
697			.80e4		49 ff						eor #$ff				      EOR   #$FF              ; invert low byte for subtract
698			.80e6		65 a4						adc $a4					      ADC   Nbendl            ; add destination end low byte
699			.80e8		85 a4						sta $a4					      STA   Nbendl            ; save modified new block end low byte
700			.80ea		b0 08						bcs $80f4				      BCS   LAB_1203          ; branch if no underflow
702			.80ec		c6 a5						dec $a5					      DEC   Nbendh            ; else decrement block end high byte
703			.80ee		90 04						bcc $80f4				      BCC   LAB_1203          ; branch always
705			.80f0																		LAB_11FF
706			.80f0		b1 a6						lda ($a6),y			      LDA   (Obendl),Y        ; get byte from source
707			.80f2		91 a4						sta ($a4),y			      STA   (Nbendl),Y        ; copy byte to destination
708			.80f4																		LAB_1203
709			.80f4		88							dey							      DEY                     ; decrement index
710			.80f5		d0 f9						bne $80f0				      BNE   LAB_11FF          ; loop until Y=0
713			.80f7		b1 a6						lda ($a6),y			      LDA   (Obendl),Y        ; get byte from source
714			.80f9		91 a4						sta ($a4),y			      STA   (Nbendl),Y        ; save byte to destination
715			.80fb																		LAB_120A
716			.80fb		c6 a7						dec $a7					      DEC   Obendh            ; decrement source pointer high byte
717			.80fd		c6 a5						dec $a5					      DEC   Nbendh            ; decrement destination pointer high byte
718			.80ff		ca							dex							      DEX                     ; decrement block count
719			.8100		d0 f2						bne $80f4				      BNE   LAB_1203          ; loop until count = $0
721			.8102		60							rts							      RTS
726			.8103																		LAB_1212
730			.8103		18							clc							      CLC                     ; prep ADC
731			.8104		69 10						adc #$10				      ADC   #Stack_floor      ; stack pointer lower limit before interrupts
734			.8106		85 78						sta $78					      STA   TempB             ; save result in temp byte
735			.8108		ba							tsx							      TSX                     ; copy stack
736			.8109		e4 78						cpx $78					      CPX   TempB             ; compare new "limit" with stack
737			.810b		90 30						bcc $813d				      BCC   LAB_OMER          ; if stack < limit do "Out of memory" error then warm start
739			.810d		60							rts							      RTS
744			.810e																		LAB_121F
745			.810e		c4 82						cpy $82					      CPY   Sstorh            ; compare bottom of string mem high byte
746			.8110		90 2a						bcc $813c				      BCC   LAB_124B          ; if less then exit (is ok)
748			.8112		d0 04						bne $8118				      BNE   LAB_1229          ; skip next test if greater (tested <)
751			.8114		c5 81						cmp $81					      CMP   Sstorl            ; compare with bottom of string mem low byte
752			.8116		90 24						bcc $813c				      BCC   LAB_124B          ; if less then exit (is ok)
755			.8118																		LAB_1229
756			.8118		48							pha							      PHA                     ; push addr low byte
757			.8119		a2 08						ldx #$08				      LDX   #$08              ; set index to save Adatal to expneg inclusive
758			.811b		98							tya							      TYA                     ; copy addr high byte (to push on stack)
761			.811c																		LAB_122D
762			.811c		48							pha							      PHA                     ; push byte
763			.811d		b5 a3						lda $a3,x				      LDA   Adatal-1,X        ; get byte from Adatal to expneg ( ,$00 not pushed)
764			.811f		ca							dex							      DEX                     ; decrement index
765			.8120		10 fa						bpl $811c				      BPL   LAB_122D          ; loop until all done
767			.8122		20 ef 91				jsr $91ef				      JSR   LAB_GARB          ; garbage collection routine
770			.8125		a2 00						ldx #$00				      LDX   #$00              ; clear the index to restore bytes
771			.8127																		LAB_1238
772			.8127		68							pla							      PLA                     ; pop byte
773			.8128		95 a4						sta $a4,x				      STA   Adatal,X          ; save byte to Adatal to expneg
774			.812a		e8							inx							      INX                     ; increment index
775			.812b		e0 08						cpx #$08				      CPX   #$08              ; compare with end + 1
776			.812d		30 f8						bmi $8127				      BMI   LAB_1238          ; loop if more to do
778			.812f		68							pla							      PLA                     ; pop addr high byte
779			.8130		a8							tay							      TAY                     ; copy back to Y
780			.8131		68							pla							      PLA                     ; pop addr low byte
781			.8132		c4 82						cpy $82					      CPY   Sstorh            ; compare bottom of string mem high byte
782			.8134		90 06						bcc $813c				      BCC   LAB_124B          ; if less then exit (is ok)
784			.8136		d0 05						bne $813d				      BNE   LAB_OMER          ; if greater do "Out of memory" error then warm start
787			.8138		c5 81						cmp $81					      CMP   Sstorl            ; compare with bottom of string mem low byte
788			.813a		b0 01						bcs $813d				      BCS   LAB_OMER          ; if >= do "Out of memory" error then warm start
791			.813c																		LAB_124B
792			.813c		60							rts							      RTS
796			.813d																		LAB_OMER
797			.813d		a2 0c						ldx #$0c				      LDX   #$0C              ; error code $0C ("Out of memory" error)
801			.813f																		LAB_XERR
802			.813f		20 93 88				jsr $8893				      JSR   LAB_CRLF          ; print CR/LF
804			.8142		bd ba a6				lda $a6ba,x			      LDA   LAB_BAER,X        ; get error message pointer low byte
805			.8145		bc bb a6				ldy $a6bb,x			      LDY   LAB_BAER+1,X      ; get error message pointer high byte
806			.8148		20 d4 88				jsr $88d4				      JSR   LAB_18C3          ; print null terminated string from memory
808			.814b		20 8c 83				jsr $838c				      JSR   LAB_1491          ; flush stack and clear continue flag
809			.814e		a9 f7						lda #$f7				      LDA   #<LAB_EMSG        ; point to " Error" low addr
810			.8150		a0 a7						ldy #$a7				      LDY   #>LAB_EMSG        ; point to " Error" high addr
811			.8152																		LAB_1269
812			.8152		20 d4 88				jsr $88d4				      JSR   LAB_18C3          ; print null terminated string from memory
813			.8155		a4 88						ldy $88					      LDY   Clineh            ; get current line high byte
814			.8157		c8							iny							      INY                     ; increment it
815			.8158		f0 03						beq $815d				      BEQ   LAB_1274          ; go do warm start (was immediate mode)
818			.815a		20 84 9a				jsr $9a84				      JSR   LAB_2953          ; print " in line [LINE #]"
823			.815d																		LAB_1274
825			.815d		a9 00						lda #$00				      LDA   #$00              ; clear A
826			.815f		85 df						sta $df					      STA   IrqBase           ; clear enabled byte
827			.8161		85 dc						sta $dc					      STA   NmiBase           ; clear enabled byte
828			.8163		a9 08						lda #$08				      LDA   #<LAB_RMSG        ; point to "Ready" message low byte
829			.8165		a0 a8						ldy #$a8				      LDY   #>LAB_RMSG        ; point to "Ready" message high byte
831			.8167		20 d4 88				jsr $88d4				      JSR   LAB_18C3          ; go do print string
835			.816a																		LAB_127D
836			.816a		20 50 82				jsr $8250				      JSR   LAB_1357          ; call for BASIC input
837			.816d																		LAB_1280
838			.816d		86 c3						stx $c3					      STX   Bpntrl            ; set BASIC execute pointer low byte
839			.816f		84 c4						sty $c4					      STY   Bpntrh            ; set BASIC execute pointer high byte
840			.8171		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; scan memory
841			.8174		f0 f4						beq $816a				      BEQ   LAB_127D          ; loop while null
845			.8176		a2 ff						ldx #$ff				      LDX   #$FF              ; current line to null value
846			.8178		86 88						stx $88					      STX   Clineh            ; set current line high byte
847			.817a		90 06						bcc $8182				      BCC   LAB_1295          ; branch if numeric character (handle new BASIC line)
850			.817c		20 81 82				jsr $8281				      JSR   LAB_13A6          ; crunch keywords into Basic tokens
851			.817f		4c f5 84				jmp $84f5				      JMP   LAB_15F6          ; go scan and interpret code
855			.8182																		LAB_1295
856			.8182		20 56 87				jsr $8756				      JSR   LAB_GFPN          ; get fixed-point number into temp integer
857			.8185		20 81 82				jsr $8281				      JSR   LAB_13A6          ; crunch keywords into Basic tokens
858			.8188		84 5d						sty $5d					      STY   Ibptr             ; save index pointer to end of crunched line
859			.818a		20 27 83				jsr $8327				      JSR   LAB_SSLN          ; search BASIC for temp integer line number
860			.818d		90 44						bcc $81d3				      BCC   LAB_12E6          ; branch if not found
863			.818f		a0 01						ldy #$01				      LDY   #$01              ; set index to next line pointer high byte
864			.8191		b1 aa						lda ($aa),y			      LDA   (Baslnl),Y        ; get next line pointer high byte
865			.8193		85 72						sta $72					      STA   ut1_ph            ; save it
866			.8195		a5 7b						lda $7b					      LDA   Svarl             ; get start of vars low byte
867			.8197		85 71						sta $71					      STA   ut1_pl            ; save it
868			.8199		a5 ab						lda $ab					      LDA   Baslnh            ; get found line pointer high byte
869			.819b		85 74						sta $74					      STA   ut2_ph            ; save it
870			.819d		a5 aa						lda $aa					      LDA   Baslnl            ; get found line pointer low byte
871			.819f		88							dey							      DEY                     ; decrement index
872			.81a0		f1 aa						sbc ($aa),y			      SBC   (Baslnl),Y        ; subtract next line pointer low byte
873			.81a2		18							clc							      CLC                     ; clear carry for add
874			.81a3		65 7b						adc $7b					      ADC   Svarl             ; add start of vars low byte
875			.81a5		85 7b						sta $7b					      STA   Svarl             ; save new start of vars low byte
876			.81a7		85 73						sta $73					      STA   ut2_pl            ; save destination pointer low byte
877			.81a9		a5 7c						lda $7c					      LDA   Svarh             ; get start of vars high byte
878			.81ab		69 ff						adc #$ff				      ADC   #$FF              ; -1 + carry
879			.81ad		85 7c						sta $7c					      STA   Svarh             ; save start of vars high byte
880			.81af		e5 ab						sbc $ab					      SBC   Baslnh            ; subtract found line pointer high byte
881			.81b1		aa							tax							      TAX                     ; copy to block count
882			.81b2		38							sec							      SEC                     ; set carry for subtract
883			.81b3		a5 aa						lda $aa					      LDA   Baslnl            ; get found line pointer low byte
884			.81b5		e5 7b						sbc $7b					      SBC   Svarl             ; subtract start of vars low byte
885			.81b7		a8							tay							      TAY                     ; copy to bytes in first block count
886			.81b8		b0 03						bcs $81bd				      BCS   LAB_12D0          ; branch if overflow
888			.81ba		e8							inx							      INX                     ; increment block count (correct for =0 loop exit)
889			.81bb		c6 74						dec $74					      DEC   ut2_ph            ; decrement destination high byte
890			.81bd																		LAB_12D0
891			.81bd		18							clc							      CLC                     ; clear carry for add
892			.81be		65 71						adc $71					      ADC   ut1_pl            ; add source pointer low byte
893			.81c0		90 03						bcc $81c5				      BCC   LAB_12D8          ; branch if no overflow
895			.81c2		c6 72						dec $72					      DEC   ut1_ph            ; else decrement source pointer high byte
896			.81c4		18							clc							      CLC                     ; clear carry
899			.81c5																		LAB_12D8
900			.81c5		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get byte from source
901			.81c7		91 73						sta ($73),y			      STA   (ut2_pl),Y        ; copy to destination
902			.81c9		c8							iny							      INY                     ; increment index
903			.81ca		d0 f9						bne $81c5				      BNE   LAB_12D8          ; while <> 0 do this block
905			.81cc		e6 72						inc $72					      INC   ut1_ph            ; increment source pointer high byte
906			.81ce		e6 74						inc $74					      INC   ut2_ph            ; increment destination pointer high byte
907			.81d0		ca							dex							      DEX                     ; decrement block count
908			.81d1		d0 f2						bne $81c5				      BNE   LAB_12D8          ; loop until all done
911			.81d3																		LAB_12E6
912			.81d3		ad 21 02				lda $0221				      LDA   Ibuffs            ; get byte from start of input buffer
913			.81d6		f0 3f						beq $8217				      BEQ   LAB_1319          ; if null line just go flush stack/vars and exit
916			.81d8		a5 85						lda $85					      LDA   Ememl             ; get end of mem low byte
917			.81da		a4 86						ldy $86					      LDY   Ememh             ; get end of mem high byte
918			.81dc		85 81						sta $81					      STA   Sstorl            ; set bottom of string space low byte
919			.81de		84 82						sty $82					      STY   Sstorh            ; set bottom of string space high byte
920			.81e0		a5 7b						lda $7b					      LDA   Svarl             ; get start of vars low byte  (end of BASIC)
921			.81e2		85 a6						sta $a6					      STA   Obendl            ; save old block end low byte
922			.81e4		a4 7c						ldy $7c					      LDY   Svarh             ; get start of vars high byte (end of BASIC)
923			.81e6		84 a7						sty $a7					      STY   Obendh            ; save old block end high byte
924			.81e8		65 5d						adc $5d					      ADC   Ibptr             ; add input buffer pointer    (also buffer length)
925			.81ea		90 01						bcc $81ed				      BCC   LAB_1301          ; branch if no overflow from add
927			.81ec		c8							iny							      INY                     ; else increment high byte
928			.81ed																		LAB_1301
929			.81ed		85 a4						sta $a4					      STA   Nbendl            ; save new block end low byte (move to, low byte)
930			.81ef		84 a5						sty $a5					      STY   Nbendh            ; save new block end high byte
931			.81f1		20 c1 80				jsr $80c1				      JSR   LAB_11CF          ; open up space in memory
933			.81f4		a5 7f						lda $7f					      LDA   Earryl            ; get array mem end low byte
934			.81f6		a4 80						ldy $80					      LDY   Earryh            ; get array mem end high byte
935			.81f8		85 7b						sta $7b					      STA   Svarl             ; save start of vars low byte
936			.81fa		84 7c						sty $7c					      STY   Svarh             ; save start of vars high byte
937			.81fc		a4 5d						ldy $5d					      LDY   Ibptr             ; get input buffer pointer    (also buffer length)
938			.81fe		88							dey							      DEY                     ; adjust for loop type
939			.81ff																		LAB_1311
940			.81ff		b9 1d 02				lda $021d,y			      LDA   Ibuffs-4,Y        ; get byte from crunched line
941			.8202		91 aa						sta ($aa),y			      STA   (Baslnl),Y        ; save it to program memory
942			.8204		88							dey							      DEY                     ; decrement count
943			.8205		c0 03						cpy #$03				      CPY   #$03              ; compare with first byte-1
944			.8207		d0 f6						bne $81ff				      BNE   LAB_1311          ; continue while count <> 3
946			.8209		a5 12						lda $12					      LDA   Itemph            ; get line # high byte
947			.820b		91 aa						sta ($aa),y			      STA   (Baslnl),Y        ; save it to program memory
948			.820d		88							dey							      DEY                     ; decrement count
949			.820e		a5 11						lda $11					      LDA   Itempl            ; get line # low byte
950			.8210		91 aa						sta ($aa),y			      STA   (Baslnl),Y        ; save it to program memory
951			.8212		88							dey							      DEY                     ; decrement count
952			.8213		a9 ff						lda #$ff				      LDA   #$FF              ; set byte to allow chain rebuild. if you didn't set this
955			.8215		91 aa						sta ($aa),y			      STA   (Baslnl),Y        ; save it to program memory
957			.8217																		LAB_1319
958			.8217		20 68 83				jsr $8368				      JSR   LAB_1477          ; reset execution to start, clear vars and flush stack
959			.821a		a6 79						ldx $79					      LDX   Smeml             ; get start of mem low byte
960			.821c		a5 7a						lda $7a					      LDA   Smemh             ; get start of mem high byte
961			.821e		a0 01						ldy #$01				      LDY   #$01              ; index to high byte of next line pointer
962			.8220																		LAB_1325
963			.8220		86 71						stx $71					      STX   ut1_pl            ; set line start pointer low byte
964			.8222		85 72						sta $72					      STA   ut1_ph            ; set line start pointer high byte
965			.8224		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get it
966			.8226		f0 18						beq $8240				      BEQ   LAB_133E          ; exit if end of program
970			.8228		a0 04						ldy #$04				      LDY   #$04              ; point to first code byte of line
972			.822a																		LAB_1330
973			.822a		c8							iny							      INY                     ; next code byte
974			.822b		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get byte
975			.822d		d0 fb						bne $822a				      BNE   LAB_1330          ; loop if not [EOL]
977			.822f		38							sec							      SEC                     ; set carry for add + 1
978			.8230		98							tya							      TYA                     ; copy end index
979			.8231		65 71						adc $71					      ADC   ut1_pl            ; add to line start pointer low byte
980			.8233		aa							tax							      TAX                     ; copy to X
981			.8234		a0 00						ldy #$00				      LDY   #$00              ; clear index, point to this line's next line pointer
982			.8236		91 71						sta ($71),y			      STA   (ut1_pl),Y        ; set next line pointer low byte
983			.8238		98							tya							      TYA                     ; clear A
984			.8239		65 72						adc $72					      ADC   ut1_ph            ; add line start pointer high byte + carry
985			.823b		c8							iny							      INY                     ; increment index to high byte
986			.823c		91 71						sta ($71),y			      STA   (ut1_pl),Y        ; save next line pointer low byte
987			.823e		90 e0						bcc $8220				      BCC   LAB_1325          ; go do next line, branch always, carry clear
990			.8240																		LAB_133E
991			.8240		4c 6a 81				jmp $816a				      JMP   LAB_127D          ; else we just wait for Basic command, no "Ready"
995			.8243																		LAB_INLN
996			.8243		20 ec 88				jsr $88ec				      JSR   LAB_18E3          ; print "?" character
997			.8246		20 e9 88				jsr $88e9				      JSR   LAB_18E0          ; print " "
998			.8249		d0 05						bne $8250				      BNE   LAB_1357          ; call for BASIC input and return
1003		.824b																		LAB_134B
1004		.824b		20 ee 88				jsr $88ee				      JSR   LAB_PRNA          ; go print the character
1005		.824e		ca							dex							      DEX                     ; decrement the buffer counter (delete)
1006		>824f		2c															      .byte $2C               ; make LDX into BIT abs
1010		.8250																		LAB_1357
1011		.8250		a2 00						ldx #$00				      LDX   #$00              ; clear BASIC line buffer pointer
1012		.8252																		LAB_1359
1013		.8252		20 f9 a0				jsr $a0f9				      JSR   V_INPT            ; call scan input device
1014		.8255		90 fb						bcc $8252				      BCC   LAB_1359          ; loop if no byte
1016		.8257		f0 f9						beq $8252				      BEQ   LAB_1359          ; loop until valid input (ignore NULLs)
1018		.8259		c9 07						cmp #$07				      CMP   #$07              ; compare with [BELL]
1019		.825b		f0 10						beq $826d				      BEQ   LAB_1378          ; branch if [BELL]
1021		.825d		c9 0d						cmp #$0d				      CMP   #$0D              ; compare with [CR]
1022		.825f		f0 19						beq $827a				      BEQ   LAB_1384          ; do CR/LF exit if [CR]
1024		.8261		e0 00						cpx #$00				      CPX   #$00              ; compare pointer with $00
1025		.8263		d0 04						bne $8269				      BNE   LAB_1374          ; branch if not empty
1029		.8265		c9 21						cmp #$21				      CMP   #$21              ; compare with [SP]+1
1030		.8267		90 e9						bcc $8252				      BCC   LAB_1359          ; if < ignore character
1032		.8269																		LAB_1374
1033		.8269		c9 08						cmp #$08				      CMP   #$08              ; compare with [BACKSPACE] (delete last character)
1034		.826b		f0 de						beq $824b				      BEQ   LAB_134B          ; go delete last character
1036		.826d																		LAB_1378
1037		.826d		e0 47						cpx #$47				      CPX   #Ibuffe-Ibuffs    ; compare character count with max
1038		.826f		b0 0c						bcs $827d				      BCS   LAB_138E          ; skip store and do [BELL] if buffer full
1040		.8271		9d 21 02				sta $0221,x			      STA   Ibuffs,X          ; else store in buffer
1041		.8274		e8							inx							      INX                     ; increment pointer
1042		.8275																		LAB_137F
1043		.8275		20 ee 88				jsr $88ee				      JSR   LAB_PRNA          ; go print the character
1044		.8278		d0 d8						bne $8252				      BNE   LAB_1359          ; always loop for next character
1046		.827a																		LAB_1384
1047		.827a		4c 8a 88				jmp $888a				      JMP   LAB_1866          ; do CR/LF exit to BASIC
1051		.827d																		LAB_138E
1052		.827d		a9 07						lda #$07				      LDA   #$07              ; [BELL] character into A
1053		.827f		d0 f4						bne $8275				      BNE   LAB_137F          ; go print the [BELL] but ignore input character
1060		.8281																		LAB_13A6
1061		.8281		a0 ff						ldy #$ff				      LDY   #$FF              ; set save index (makes for easy math later)
1063		.8283		38							sec							      SEC                     ; set carry for subtract
1064		.8284		a5 c3						lda $c3					      LDA   Bpntrl            ; get basic execute pointer low byte
1065		.8286		e9 21						sbc #$21				      SBC   #<Ibuffs          ; subtract input buffer start pointer
1066		.8288		aa							tax							      TAX                     ; copy result to X (index past line # if any)
1068		.8289		86 60						stx $60					      STX   Oquote            ; clear open quote/DATA flag
1069		.828b																		LAB_13AC
1070		.828b		bd 21 02				lda $0221,x			      LDA   Ibuffs,X          ; get byte from input buffer
1071		.828e		f0 51						beq $82e1				      BEQ   LAB_13EC          ; if null save byte then exit
1073		.8290		c9 5f						cmp #$5f				      CMP   #'_'              ; compare with "_"
1074		.8292		b0 4d						bcs $82e1				      BCS   LAB_13EC          ; if >= go save byte then continue crunching
1076		.8294		c9 3c						cmp #$3c				      CMP   #'<'              ; compare with "<"
1077		.8296		b0 0e						bcs $82a6				      BCS   LAB_13CC          ; if >= go crunch now
1079		.8298		c9 30						cmp #$30				      CMP   #'0'              ; compare with "0"
1080		.829a		b0 45						bcs $82e1				      BCS   LAB_13EC          ; if >= go save byte then continue crunching
1082		.829c		85 5c						sta $5c					      STA   Scnquo            ; save buffer byte as search character
1083		.829e		c9 22						cmp #$22				      CMP   #$22              ; is it quote character?
1084		.82a0		f0 61						beq $8303				      BEQ   LAB_1410          ; branch if so (copy quoted string)
1086		.82a2		c9 2a						cmp #$2a				      CMP   #'*'              ; compare with "*"
1087		.82a4		90 3b						bcc $82e1				      BCC   LAB_13EC          ; if < go save byte then continue crunching
1090		.82a6																		LAB_13CC
1091		.82a6		24 60						bit $60					      BIT   Oquote            ; get open quote/DATA token flag
1092		.82a8		70 37						bvs $82e1				      BVS   LAB_13EC          ; branch if b6 of Oquote set (was DATA)
1095		.82aa		86 78						stx $78					      STX   TempB             ; save buffer read index
1096		.82ac		84 ba						sty $ba					      STY   csidx             ; copy buffer save index
1097		.82ae		a0 21						ldy #$21				      LDY   #<TAB_1STC        ; get keyword first character table low address
1098		.82b0		84 73						sty $73					      STY   ut2_pl            ; save pointer low byte
1099		.82b2		a0 a3						ldy #$a3				      LDY   #>TAB_1STC        ; get keyword first character table high address
1100		.82b4		84 74						sty $74					      STY   ut2_ph            ; save pointer high byte
1101		.82b6		a0 00						ldy #$00				      LDY   #$00              ; clear table pointer
1103		.82b8																		LAB_13D0
1104		.82b8		d1 73						cmp ($73),y			      CMP   (ut2_pl),Y        ; compare with keyword first character table byte
1105		.82ba		f0 05						beq $82c1				      BEQ   LAB_13D1          ; go do word_table_chr if match
1107		.82bc		90 21						bcc $82df				      BCC   LAB_13EA          ; if < keyword first character table byte go restore
1110		.82be		c8							iny							      INY                     ; else increment pointer
1111		.82bf		d0 f7						bne $82b8				      BNE   LAB_13D0          ; and loop (branch always)
1115		.82c1																		LAB_13D1
1116		.82c1		98							tya							      TYA                     ; copy matching index
1117		.82c2		0a							asl a						      ASL                     ; *2 (bytes per pointer)
1118		.82c3		aa							tax							      TAX                     ; copy to new index
1119		.82c4		bd 3f a3				lda $a33f,x			      LDA   TAB_CHRT,X        ; get keyword table pointer low byte
1120		.82c7		85 73						sta $73					      STA   ut2_pl            ; save pointer low byte
1121		.82c9		bd 40 a3				lda $a340,x			      LDA   TAB_CHRT+1,X      ; get keyword table pointer high byte
1122		.82cc		85 74						sta $74					      STA   ut2_ph            ; save pointer high byte
1124		.82ce		a0 ff						ldy #$ff				      LDY   #$FF              ; clear table pointer (make -1 for start)
1126		.82d0		a6 78						ldx $78					      LDX   TempB             ; restore buffer read index
1128		.82d2																		LAB_13D6
1129		.82d2		c8							iny							      INY                     ; next table byte
1130		.82d3		b1 73						lda ($73),y			      LDA   (ut2_pl),Y        ; get byte from table
1131		.82d5																		LAB_13D8
1132		.82d5		30 08						bmi $82df				      BMI   LAB_13EA          ; all bytes matched so go save token
1134		.82d7		e8							inx							      INX                     ; next buffer byte
1135		.82d8		dd 21 02				cmp $0221,x			      CMP   Ibuffs,X          ; compare with byte from input buffer
1136		.82db		f0 f5						beq $82d2				      BEQ   LAB_13D6          ; go compare next if match
1138		.82dd		d0 2b						bne $830a				      BNE   LAB_1417          ; branch if >< (not found keyword)
1140		.82df																		LAB_13EA
1141		.82df		a4 ba						ldy $ba					      LDY   csidx             ; restore save index
1144		.82e1																		LAB_13EC
1145		.82e1		e8							inx							      INX                     ; increment buffer index (to next input byte)
1146		.82e2		c8							iny							      INY                     ; increment save index (to next output byte)
1147		.82e3		99 21 02				sta $0221,y			      STA   Ibuffs,Y          ; save byte to output
1148		.82e6		c9 00						cmp #$00				      CMP   #$00              ; set the flags, set carry
1149		.82e8		f0 32						beq $831c				      BEQ   LAB_142A          ; do exit if was null [EOL]
1152		.82ea		e9 3a						sbc #$3a				      SBC   #':'              ; subtract ":" (carry set by CMP #00)
1153		.82ec		f0 04						beq $82f2				      BEQ   LAB_13FF          ; branch if it was ":" (is now $00)
1156		.82ee		c9 49						cmp #$49				      CMP   #TK_DATA-$3A      ; compare with DATA token - $3A
1157		.82f0		d0 02						bne $82f4				      BNE   LAB_1401          ; branch if not DATA
1160		.82f2																		LAB_13FF
1161		.82f2		85 60						sta $60					      STA   Oquote            ; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
1162		.82f4																		LAB_1401
1163		.82f4		49 57						eor #$57				      EOR   #TK_REM-$3A       ; effectively subtract REM token offset
1164		.82f6		d0 93						bne $828b				      BNE   LAB_13AC          ; If wasn't REM then go crunch rest of line
1166		.82f8		85 5c						sta $5c					      STA   Asrch             ; else was REM so set search for [EOL]
1169		.82fa																		LAB_1408
1170		.82fa		bd 21 02				lda $0221,x			      LDA   Ibuffs,X          ; get byte from input buffer
1171		.82fd		f0 e2						beq $82e1				      BEQ   LAB_13EC          ; branch if null [EOL]
1173		.82ff		c5 5c						cmp $5c					      CMP   Asrch             ; compare with stored character
1174		.8301		f0 de						beq $82e1				      BEQ   LAB_13EC          ; branch if match (end quote)
1177		.8303																		LAB_1410
1178		.8303		c8							iny							      INY                     ; increment buffer save index
1179		.8304		99 21 02				sta $0221,y			      STA   Ibuffs,Y          ; save byte to output
1180		.8307		e8							inx							      INX                     ; increment buffer read index
1181		.8308		d0 f0						bne $82fa				      BNE   LAB_1408          ; loop while <> 0 (should never be 0!)
1184		.830a																		LAB_1417
1185		.830a		a6 78						ldx $78					      LDX   TempB             ; compare has failed, restore buffer index (start byte!)
1188		.830c																		LAB_141B
1189		.830c		b1 73						lda ($73),y			      LDA   (ut2_pl),Y        ; get table byte
1190		.830e		08							php							      PHP                     ; save status
1191		.830f		c8							iny							      INY                     ; increment table index
1192		.8310		28							plp							      PLP                     ; restore byte status
1193		.8311		10 f9						bpl $830c				      BPL   LAB_141B          ; if not end of keyword go do next
1195		.8313		b1 73						lda ($73),y			      LDA   (ut2_pl),Y        ; get byte from keyword table
1196		.8315		d0 be						bne $82d5				      BNE   LAB_13D8          ; go test next word if not zero byte (end of table)
1199		.8317		bd 21 02				lda $0221,x			      LDA   Ibuffs,X          ; restore byte from input buffer
1200		.831a		10 c3						bpl $82df				      BPL   LAB_13EA          ; branch always (all bytes in buffer are $00-$7F)
1204		.831c																		LAB_142A
1205		.831c		c8							iny							      INY                     ; increment pointer
1206		.831d		c8							iny							      INY                     ; increment pointer (makes it next line pointer high byte)
1207		.831e		99 21 02				sta $0221,y			      STA   Ibuffs,Y          ; save [EOL] (marks [EOT] in immediate mode)
1208		.8321		c8							iny							      INY                     ; adjust for line copy
1209		.8322		c8							iny							      INY                     ; adjust for line copy
1210		.8323		c8							iny							      INY                     ; adjust for line copy
1221		.8324		c6 c3						dec $c3					      DEC   Bpntrl            ; allow for increment
1222		.8326		60							rts							      RTS
1226		.8327																		LAB_SSLN
1227		.8327		a5 79						lda $79					      LDA   Smeml             ; get start of mem low byte
1228		.8329		a6 7a						ldx $7a					      LDX   Smemh             ; get start of mem high byte
1236		.832b																		LAB_SHLN
1237		.832b		a0 01						ldy #$01				      LDY   #$01              ; set index
1238		.832d		85 aa						sta $aa					      STA   Baslnl            ; save low byte as current
1239		.832f		86 ab						stx $ab					      STX   Baslnh            ; save high byte as current
1240		.8331		b1 aa						lda ($aa),y			      LDA   (Baslnl),Y        ; get pointer high byte from addr
1241		.8333		f0 1a						beq $834f				      BEQ   LAB_145F          ; pointer was zero so we're done, do 'not found' exit
1243		.8335		a0 03						ldy #$03				      LDY   #$03              ; set index to line # high byte
1244		.8337		b1 aa						lda ($aa),y			      LDA   (Baslnl),Y        ; get line # high byte
1245		.8339		88							dey							      DEY                     ; decrement index (point to low byte)
1246		.833a		c5 12						cmp $12					      CMP   Itemph            ; compare with temporary integer high byte
1247		.833c		d0 04						bne $8342				      BNE   LAB_1455          ; if <> skip low byte check
1249		.833e		b1 aa						lda ($aa),y			      LDA   (Baslnl),Y        ; get line # low byte
1250		.8340		c5 11						cmp $11					      CMP   Itempl            ; compare with temporary integer low byte
1251		.8342																		LAB_1455
1252		.8342		b0 09						bcs $834d				      BCS   LAB_145E          ; else if temp < this line, exit (passed line#)
1254		.8344																		LAB_1456
1255		.8344		88							dey							      DEY                     ; decrement index to next line ptr high byte
1256		.8345		b1 aa						lda ($aa),y			      LDA   (Baslnl),Y        ; get next line pointer high byte
1257		.8347		aa							tax							      TAX                     ; copy to X
1258		.8348		88							dey							      DEY                     ; decrement index to next line ptr low byte
1259		.8349		b1 aa						lda ($aa),y			      LDA   (Baslnl),Y        ; get next line pointer low byte
1260		.834b		90 de						bcc $832b				      BCC   LAB_SHLN          ; go search for line # in temp (Itempl/Itemph) from AX
1263		.834d																		LAB_145E
1264		.834d		f0 01						beq $8350				      BEQ   LAB_1460          ; exit if temp = found line #, carry is set
1266		.834f																		LAB_145F
1267		.834f		18							clc							      CLC                     ; clear found flag
1268		.8350																		LAB_1460
1269		.8350		60							rts							      RTS
1273		.8351																		LAB_NEW
1274		.8351		d0 fd						bne $8350				      BNE   LAB_1460          ; exit if not end of statement (to do syntax error)
1276		.8353																		LAB_1463
1277		.8353		a9 00						lda #$00				      LDA   #$00              ; clear A
1278		.8355		a8							tay							      TAY                     ; clear Y
1279		.8356		91 79						sta ($79),y			      STA   (Smeml),Y         ; clear first line, next line pointer, low byte
1280		.8358		c8							iny							      INY                     ; increment index
1281		.8359		91 79						sta ($79),y			      STA   (Smeml),Y         ; clear first line, next line pointer, high byte
1282		.835b		18							clc							      CLC                     ; clear carry
1283		.835c		a5 79						lda $79					      LDA   Smeml             ; get start of mem low byte
1284		.835e		69 02						adc #$02				      ADC   #$02              ; calculate end of BASIC low byte
1285		.8360		85 7b						sta $7b					      STA   Svarl             ; save start of vars low byte
1286		.8362		a5 7a						lda $7a					      LDA   Smemh             ; get start of mem high byte
1287		.8364		69 00						adc #$00				      ADC   #$00              ; add any carry
1288		.8366		85 7c						sta $7c					      STA   Svarh             ; save start of vars high byte
1292		.8368																		LAB_1477
1293		.8368		18							clc							      CLC                     ; clear carry
1294		.8369		a5 79						lda $79					      LDA   Smeml             ; get start of mem low byte
1295		.836b		69 ff						adc #$ff				      ADC   #$FF              ; -1
1296		.836d		85 c3						sta $c3					      STA   Bpntrl            ; save BASIC execute pointer low byte
1297		.836f		a5 7a						lda $7a					      LDA   Smemh             ; get start of mem high byte
1298		.8371		69 ff						adc #$ff				      ADC   #$FF              ; -1+carry
1299		.8373		85 c4						sta $c4					      STA   Bpntrh            ; save BASIC execute pointer high byte
1303		.8375																		LAB_147A
1304		.8375		a5 85						lda $85					      LDA   Ememl             ; get end of mem low byte
1305		.8377		a4 86						ldy $86					      LDY   Ememh             ; get end of mem high byte
1306		.8379		85 81						sta $81					      STA   Sstorl            ; set bottom of string space low byte
1307		.837b		84 82						sty $82					      STY   Sstorh            ; set bottom of string space high byte
1308		.837d		a5 7b						lda $7b					      LDA   Svarl             ; get start of vars low byte
1309		.837f		a4 7c						ldy $7c					      LDY   Svarh             ; get start of vars high byte
1310		.8381		85 7d						sta $7d					      STA   Sarryl            ; save var mem end low byte
1311		.8383		84 7e						sty $7e					      STY   Sarryh            ; save var mem end high byte
1312		.8385		85 7f						sta $7f					      STA   Earryl            ; save array mem end low byte
1313		.8387		84 80						sty $80					      STY   Earryh            ; save array mem end high byte
1314		.8389		20 40 85				jsr $8540				      JSR   LAB_161A          ; perform RESTORE command
1318		.838c																		LAB_1491
1319		.838c		a2 68						ldx #$68				      LDX   #des_sk           ; set descriptor stack pointer
1320		.838e		86 65						stx $65					      STX   next_s            ; save descriptor stack pointer
1321		.8390		68							pla							      PLA                     ; pull return address low byte
1322		.8391		aa							tax							      TAX                     ; copy return address low byte
1323		.8392		68							pla							      PLA                     ; pull return address high byte
1324		.8393		8e fe 01				stx $01fe				      STX   LAB_SKFE          ; save to cleared stack
1325		.8396		8d ff 01				sta $01ff				      STA   LAB_SKFF          ; save to cleared stack
1326		.8399		a2 fd						ldx #$fd				      LDX   #$FD              ; new stack pointer
1327		.839b		9a							txs							      TXS                     ; reset stack
1328		.839c		a9 00						lda #$00				      LDA   #$00              ; clear byte
1331		.839e		85 61						sta $61					      STA   Sufnxf            ; clear subscript/FNX flag
1332		.83a0																		LAB_14A6
1333		.83a0		60							rts							      RTS
1337		.83a1																		LAB_CLEAR
1338		.83a1		f0 d2						beq $8375				      BEQ   LAB_147A          ; if no following token go do "CLEAR"
1341		.83a3		60							rts							      RTS
1346		.83a4																		LAB_LIST
1347		.83a4		90 06						bcc $83ac				      BCC   LAB_14BD          ; branch if next character numeric (LIST n..)
1349		.83a6		f0 04						beq $83ac				      BEQ   LAB_14BD          ; branch if next character [NULL] (LIST)
1351		.83a8		c9 b7						cmp #$b7				      CMP   #TK_MINUS         ; compare with token for -
1352		.83aa		d0 f4						bne $83a0				      BNE   LAB_14A6          ; exit if not - (LIST -m)
1356		.83ac																		LAB_14BD
1357		.83ac		20 56 87				jsr $8756				      JSR   LAB_GFPN          ; get fixed-point number into temp integer
1358		.83af		20 27 83				jsr $8327				      JSR   LAB_SSLN          ; search BASIC for temp integer line number
1360		.83b2		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; scan memory
1361		.83b5		f0 0c						beq $83c3				      BEQ   LAB_14D4          ; branch if no more characters
1364		.83b7		c9 b7						cmp #$b7				      CMP   #TK_MINUS         ; compare with token for -
1365		.83b9		d0 95						bne $8350				      BNE   LAB_1460          ; return if not "-" (will be Syntax error)
1369		.83bb		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment and scan memory
1370		.83be		20 56 87				jsr $8756				      JSR   LAB_GFPN          ; get fixed-point number into temp integer
1371		.83c1		d0 8d						bne $8350				      BNE   LAB_1460          ; exit if not ok
1373		.83c3																		LAB_14D4
1374		.83c3		a5 11						lda $11					      LDA   Itempl            ; get temporary integer low byte
1375		.83c5		05 12						ora $12					      ORA   Itemph            ; OR temporary integer high byte
1376		.83c7		d0 06						bne $83cf				      BNE   LAB_14E2          ; branch if start set
1378		.83c9		a9 ff						lda #$ff				      LDA   #$FF              ; set for -1
1379		.83cb		85 11						sta $11					      STA   Itempl            ; set temporary integer low byte
1380		.83cd		85 12						sta $12					      STA   Itemph            ; set temporary integer high byte
1381		.83cf																		LAB_14E2
1382		.83cf		a0 01						ldy #$01				      LDY   #$01              ; set index for line
1383		.83d1		84 60						sty $60					      STY   Oquote            ; clear open quote flag
1384		.83d3		20 93 88				jsr $8893				      JSR   LAB_CRLF          ; print CR/LF
1385		.83d6		b1 aa						lda ($aa),y			      LDA   (Baslnl),Y        ; get next line pointer high byte
1387		.83d8		f0 3e						beq $8418				      BEQ   LAB_152B          ; if null all done so exit
1388		.83da		20 16 85				jsr $8516				      JSR   LAB_1629          ; do CRTL-C check vector
1390		.83dd		c8							iny							      INY                     ; increment index for line
1391		.83de		b1 aa						lda ($aa),y			      LDA   (Baslnl),Y        ; get line # low byte
1392		.83e0		aa							tax							      TAX                     ; copy to X
1393		.83e1		c8							iny							      INY                     ; increment index
1394		.83e2		b1 aa						lda ($aa),y			      LDA   (Baslnl),Y        ; get line # high byte
1395		.83e4		c5 12						cmp $12					      CMP   Itemph            ; compare with temporary integer high byte
1396		.83e6		d0 04						bne $83ec				      BNE   LAB_14FF          ; branch if no high byte match
1398		.83e8		e4 11						cpx $11					      CPX   Itempl            ; compare with temporary integer low byte
1399		.83ea		f0 02						beq $83ee				      BEQ   LAB_1501          ; branch if = last line to do (< will pass next branch)
1401		.83ec																		LAB_14FF
1402		.83ec		b0 2a						bcs $8418				      BCS   LAB_152B          ; if greater all done so exit
1404		.83ee																		LAB_1501
1405		.83ee		84 97						sty $97					      STY   Tidx1             ; save index for line
1406		.83f0		20 8f 9a				jsr $9a8f				      JSR   LAB_295E          ; print XA as unsigned integer
1407		.83f3		a9 20						lda #$20				      LDA   #$20              ; space is the next character
1408		.83f5																		LAB_1508
1409		.83f5		a4 97						ldy $97					      LDY   Tidx1             ; get index for line
1410		.83f7		29 7f						and #$7f				      AND   #$7F              ; mask top out bit of character
1411		.83f9																		LAB_150C
1412		.83f9		20 ee 88				jsr $88ee				      JSR   LAB_PRNA          ; go print the character
1413		.83fc		c9 22						cmp #$22				      CMP   #$22              ; was it " character
1414		.83fe		d0 06						bne $8406				      BNE   LAB_1519          ; branch if not
1417		.8400		a5 60						lda $60					      LDA   Oquote            ; get open quote flag
1418		.8402		49 ff						eor #$ff				      EOR   #$FF              ; toggle it
1419		.8404		85 60						sta $60					      STA   Oquote            ; save it back
1420		.8406																		LAB_1519
1421		.8406		c8							iny							      INY                     ; increment index
1422		.8407		b1 aa						lda ($aa),y			      LDA   (Baslnl),Y        ; get next byte
1423		.8409		d0 0e						bne $8419				      BNE   LAB_152E          ; branch if not [EOL] (go print character)
1424		.840b		a8							tay							      TAY                     ; else clear index
1425		.840c		b1 aa						lda ($aa),y			      LDA   (Baslnl),Y        ; get next line pointer low byte
1426		.840e		aa							tax							      TAX                     ; copy to X
1427		.840f		c8							iny							      INY                     ; increment index
1428		.8410		b1 aa						lda ($aa),y			      LDA   (Baslnl),Y        ; get next line pointer high byte
1429		.8412		86 aa						stx $aa					      STX   Baslnl            ; set pointer to line low byte
1430		.8414		85 ab						sta $ab					      STA   Baslnh            ; set pointer to line high byte
1431		.8416		d0 b7						bne $83cf				      BNE   LAB_14E2          ; go do next line if not [EOT]
1433		.8418																		LAB_152B
1434		.8418		60							rts							      RTS
1436		.8419																		LAB_152E
1437		.8419		10 de						bpl $83f9				      BPL   LAB_150C          ; just go print it if not token byte
1440		.841b		24 60						bit $60					      BIT   Oquote            ; test the open quote flag
1441		.841d		30 da						bmi $83f9				      BMI   LAB_150C          ; just go print character if open quote set
1443		.841f		a2 a5						ldx #$a5				      LDX   #>LAB_KEYT        ; get table address high byte
1444		.8421		0a							asl a						      ASL                     ; *2
1445		.8422		0a							asl a						      ASL                     ; *4
1446		.8423		90 02						bcc $8427				      BCC   LAB_152F          ; branch if no carry
1448		.8425		e8							inx							      INX                     ; else increment high byte
1449		.8426		18							clc							      CLC                     ; clear carry for add
1450		.8427																		LAB_152F
1451		.8427		69 22						adc #$22				      ADC   #<LAB_KEYT        ; add low byte
1452		.8429		90 01						bcc $842c				      BCC   LAB_1530          ; branch if no carry
1454		.842b		e8							inx							      INX                     ; else increment high byte
1455		.842c																		LAB_1530
1456		.842c		85 73						sta $73					      STA   ut2_pl            ; save table pointer low byte
1457		.842e		86 74						stx $74					      STX   ut2_ph            ; save table pointer high byte
1458		.8430		84 97						sty $97					      STY   Tidx1             ; save index for line
1459		.8432		a0 00						ldy #$00				      LDY   #$00              ; clear index
1460		.8434		b1 73						lda ($73),y			      LDA   (ut2_pl),Y        ; get length
1461		.8436		aa							tax							      TAX                     ; copy length
1462		.8437		c8							iny							      INY                     ; increment index
1463		.8438		b1 73						lda ($73),y			      LDA   (ut2_pl),Y        ; get 1st character
1464		.843a		ca							dex							      DEX                     ; decrement length
1465		.843b		f0 b8						beq $83f5				      BEQ   LAB_1508          ; if no more characters exit and print
1467		.843d		20 ee 88				jsr $88ee				      JSR   LAB_PRNA          ; go print the character
1468		.8440		c8							iny							      INY                     ; increment index
1469		.8441		b1 73						lda ($73),y			      LDA   (ut2_pl),Y        ; get keyword address low byte
1470		.8443		48							pha							      PHA                     ; save it for now
1471		.8444		c8							iny							      INY                     ; increment index
1472		.8445		b1 73						lda ($73),y			      LDA   (ut2_pl),Y        ; get keyword address high byte
1473		.8447		a0 00						ldy #$00				      LDY   #$00
1474		.8449		85 74						sta $74					      STA   ut2_ph            ; save keyword pointer high byte
1475		.844b		68							pla							      PLA                     ; pull low byte
1476		.844c		85 73						sta $73					      STA   ut2_pl            ; save keyword pointer low byte
1477		.844e																		LAB_1540
1478		.844e		b1 73						lda ($73),y			      LDA   (ut2_pl),Y        ; get character
1479		.8450		ca							dex							      DEX                     ; decrement character count
1480		.8451		f0 a2						beq $83f5				      BEQ   LAB_1508          ; if last character exit and print
1482		.8453		20 ee 88				jsr $88ee				      JSR   LAB_PRNA          ; go print the character
1483		.8456		c8							iny							      INY                     ; increment index
1484		.8457		d0 f5						bne $844e				      BNE   LAB_1540          ; loop for next character
1488		.8459																		LAB_FOR
1489		.8459		a9 80						lda #$80				      LDA   #$80              ; set FNX
1490		.845b		85 61						sta $61					      STA   Sufnxf            ; set subscript/FNX flag
1491		.845d		20 b5 87				jsr $87b5				      JSR   LAB_LET           ; go do LET
1492		.8460		68							pla							      PLA                     ; pull return address
1493		.8461		68							pla							      PLA                     ; pull return address
1494		.8462		a9 10						lda #$10				      LDA   #$10              ; we need 16d bytes !
1495		.8464		20 03 81				jsr $8103				      JSR   LAB_1212          ; check room on stack for A bytes
1496		.8467		20 9b 86				jsr $869b				      JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
1497		.846a		18							clc							      CLC                     ; clear carry for add
1498		.846b		98							tya							      TYA                     ; copy index to A
1499		.846c		65 c3						adc $c3					      ADC   Bpntrl            ; add BASIC execute pointer low byte
1500		.846e		48							pha							      PHA                     ; push onto stack
1501		.846f		a5 c4						lda $c4					      LDA   Bpntrh            ; get BASIC execute pointer high byte
1502		.8471		69 00						adc #$00				      ADC   #$00              ; add carry
1503		.8473		48							pha							      PHA                     ; push onto stack
1504		.8474		a5 88						lda $88					      LDA   Clineh            ; get current line high byte
1505		.8476		48							pha							      PHA                     ; push onto stack
1506		.8477		a5 87						lda $87					      LDA   Clinel            ; get current line low byte
1507		.8479		48							pha							      PHA                     ; push onto stack
1508		.847a		a9 ad						lda #$ad				      LDA   #TK_TO            ; get "TO" token
1509		.847c		20 f1 8b				jsr $8bf1				      JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
1510		.847f		20 d0 8a				jsr $8ad0				      JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
1511		.8482		20 cd 8a				jsr $8acd				      JSR   LAB_EVNM          ; evaluate expression and check is numeric,
1515		.8485		20 e6 98				jsr $98e6				      JSR   LAB_27BA          ; round FAC1
1517		.8488		a5 b0						lda $b0					      LDA   FAC1_s            ; get FAC1 sign (b7)
1518		.848a		09 7f						ora #$7f				      ORA   #$7F              ; set all non sign bits
1519		.848c		25 ad						and $ad					      AND   FAC1_1            ; and FAC1 mantissa1
1520		.848e		85 ad						sta $ad					      STA   FAC1_1            ; save FAC1 mantissa1
1521		.8490		a9 9b						lda #$9b				      LDA   #<LAB_159F        ; set return address low byte
1522		.8492		a0 84						ldy #$84				      LDY   #>LAB_159F        ; set return address high byte
1523		.8494		85 71						sta $71					      STA   ut1_pl            ; save return address low byte
1524		.8496		84 72						sty $72					      STY   ut1_ph            ; save return address high byte
1525		.8498		4c 87 8b				jmp $8b87				      JMP   LAB_1B66          ; round FAC1 and put on stack (returns to next instruction)
1527		.849b																		LAB_159F
1528		.849b		a9 f1						lda #$f1				      LDA   #<LAB_259C        ; set 1 pointer low addr (default step size)
1529		.849d		a0 a1						ldy #$a1				      LDY   #>LAB_259C        ; set 1 pointer high addr
1530		.849f		20 8a 98				jsr $988a				      JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
1531		.84a2		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; scan memory
1532		.84a5		c9 b2						cmp #$b2				      CMP   #TK_STEP          ; compare with STEP token
1533		.84a7		d0 06						bne $84af				      BNE   LAB_15B3          ; jump if not "STEP"
1536		.84a9		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment and scan memory
1537		.84ac		20 cd 8a				jsr $8acd				      JSR   LAB_EVNM          ; evaluate expression and check is numeric,
1539		.84af																		LAB_15B3
1540		.84af		20 f6 98				jsr $98f6				      JSR   LAB_27CA          ; return A=FF,C=1/-ve A=01,C=0/+ve
1541		.84b2		85 b0						sta $b0					      STA   FAC1_s            ; set FAC1 sign (b7)
1555		.84b4		20 79 8b				jsr $8b79				      JSR   LAB_1B5B          ; push sign, round FAC1 and put on stack
1556		.84b7		a5 98						lda $98					      LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
1557		.84b9		48							pha							      PHA                     ; push on stack
1558		.84ba		a5 97						lda $97					      LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
1559		.84bc		48							pha							      PHA                     ; push on stack
1560		.84bd		a9 81						lda #$81				      LDA   #TK_FOR           ; get FOR token
1561		.84bf		48							pha							      PHA                     ; push on stack
1565		.84c0																		LAB_15C2
1566		.84c0		20 16 85				jsr $8516				      JSR   LAB_1629          ; do CRTL-C check vector
1567		.84c3		a5 c3						lda $c3					      LDA   Bpntrl            ; get BASIC execute pointer low byte
1568		.84c5		a4 c4						ldy $c4					      LDY   Bpntrh            ; get BASIC execute pointer high byte
1570		.84c7		a6 88						ldx $88					      LDX   Clineh            ; continue line is $FFxx for immediate mode
1572		.84c9		e8							inx							      INX                     ; increment it (now $00 if immediate mode)
1576		.84ca		85 8b						sta $8b					      STA   Cpntrl            ; save continue pointer low byte
1577		.84cc		84 8c						sty $8c					      STY   Cpntrh            ; save continue pointer high byte
1578		.84ce																		LAB_15D1
1579		.84ce		a0 00						ldy #$00				      LDY   #$00              ; clear index
1580		.84d0		b1 c3						lda ($c3),y			      LDA   (Bpntrl),Y        ; get next byte
1581		.84d2		f0 07						beq $84db				      BEQ   LAB_15DC          ; branch if null [EOL]
1583		.84d4		c9 3a						cmp #$3a				      CMP   #':'              ; compare with ":"
1584		.84d6		f0 1d						beq $84f5				      BEQ   LAB_15F6          ; branch if = (statement separator)
1586		.84d8																		LAB_15D9
1587		.84d8		4c 02 8c				jmp $8c02				      JMP   LAB_SNER          ; else syntax error then warm start
1590		.84db																		LAB_15DC
1591		.84db		a0 02						ldy #$02				      LDY   #$02              ; set index
1592		.84dd		b1 c3						lda ($c3),y			      LDA   (Bpntrl),Y        ; get next line pointer high byte
1593		.84df		18							clc							      CLC                     ; clear carry for no "BREAK" message
1594		.84e0		f0 50						beq $8532				      BEQ   LAB_1651          ; if null go to immediate mode (was immediate or [EOT]
1597		.84e2		c8							iny							      INY                     ; increment index
1598		.84e3		b1 c3						lda ($c3),y			      LDA   (Bpntrl),Y        ; get line # low byte
1599		.84e5		85 87						sta $87					      STA   Clinel            ; save current line low byte
1600		.84e7		c8							iny							      INY                     ; increment index
1601		.84e8		b1 c3						lda ($c3),y			      LDA   (Bpntrl),Y        ; get line # high byte
1602		.84ea		85 88						sta $88					      STA   Clineh            ; save current line high byte
1603		.84ec		98							tya							      TYA                     ; A now = 4
1604		.84ed		65 c3						adc $c3					      ADC   Bpntrl            ; add BASIC execute pointer low byte
1605		.84ef		85 c3						sta $c3					      STA   Bpntrl            ; save BASIC execute pointer low byte
1606		.84f1		90 02						bcc $84f5				      BCC   LAB_15F6          ; branch if no overflow
1608		.84f3		e6 c4						inc $c4					      INC   Bpntrh            ; else increment BASIC execute pointer high byte
1609		.84f5																		LAB_15F6
1610		.84f5		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment and scan memory
1612		.84f8																		LAB_15F9
1613		.84f8		20 fe 84				jsr $84fe				      JSR   LAB_15FF          ; go interpret BASIC code from (Bpntrl)
1615		.84fb																		LAB_15FC
1616		.84fb		4c c0 84				jmp $84c0				      JMP   LAB_15C2          ; loop
1620		.84fe																		LAB_15FF
1621		.84fe		f0 4e						beq $854e				      BEQ   LAB_1628          ; exit if zero [EOL]
1623		.8500																		LAB_1602
1624		.8500		0a							asl a						      ASL                     ; *2 bytes per vector and normalise token
1625		.8501		b0 03						bcs $8506				      BCS   LAB_1609          ; branch if was token
1627		.8503		4c b5 87				jmp $87b5				      JMP   LAB_LET           ; else go do implied LET
1629		.8506																		LAB_1609
1630		.8506		c9 56						cmp #$56				      CMP   #(TK_TAB-$80)*2   ; compare normalised token * 2 with TAB
1631		.8508		b0 ce						bcs $84d8				      BCS   LAB_15D9          ; branch if A>=TAB (do syntax error then warm start)
1633		.850a		a8							tay							      TAY                     ; copy to index
1634		.850b		b9 19 a2				lda $a219,y			      LDA   LAB_CTBL+1,Y      ; get vector high byte
1635		.850e		48							pha							      PHA                     ; onto stack
1636		.850f		b9 18 a2				lda $a218,y			      LDA   LAB_CTBL,Y        ; get vector low byte
1637		.8512		48							pha							      PHA                     ; onto stack
1638		.8513		4c bc 00				jmp $00bc				      JMP   LAB_IGBY          ; jump to increment and scan memory
1644		.8516																		LAB_1629
1645		.8516		6c 03 02				jmp ($0203)			      JMP   (VEC_CC)          ; ctrl c check vector
1649		.8519																		LAB_1636
1650		.8519		c9 03						cmp #$03				      CMP   #$03              ; compare with CTRL-C
1654		.851b																		LAB_STOP
1655		.851b		b0 01						bcs $851e				      BCS   LAB_163B          ; branch if token follows STOP
1659		.851d																		LAB_END
1660		.851d		18							clc							      CLC                     ; clear the carry, indicate a normal program end
1661		.851e																		LAB_163B
1662		.851e		d0 61						bne $8581				      BNE   LAB_167A          ; if wasn't CTRL-C or there is a following byte return
1664		.8520		a5 c4						lda $c4					      LDA   Bpntrh            ; get the BASIC execute pointer high byte
1671		.8522		a4 c3						ldy $c3					      LDY   Bpntrl            ; get BASIC execute pointer low byte
1672		.8524		84 8b						sty $8b					      STY   Cpntrl            ; save continue pointer low byte
1673		.8526		85 8c						sta $8c					      STA   Cpntrh            ; save continue pointer high byte
1674		.8528																		LAB_1647
1675		.8528		a5 87						lda $87					      LDA   Clinel            ; get current line low byte
1676		.852a		a4 88						ldy $88					      LDY   Clineh            ; get current line high byte
1677		.852c		85 89						sta $89					      STA   Blinel            ; save break line low byte
1678		.852e		84 8a						sty $8a					      STY   Blineh            ; save break line high byte
1679		.8530																		LAB_164F
1680		.8530		68							pla							      PLA                     ; pull return address low
1681		.8531		68							pla							      PLA                     ; pull return address high
1682		.8532																		LAB_1651
1683		.8532		90 07						bcc $853b				      BCC   LAB_165E          ; if was program end just do warm start
1686		.8534		a9 ef						lda #$ef				      LDA   #<LAB_BMSG        ; point to "Break" low byte
1687		.8536		a0 a7						ldy #$a7				      LDY   #>LAB_BMSG        ; point to "Break" high byte
1688		.8538		4c 52 81				jmp $8152				      JMP   LAB_1269          ; print "Break" and do warm start
1690		.853b																		LAB_165E
1691		.853b		4c 5d 81				jmp $815d				      JMP   LAB_1274          ; go do warm start
1695		.853e																		LAB_RESTORE
1696		.853e		d0 0f						bne $854f				      BNE   LAB_RESTOREn      ; branch if next character not null (RESTORE n)
1698		.8540																		LAB_161A
1699		.8540		38							sec							      SEC                     ; set carry for subtract
1700		.8541		a5 79						lda $79					      LDA   Smeml             ; get start of mem low byte
1701		.8543		e9 01						sbc #$01				      SBC   #$01              ; -1
1702		.8545		a4 7a						ldy $7a					      LDY   Smemh             ; get start of mem high byte
1703		.8547		b0 01						bcs $854a				      BCS   LAB_1624          ; branch if no underflow
1705		.8549																		LAB_uflow
1706		.8549		88							dey							      DEY                     ; else decrement high byte
1707		.854a																		LAB_1624
1708		.854a		85 8f						sta $8f					      STA   Dptrl             ; save DATA pointer low byte
1709		.854c		84 90						sty $90					      STY   Dptrh             ; save DATA pointer high byte
1710		.854e																		LAB_1628
1711		.854e		60							rts							      RTS
1714		.854f																		LAB_RESTOREn
1715		.854f		20 56 87				jsr $8756				      JSR   LAB_GFPN          ; get fixed-point number into temp integer
1716		.8552		20 9e 86				jsr $869e				      JSR   LAB_SNBL          ; scan for next BASIC line
1717		.8555		a5 88						lda $88					      LDA   Clineh            ; get current line high byte
1718		.8557		c5 12						cmp $12					      CMP   Itemph            ; compare with temporary integer high byte
1719		.8559		b0 0b						bcs $8566				      BCS   LAB_reset_search  ; branch if >= (start search from beginning)
1721		.855b		98							tya							      TYA                     ; else copy line index to A
1722		.855c		38							sec							      SEC                     ; set carry (+1)
1723		.855d		65 c3						adc $c3					      ADC   Bpntrl            ; add BASIC execute pointer low byte
1724		.855f		a6 c4						ldx $c4					      LDX   Bpntrh            ; get BASIC execute pointer high byte
1725		.8561		90 07						bcc $856a				      BCC   LAB_go_search     ; branch if no overflow to high byte
1727		.8563		e8							inx							      INX                     ; increment high byte
1728		.8564		b0 04						bcs $856a				      BCS   LAB_go_search     ; branch always (can never be carry clear)
1732		.8566																		LAB_reset_search
1733		.8566		a5 79						lda $79					      LDA   Smeml             ; get start of mem low byte
1734		.8568		a6 7a						ldx $7a					      LDX   Smemh             ; get start of mem high byte
1738		.856a																		LAB_go_search
1740		.856a		20 2b 83				jsr $832b				      JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
1741		.856d		b0 03						bcs $8572				      BCS   LAB_line_found    ; if carry set go set pointer
1743		.856f		4c 70 86				jmp $8670				      JMP   LAB_16F7          ; else go do "Undefined statement" error
1745		.8572																		LAB_line_found
1747		.8572		a5 aa						lda $aa					      LDA   Baslnl            ; get pointer low byte
1748		.8574		e9 01						sbc #$01				      SBC   #$01              ; -1
1749		.8576		a4 ab						ldy $ab					      LDY   Baslnh            ; get pointer high byte
1750		.8578		b0 d0						bcs $854a				      BCS   LAB_1624          ; branch if no underflow (save DATA pointer and return)
1752		.857a		90 cd						bcc $8549				      BCC   LAB_uflow         ; else decrement high byte then save DATA pointer and
1757		.857c																		LAB_NULL
1758		.857c		20 a0 94				jsr $94a0				      JSR   LAB_GTBY          ; get byte parameter
1759		.857f		86 0d						stx $0d					      STX   Nullct            ; save new NULL count
1760		.8581																		LAB_167A
1761		.8581		60							rts							      RTS
1765		.8582																		LAB_CONT
1766		.8582		d0 fd						bne $8581				      BNE   LAB_167A          ; if following byte exit to do syntax error
1768		.8584		a4 8c						ldy $8c					      LDY   Cpntrh            ; get continue pointer high byte
1769		.8586		c0 02						cpy #$02				      CPY   #>Ibuffs          ; *** fix p2: test direct mode
1770		.8588		d0 05						bne $858f				      BNE   LAB_166C          ; go do continue if we can
1772		.858a		a2 1e						ldx #$1e				      LDX   #$1E              ; error code $1E ("Can't continue" error)
1773		.858c		4c 3f 81				jmp $813f				      JMP   LAB_XERR          ; do error #X, then warm start
1776		.858f																		LAB_166C
1777		.858f		a9 93						lda #$93				      LDA   #TK_ON            ; set token for ON
1778		.8591		20 23 9f				jsr $9f23				      JSR   LAB_IRQ           ; set IRQ flags
1779		.8594		a9 93						lda #$93				      LDA   #TK_ON            ; set token for ON
1780		.8596		20 26 9f				jsr $9f26				      JSR   LAB_NMI           ; set NMI flags
1782		.8599		84 c4						sty $c4					      STY   Bpntrh            ; save BASIC execute pointer high byte
1783		.859b		a5 8b						lda $8b					      LDA   Cpntrl            ; get continue pointer low byte
1784		.859d		85 c3						sta $c3					      STA   Bpntrl            ; save BASIC execute pointer low byte
1785		.859f		a5 89						lda $89					      LDA   Blinel            ; get break line low byte
1786		.85a1		a4 8a						ldy $8a					      LDY   Blineh            ; get break line high byte
1787		.85a3		85 87						sta $87					      STA   Clinel            ; set current line low byte
1788		.85a5		84 88						sty $88					      STY   Clineh            ; set current line high byte
1789		.85a7		60							rts							      RTS
1793		.85a8																		LAB_RUN
1794		.85a8		d0 03						bne $85ad				      BNE   LAB_1696          ; branch if RUN n
1795		.85aa		4c 68 83				jmp $8368				      JMP   LAB_1477          ; reset execution to start, clear variables, flush stack and
1800		.85ad																		LAB_1696
1801		.85ad		20 75 83				jsr $8375				      JSR   LAB_147A          ; go do "CLEAR"
1802		.85b0		f0 2e						beq $85e0				      BEQ   LAB_16B0          ; get n and do GOTO n (branch always as CLEAR sets Z=1)
1806		.85b2																		LAB_DO
1807		.85b2		a9 05						lda #$05				      LDA   #$05              ; need 5 bytes for DO
1808		.85b4		20 03 81				jsr $8103				      JSR   LAB_1212          ; check room on stack for A bytes
1809		.85b7		a5 c4						lda $c4					      LDA   Bpntrh            ; get BASIC execute pointer high byte
1810		.85b9		48							pha							      PHA                     ; push on stack
1811		.85ba		a5 c3						lda $c3					      LDA   Bpntrl            ; get BASIC execute pointer low byte
1812		.85bc		48							pha							      PHA                     ; push on stack
1813		.85bd		a5 88						lda $88					      LDA   Clineh            ; get current line high byte
1814		.85bf		48							pha							      PHA                     ; push on stack
1815		.85c0		a5 87						lda $87					      LDA   Clinel            ; get current line low byte
1816		.85c2		48							pha							      PHA                     ; push on stack
1817		.85c3		a9 9d						lda #$9d				      LDA   #TK_DO            ; token for DO
1818		.85c5		48							pha							      PHA                     ; push on stack
1819		.85c6		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; scan memory
1820		.85c9		4c c0 84				jmp $84c0				      JMP   LAB_15C2          ; go do interpreter inner loop
1824		.85cc																		LAB_GOSUB
1825		.85cc		a9 05						lda #$05				      LDA   #$05              ; need 5 bytes for GOSUB
1826		.85ce		20 03 81				jsr $8103				      JSR   LAB_1212          ; check room on stack for A bytes
1827		.85d1		a5 c4						lda $c4					      LDA   Bpntrh            ; get BASIC execute pointer high byte
1828		.85d3		48							pha							      PHA                     ; push on stack
1829		.85d4		a5 c3						lda $c3					      LDA   Bpntrl            ; get BASIC execute pointer low byte
1830		.85d6		48							pha							      PHA                     ; push on stack
1831		.85d7		a5 88						lda $88					      LDA   Clineh            ; get current line high byte
1832		.85d9		48							pha							      PHA                     ; push on stack
1833		.85da		a5 87						lda $87					      LDA   Clinel            ; get current line low byte
1834		.85dc		48							pha							      PHA                     ; push on stack
1835		.85dd		a9 8d						lda #$8d				      LDA   #TK_GOSUB         ; token for GOSUB
1836		.85df		48							pha							      PHA                     ; push on stack
1837		.85e0																		LAB_16B0
1838		.85e0		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; scan memory
1839		.85e3		20 e9 85				jsr $85e9				      JSR   LAB_GOTO          ; perform GOTO n
1840		.85e6		4c c0 84				jmp $84c0				      JMP   LAB_15C2          ; go do interpreter inner loop
1845		.85e9																		LAB_GOTO
1846		.85e9		20 56 87				jsr $8756				      JSR   LAB_GFPN          ; get fixed-point number into temp integer
1847		.85ec		20 9e 86				jsr $869e				      JSR   LAB_SNBL          ; scan for next BASIC line
1848		.85ef		a5 88						lda $88					      LDA   Clineh            ; get current line high byte
1849		.85f1		c5 12						cmp $12					      CMP   Itemph            ; compare with temporary integer high byte
1850		.85f3		b0 0b						bcs $8600				      BCS   LAB_16D0          ; branch if >= (start search from beginning)
1852		.85f5		98							tya							      TYA                     ; else copy line index to A
1853		.85f6		38							sec							      SEC                     ; set carry (+1)
1854		.85f7		65 c3						adc $c3					      ADC   Bpntrl            ; add BASIC execute pointer low byte
1855		.85f9		a6 c4						ldx $c4					      LDX   Bpntrh            ; get BASIC execute pointer high byte
1856		.85fb		90 07						bcc $8604				      BCC   LAB_16D4          ; branch if no overflow to high byte
1858		.85fd		e8							inx							      INX                     ; increment high byte
1859		.85fe		b0 04						bcs $8604				      BCS   LAB_16D4          ; branch always (can never be carry)
1863		.8600																		LAB_16D0
1864		.8600		a5 79						lda $79					      LDA   Smeml             ; get start of mem low byte
1865		.8602		a6 7a						ldx $7a					      LDX   Smemh             ; get start of mem high byte
1869		.8604																		LAB_16D4
1870		.8604		20 2b 83				jsr $832b				      JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
1871		.8607		90 67						bcc $8670				      BCC   LAB_16F7          ; if carry clear go do "Undefined statement" error
1875		.8609		a5 aa						lda $aa					      LDA   Baslnl            ; get pointer low byte
1876		.860b		e9 01						sbc #$01				      SBC   #$01              ; -1
1877		.860d		85 c3						sta $c3					      STA   Bpntrl            ; save BASIC execute pointer low byte
1878		.860f		a5 ab						lda $ab					      LDA   Baslnh            ; get pointer high byte
1879		.8611		e9 00						sbc #$00				      SBC   #$00              ; subtract carry
1880		.8613		85 c4						sta $c4					      STA   Bpntrh            ; save BASIC execute pointer high byte
1881		.8615																		LAB_16E5
1882		.8615		60							rts							      RTS
1884		.8616																		LAB_DONOK
1885		.8616		a2 22						ldx #$22				      LDX   #$22              ; error code $22 ("LOOP without DO" error)
1886		.8618		4c 3f 81				jmp $813f				      JMP   LAB_XERR          ; do error #X, then warm start
1890		.861b																		LAB_LOOP
1891		.861b		a8							tay							      TAY                     ; save following token
1892		.861c		ba							tsx							      TSX                     ; copy stack pointer
1893		.861d		bd 03 01				lda $0103,x			      LDA   LAB_STAK+3,X      ; get token byte from stack
1894		.8620		c9 9d						cmp #$9d				      CMP   #TK_DO            ; compare with DO token
1895		.8622		d0 f2						bne $8616				      BNE   LAB_DONOK         ; branch if no matching DO
1897		.8624		e8							inx							      INX                     ; dump calling routine return address
1898		.8625		e8							inx							      INX                     ; dump calling routine return address
1899		.8626		9a							txs							      TXS                     ; correct stack
1900		.8627		98							tya							      TYA                     ; get saved following token back
1901		.8628		f0 20						beq $864a				      BEQ   LoopAlways        ; if no following token loop forever
1904		.862a		c9 3a						cmp #$3a				      CMP   #':'              ; could be ':'
1905		.862c		f0 1c						beq $864a				      BEQ   LoopAlways        ; if :... loop forever
1907		.862e		e9 b3						sbc #$b3				      SBC   #TK_UNTIL         ; subtract token for UNTIL, we know carry is set here
1908		.8630		aa							tax							      TAX                     ; copy to X (if it was UNTIL then Y will be correct)
1909		.8631		f0 04						beq $8637				      BEQ   DoRest            ; branch if was UNTIL
1911		.8633		ca							dex							      DEX                     ; decrement result
1912		.8634		d0 62						bne $8698				      BNE   LAB_16FC          ; if not WHILE go do syntax error and warm start
1915		.8636		ca							dex							      DEX                     ; set invert result byte
1916		.8637																		DoRest
1917		.8637		86 98						stx $98					      STX   Frnxth            ; save invert result byte
1918		.8639		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment and scan memory
1919		.863c		20 e1 8a				jsr $8ae1				      JSR   LAB_EVEX          ; evaluate expression
1920		.863f		a5 ac						lda $ac					      LDA   FAC1_e            ; get FAC1 exponent
1921		.8641		f0 02						beq $8645				      BEQ   DoCmp             ; if =0 go do straight compare
1923		.8643		a9 ff						lda #$ff				      LDA   #$FF              ; else set all bits
1924		.8645																		DoCmp
1925		.8645		ba							tsx							      TSX                     ; copy stack pointer
1926		.8646		45 98						eor $98					      EOR   Frnxth            ; EOR with invert byte
1927		.8648		d0 1a						bne $8664				      BNE   LoopDone          ; if <> 0 clear stack and back to interpreter loop
1930		.864a																		LoopAlways
1931		.864a		bd 02 01				lda $0102,x			      LDA   LAB_STAK+2,X      ; get current line low byte
1932		.864d		85 87						sta $87					      STA   Clinel            ; save current line low byte
1933		.864f		bd 03 01				lda $0103,x			      LDA   LAB_STAK+3,X      ; get current line high byte
1934		.8652		85 88						sta $88					      STA   Clineh            ; save current line high byte
1935		.8654		bd 04 01				lda $0104,x			      LDA   LAB_STAK+4,X      ; get BASIC execute pointer low byte
1936		.8657		85 c3						sta $c3					      STA   Bpntrl            ; save BASIC execute pointer low byte
1937		.8659		bd 05 01				lda $0105,x			      LDA   LAB_STAK+5,X      ; get BASIC execute pointer high byte
1938		.865c		85 c4						sta $c4					      STA   Bpntrh            ; save BASIC execute pointer high byte
1939		.865e		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; scan memory
1940		.8661		4c c0 84				jmp $84c0				      JMP   LAB_15C2          ; go do interpreter inner loop
1943		.8664																		LoopDone
1944		.8664		e8							inx							      INX                     ; dump DO token
1945		.8665		e8							inx							      INX                     ; dump current line low byte
1946		.8666		e8							inx							      INX                     ; dump current line high byte
1947		.8667		e8							inx							      INX                     ; dump BASIC execute pointer low byte
1948		.8668		e8							inx							      INX                     ; dump BASIC execute pointer high byte
1949		.8669		9a							txs							      TXS                     ; correct stack
1950		.866a		4c 8a 86				jmp $868a				      JMP   LAB_DATA          ; go perform DATA (find : or [EOL])
1954		.866d																		LAB_16F4
1955		.866d		a2 04						ldx #$04				      LDX   #$04              ; error code $04 ("RETURN without GOSUB" error)
1956		>866f		2c															      .byte $2C               ; makes next line BIT LAB_0EA2
1958		.8670																		LAB_16F7
1959		.8670		a2 0e						ldx #$0e				      LDX   #$0E              ; error code $0E ("Undefined statement" error)
1960		.8672		4c 3f 81				jmp $813f				      JMP   LAB_XERR          ; do error #X, then warm start
1964		.8675																		LAB_RETURN
1965		.8675		d0 9e						bne $8615				      BNE   LAB_16E5          ; exit if following token (to allow syntax error)
1967		.8677																		LAB_16E8
1968		.8677		68							pla							      PLA                     ; dump calling routine return address
1969		.8678		68							pla							      PLA                     ; dump calling routine return address
1970		.8679		68							pla							      PLA                     ; pull token
1971		.867a		c9 8d						cmp #$8d				      CMP   #TK_GOSUB         ; compare with GOSUB token
1972		.867c		d0 ef						bne $866d				      BNE   LAB_16F4          ; branch if no matching GOSUB
1974		.867e																		LAB_16FF
1975		.867e		68							pla							      PLA                     ; pull current line low byte
1976		.867f		85 87						sta $87					      STA   Clinel            ; save current line low byte
1977		.8681		68							pla							      PLA                     ; pull current line high byte
1978		.8682		85 88						sta $88					      STA   Clineh            ; save current line high byte
1979		.8684		68							pla							      PLA                     ; pull BASIC execute pointer low byte
1980		.8685		85 c3						sta $c3					      STA   Bpntrl            ; save BASIC execute pointer low byte
1981		.8687		68							pla							      PLA                     ; pull BASIC execute pointer high byte
1982		.8688		85 c4						sta $c4					      STA   Bpntrh            ; save BASIC execute pointer high byte
1991		.868a																		LAB_DATA
1992		.868a		20 9b 86				jsr $869b				      JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
1995		.868d																		LAB_170F
1996		.868d		98							tya							      TYA                     ; copy index to A
1997		.868e		18							clc							      CLC                     ; clear carry for add
1998		.868f		65 c3						adc $c3					      ADC   Bpntrl            ; add BASIC execute pointer low byte
1999		.8691		85 c3						sta $c3					      STA   Bpntrl            ; save BASIC execute pointer low byte
2000		.8693		90 02						bcc $8697				      BCC   LAB_1719          ; skip next if no carry
2002		.8695		e6 c4						inc $c4					      INC   Bpntrh            ; else increment BASIC execute pointer high byte
2003		.8697																		LAB_1719
2004		.8697		60							rts							      RTS
2006		.8698																		LAB_16FC
2007		.8698		4c 02 8c				jmp $8c02				      JMP   LAB_SNER          ; do syntax error then warm start
2012		.869b																		LAB_SNBS
2013		.869b		a2 3a						ldx #$3a				      LDX   #':'              ; set look for character = ":"
2014		>869d		2c															      .byte $2C               ; makes next line BIT $00A2
2019		.869e																		LAB_SNBL
2020		.869e		a2 00						ldx #$00				      LDX   #$00              ; set alt search character = [EOL]
2021		.86a0		a0 00						ldy #$00				      LDY   #$00              ; set search character = [EOL]
2022		.86a2		84 5c						sty $5c					      STY   Asrch             ; store search character
2023		.86a4																		LAB_1725
2024		.86a4		8a							txa							      TXA                     ; get alt search character
2025		.86a5		45 5c						eor $5c					      EOR   Asrch             ; toggle search character, effectively swap with $00
2026		.86a7		85 5c						sta $5c					      STA   Asrch             ; save swapped search character
2027		.86a9																		LAB_172D
2028		.86a9		b1 c3						lda ($c3),y			      LDA   (Bpntrl),Y        ; get next byte
2029		.86ab		f0 ea						beq $8697				      BEQ   LAB_1719          ; exit if null [EOL]
2031		.86ad		c5 5c						cmp $5c					      CMP   Asrch             ; compare with search character
2032		.86af		f0 e6						beq $8697				      BEQ   LAB_1719          ; exit if found
2034		.86b1		c8							iny							      INY                     ; increment index
2035		.86b2		c9 22						cmp #$22				      CMP   #$22              ; compare current character with open quote
2036		.86b4		d0 f3						bne $86a9				      BNE   LAB_172D          ; if not open quote go get next character
2038		.86b6		f0 ec						beq $86a4				      BEQ   LAB_1725          ; if found go swap search character for alt search character
2042		.86b8																		LAB_IF
2043		.86b8		20 e1 8a				jsr $8ae1				      JSR   LAB_EVEX          ; evaluate the expression
2044		.86bb		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; scan memory
2045		.86be		c9 b0						cmp #$b0				      CMP   #TK_THEN          ; compare with THEN token
2046		.86c0		f0 11						beq $86d3				      BEQ   LAB_174B          ; if it was THEN go do IF
2049		.86c2		c9 89						cmp #$89				      CMP   #TK_GOTO          ; compare with GOTO token
2050		.86c4		d0 d2						bne $8698				      BNE   LAB_16FC          ; if it wasn't GOTO go do syntax error
2052		.86c6		a6 c3						ldx $c3					      LDX   Bpntrl            ; save the basic pointer low byte
2053		.86c8		a4 c4						ldy $c4					      LDY   Bpntrh            ; save the basic pointer high byte
2054		.86ca		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment and scan memory
2055		.86cd		b0 c9						bcs $8698				      BCS   LAB_16FC          ; if not numeric go do syntax error
2057		.86cf		86 c3						stx $c3					      STX   Bpntrl            ; restore the basic pointer low byte
2058		.86d1		84 c4						sty $c4					      STY   Bpntrh            ; restore the basic pointer high byte
2059		.86d3																		LAB_174B
2060		.86d3		a5 ac						lda $ac					      LDA   FAC1_e            ; get FAC1 exponent
2061		.86d5		f0 1e						beq $86f5				      BEQ   LAB_174E          ; if the result was zero go look for an ELSE
2063		.86d7		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; else increment and scan memory
2064		.86da		b0 03						bcs $86df				      BCS   LAB_174D          ; if not numeric go do var or keyword
2066		.86dc																		LAB_174C
2067		.86dc		4c e9 85				jmp $85e9				      JMP   LAB_GOTO          ; else was numeric so do GOTO n
2070		.86df																		LAB_174D
2097		.86df		68							pla							      PLA                     ; discard interpreter loop return address
2098		.86e0		68							pla							      PLA                     ; so data structures are at the correct stack offset
2099		.86e1		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; restore token or variable
2100		.86e4		20 fe 84				jsr $84fe				      JSR   LAB_15FF          ; interpret BASIC code from (Bpntrl)
2105		.86e7		a0 00						ldy #$00				      LDY   #$00              ; clear the index
2106		.86e9		b1 c3						lda ($c3),y			      LDA   (Bpntrl),Y        ; get the next BASIC byte
2107		.86eb		c9 ac						cmp #$ac				      CMP   #TK_ELSE          ; compare it with the token for ELSE
2108		.86ed		d0 03						bne $86f2				      BNE   LAB_no_ELSE       ; no - continue on this line
2109		.86ef		20 8a 86				jsr $868a				      JSR   LAB_DATA          ; yes - skip the rest of the line
2114		.86f2																		LAB_no_ELSE
2115		.86f2		4c c0 84				jmp $84c0				      JMP LAB_15C2            ; return to the interpreter inner loop
2120		.86f5																		LAB_174E
2121		.86f5		a0 00						ldy #$00				      LDY   #$00              ; clear the BASIC byte index
2122		.86f7		a2 01						ldx #$01				      LDX   #$01              ; clear the nesting depth
2123		.86f9																		LAB_1750
2124		.86f9		c8							iny							      INY                     ; increment the BASIC byte index
2125		.86fa		b1 c3						lda ($c3),y			      LDA   (Bpntrl),Y        ; get the next BASIC byte
2126		.86fc		f0 0f						beq $870d				      BEQ   LAB_1753          ; if EOL go add the pointer and return
2128		.86fe		c9 8b						cmp #$8b				      CMP   #TK_IF            ; compare the byte with the token for IF
2129		.8700		d0 03						bne $8705				      BNE   LAB_1752          ; if not IF token skip the depth increment
2131		.8702		e8							inx							      INX                     ; else increment the nesting depth ..
2132		.8703		d0 f4						bne $86f9				      BNE   LAB_1750          ; .. and continue looking
2134		.8705																		LAB_1752
2135		.8705		c9 ac						cmp #$ac				      CMP   #TK_ELSE          ; compare the byte with the token for ELSE
2136		.8707		d0 f0						bne $86f9				      BNE   LAB_1750          ; if not ELSE token continue looking
2138		.8709		ca							dex							      DEX                     ; was ELSE so decrement the nesting depth
2139		.870a		d0 ed						bne $86f9				      BNE   LAB_1750          ; loop if still nested
2141		.870c		c8							iny							      INY                     ; increment the BASIC byte index past the ELSE
2145		.870d																		LAB_1753
2146		.870d		98							tya							      TYA                     ; else copy line index to A
2147		.870e		18							clc							      CLC                     ; clear carry for add
2148		.870f		65 c3						adc $c3					      ADC   Bpntrl            ; add the BASIC execute pointer low byte
2149		.8711		85 c3						sta $c3					      STA   Bpntrl            ; save the BASIC execute pointer low byte
2150		.8713		90 02						bcc $8717				      BCC   LAB_1754          ; branch if no overflow to high byte
2152		.8715		e6 c4						inc $c4					      INC   Bpntrh            ; else increment the BASIC execute pointer high byte
2153		.8717																		LAB_1754
2154		.8717		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; scan memory
2155		.871a		90 c0						bcc $86dc				      BCC   LAB_174C          ; if numeric do GOTO n
2159		.871c		4c fe 84				jmp $84fe				      JMP   LAB_15FF          ; interpret BASIC code from (Bpntrl)
2165		.871f																		LAB_REM
2166		.871f		20 9e 86				jsr $869e				      JSR   LAB_SNBL          ; scan for next BASIC line
2167		.8722		4c 8d 86				jmp $868d				      JMP   LAB_170F          ; go set BASIC execute pointer and return, branch always
2169		.8725																		LAB_16FD
2170		.8725		4c 02 8c				jmp $8c02				      JMP   LAB_SNER          ; do syntax error then warm start
2174		.8728																		LAB_ON
2175		.8728		c9 a9						cmp #$a9				      CMP   #TK_IRQ           ; was it IRQ token ?
2176		.872a		d0 03						bne $872f				      BNE   LAB_NOIN          ; if not go check NMI
2178		.872c		4c 47 9f				jmp $9f47				      JMP   LAB_SIRQ          ; else go set-up IRQ
2180		.872f																		LAB_NOIN
2181		.872f		c9 aa						cmp #$aa				      CMP   #TK_NMI           ; was it NMI token ?
2182		.8731		d0 03						bne $8736				      BNE   LAB_NONM          ; if not go do normal ON command
2184		.8733		4c 4b 9f				jmp $9f4b				      JMP   LAB_SNMI          ; else go set-up NMI
2186		.8736																		LAB_NONM
2187		.8736		20 a0 94				jsr $94a0				      JSR   LAB_GTBY          ; get byte parameter
2188		.8739		48							pha							      PHA                     ; push GOTO/GOSUB token
2189		.873a		c9 8d						cmp #$8d				      CMP   #TK_GOSUB         ; compare with GOSUB token
2190		.873c		f0 04						beq $8742				      BEQ   LAB_176B          ; branch if GOSUB
2192		.873e		c9 89						cmp #$89				      CMP   #TK_GOTO          ; compare with GOTO token
2193		.8740																		LAB_1767
2194		.8740		d0 e3						bne $8725				      BNE   LAB_16FD          ; if not GOTO do syntax error then warm start
2199		.8742																		LAB_176B
2200		.8742		c6 af						dec $af					      DEC   FAC1_3            ; decrement index (byte value)
2201		.8744		d0 04						bne $874a				      BNE   LAB_1773          ; branch if not zero
2203		.8746		68							pla							      PLA                     ; pull GOTO/GOSUB token
2204		.8747		4c 00 85				jmp $8500				      JMP   LAB_1602          ; go execute it
2206		.874a																		LAB_1773
2207		.874a		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment and scan memory
2208		.874d		20 56 87				jsr $8756				      JSR   LAB_GFPN          ; get fixed-point number into temp integer (skip this n)
2212		.8750		c9 2c						cmp #$2c				      CMP   #$2C              ; compare next character with ","
2213		.8752		f0 ee						beq $8742				      BEQ   LAB_176B          ; loop if ","
2215		.8754																		LAB_177E
2216		.8754		68							pla							      PLA                     ; else pull keyword token (run out of options)
2218		.8755																		LAB_177F
2219		.8755		60							rts							      RTS
2225		.8756																		LAB_GFPN
2226		.8756		a2 00						ldx #$00				      LDX   #$00              ; clear reg
2227		.8758		86 11						stx $11					      STX   Itempl            ; clear temporary integer low byte
2228		.875a																		LAB_1785
2229		.875a		86 12						stx $12					      STX   Itemph            ; save temporary integer high byte
2230		.875c		b0 f7						bcs $8755				      BCS   LAB_177F          ; return if carry set, end of scan, character was
2233		.875e		e0 19						cpx #$19				      CPX   #$19              ; compare high byte with $19
2234		.8760		a8							tay							      TAY                     ; ensure Zb = 0 if the branch is taken
2235		.8761		b0 dd						bcs $8740				      BCS   LAB_1767          ; branch if >=, makes max line # 63999 because next
2239		.8763		e9 2f						sbc #$2f				      SBC   #'0'-1            ; subtract "0", $2F + carry, from byte
2240		.8765		a8							tay							      TAY                     ; copy binary digit
2241		.8766		a5 11						lda $11					      LDA   Itempl            ; get temporary integer low byte
2242		.8768		0a							asl a						      ASL                     ; *2 low byte
2243		.8769		26 12						rol $12					      ROL   Itemph            ; *2 high byte
2244		.876b		0a							asl a						      ASL                     ; *2 low byte
2245		.876c		26 12						rol $12					      ROL   Itemph            ; *2 high byte, *4
2246		.876e		65 11						adc $11					      ADC   Itempl            ; + low byte, *5
2247		.8770		85 11						sta $11					      STA   Itempl            ; save it
2248		.8772		8a							txa							      TXA                     ; get high byte copy to A
2249		.8773		65 12						adc $12					      ADC   Itemph            ; + high byte, *5
2250		.8775		06 11						asl $11					      ASL   Itempl            ; *2 low byte, *10d
2251		.8777		2a							rol a						      ROL                     ; *2 high byte, *10d
2252		.8778		aa							tax							      TAX                     ; copy high byte back to X
2253		.8779		98							tya							      TYA                     ; get binary digit back
2254		.877a		65 11						adc $11					      ADC   Itempl            ; add number low byte
2255		.877c		85 11						sta $11					      STA   Itempl            ; save number low byte
2256		.877e		90 01						bcc $8781				      BCC   LAB_17B3          ; if no overflow to high byte get next character
2258		.8780		e8							inx							      INX                     ; else increment high byte
2259		.8781																		LAB_17B3
2260		.8781		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment and scan memory
2261		.8784		4c 5a 87				jmp $875a				      JMP   LAB_1785          ; loop for next character
2265		.8787																		LAB_DEC
2266		.8787		a9 f5						lda #$f5				      LDA   #<LAB_2AFD        ; set -1 pointer low byte
2267		>8789		2c															      .byte $2C               ; BIT abs to skip the LDA below
2271		.878a																		LAB_INC
2272		.878a		a9 f1						lda #$f1				      LDA   #<LAB_259C        ; set 1 pointer low byte
2273		.878c																		LAB_17B5
2274		.878c		48							pha							      PHA                     ; save +/-1 pointer low byte
2275		.878d																		LAB_17B7
2276		.878d		20 b8 8d				jsr $8db8				      JSR   LAB_GVAR          ; get var address
2277		.8790		a6 5f						ldx $5f					      LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
2278		.8792		30 1e						bmi $87b2				      BMI   IncrErr           ; exit if string
2280		.8794		85 97						sta $97					      STA   Lvarpl            ; save var address low byte
2281		.8796		84 98						sty $98					      STY   Lvarph            ; save var address high byte
2282		.8798		20 8a 98				jsr $988a				      JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
2283		.879b		68							pla							      PLA                     ; get +/-1 pointer low byte
2284		.879c		48							pha							      PHA                     ; save +/-1 pointer low byte
2285		.879d		a0 a1						ldy #$a1				      LDY   #>LAB_259C        ; set +/-1 pointer high byte (both the same)
2286		.879f		20 cb 95				jsr $95cb				      JSR   LAB_246C          ; add (AY) to FAC1
2287		.87a2		20 b0 98				jsr $98b0				      JSR   LAB_PFAC          ; pack FAC1 into variable (Lvarpl)
2289		.87a5		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; scan memory
2290		.87a8		c9 2c						cmp #$2c				      CMP   #','              ; compare with ","
2291		.87aa		d0 a8						bne $8754				      BNE   LAB_177E          ; exit if not "," (either end or error)
2294		.87ac		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment and scan memory
2295		.87af		4c 8d 87				jmp $878d				      JMP   LAB_17B7          ; go do next var
2297		.87b2																		IncrErr
2298		.87b2		4c dc 8a				jmp $8adc				      JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
2302		.87b5																		LAB_LET
2303		.87b5		20 b8 8d				jsr $8db8				      JSR   LAB_GVAR          ; get var address
2304		.87b8		85 97						sta $97					      STA   Lvarpl            ; save var address low byte
2305		.87ba		84 98						sty $98					      STY   Lvarph            ; save var address high byte
2306		.87bc		a9 c1						lda #$c1				      LDA   #TK_EQUAL         ; get = token
2307		.87be		20 f1 8b				jsr $8bf1				      JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
2308		.87c1		a5 5f						lda $5f					      LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
2309		.87c3		48							pha							      PHA                     ; push data type flag
2310		.87c4		20 e1 8a				jsr $8ae1				      JSR   LAB_EVEX          ; evaluate expression
2311		.87c7		68							pla							      PLA                     ; pop data type flag
2312		.87c8		2a							rol a						      ROL                     ; set carry if type = string
2319		.87c9		20 d3 8a				jsr $8ad3				      JSR   LAB_CKTM          ; type match check, keep C (expected type)
2320		.87cc		b0 03						bcs $87d1				      BCS   LAB_17D5          ; branch if string
2323		.87ce		4c b0 98				jmp $98b0				      JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
2327		.87d1																		LAB_17D5
2328		.87d1		a0 02						ldy #$02				      LDY   #$02              ; set index to pointer high byte
2329		.87d3		b1 ae						lda ($ae),y			      LDA   (des_pl),Y        ; get string pointer high byte
2330		.87d5		c5 82						cmp $82					      CMP   Sstorh            ; compare bottom of string space high byte
2331		.87d7		90 17						bcc $87f0				      BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
2333		.87d9		d0 07						bne $87e2				      BNE   LAB_17E6          ; branch if >
2335		.87db		88							dey							      DEY                     ; decrement index
2336		.87dc		b1 ae						lda ($ae),y			      LDA   (des_pl),Y        ; get pointer low byte
2337		.87de		c5 81						cmp $81					      CMP   Sstorl            ; compare bottom of string space low byte
2338		.87e0		90 0e						bcc $87f0				      BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
2341		.87e2																		LAB_17E6
2342		.87e2		a4 af						ldy $af					      LDY   des_ph            ; get descriptor pointer high byte
2343		.87e4		c4 7c						cpy $7c					      CPY   Svarh             ; compare start of vars high byte
2344		.87e6		90 08						bcc $87f0				      BCC   LAB_17F4          ; branch if less (descriptor is on stack)
2346		.87e8		d0 0d						bne $87f7				      BNE   LAB_17FB          ; branch if greater (descriptor is not on stack)
2349		.87ea		a5 ae						lda $ae					      LDA   des_pl            ; get descriptor pointer low byte
2350		.87ec		c5 7b						cmp $7b					      CMP   Svarl             ; compare start of vars low byte
2351		.87ee		b0 07						bcs $87f7				      BCS   LAB_17FB          ; branch if >= (descriptor is not on stack)
2353		.87f0																		LAB_17F4
2354		.87f0		a5 ae						lda $ae					      LDA   des_pl            ; get descriptor pointer low byte
2355		.87f2		a4 af						ldy $af					      LDY   des_ph            ; get descriptor pointer high byte
2356		.87f4		4c 0d 88				jmp $880d				      JMP   LAB_1811          ; clean stack, copy descriptor to variable and return
2359		.87f7																		LAB_17FB
2360		.87f7		a0 00						ldy #$00				      LDY   #$00              ; index to length
2361		.87f9		b1 ae						lda ($ae),y			      LDA   (des_pl),Y        ; get string length
2362		.87fb		20 40 91				jsr $9140				      JSR   LAB_209C          ; copy string
2363		.87fe		a5 9e						lda $9e					      LDA   des_2l            ; get descriptor pointer low byte
2364		.8800		a4 9f						ldy $9f					      LDY   des_2h            ; get descriptor pointer high byte
2365		.8802		85 b8						sta $b8					      STA   ssptr_l           ; save descriptor pointer low byte
2366		.8804		84 b9						sty $b9					      STY   ssptr_h           ; save descriptor pointer high byte
2367		.8806		20 25 93				jsr $9325				      JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
2368		.8809		a9 ac						lda #$ac				      LDA   #<FAC1_e          ; set descriptor pointer low byte
2369		.880b		a0 00						ldy #$00				      LDY   #>FAC1_e          ; get descriptor pointer high byte
2372		.880d																		LAB_1811
2373		.880d		85 9e						sta $9e					      STA   des_2l            ; save descriptor_2 pointer low byte
2374		.880f		84 9f						sty $9f					      STY   des_2h            ; save descriptor_2 pointer high byte
2375		.8811		20 87 93				jsr $9387				      JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
2376		.8814		a0 00						ldy #$00				      LDY   #$00              ; index to length
2377		.8816		b1 9e						lda ($9e),y			      LDA   (des_2l),Y        ; get string length
2378		.8818		91 97						sta ($97),y			      STA   (Lvarpl),Y        ; copy to let string variable
2379		.881a		c8							iny							      INY                     ; index to string pointer low byte
2380		.881b		b1 9e						lda ($9e),y			      LDA   (des_2l),Y        ; get string pointer low byte
2381		.881d		91 97						sta ($97),y			      STA   (Lvarpl),Y        ; copy to let string variable
2382		.881f		c8							iny							      INY                     ; index to string pointer high byte
2383		.8820		b1 9e						lda ($9e),y			      LDA   (des_2l),Y        ; get string pointer high byte
2384		.8822		91 97						sta ($97),y			      STA   (Lvarpl),Y        ; copy to let string variable
2385		.8824		60							rts							      RTS
2389		.8825																		LAB_GET
2390		.8825		20 b8 8d				jsr $8db8				      JSR   LAB_GVAR          ; get var address
2391		.8828		85 97						sta $97					      STA   Lvarpl            ; save var address low byte
2392		.882a		84 98						sty $98					      STY   Lvarph            ; save var address high byte
2393		.882c		20 0f 9f				jsr $9f0f				      JSR   INGET             ; get input byte
2394		.882f		a6 5f						ldx $5f					      LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
2395		.8831		30 07						bmi $883a				      BMI   LAB_GETS          ; go get string character
2398		.8833		a8							tay							      TAY                     ; copy character to Y
2399		.8834		20 74 90				jsr $9074				      JSR   LAB_1FD0          ; convert Y to byte in FAC1
2400		.8837		4c b0 98				jmp $98b0				      JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
2402		.883a																		LAB_GETS
2403		.883a		48							pha							      PHA                     ; save character
2404		.883b		a9 01						lda #$01				      LDA   #$01              ; string is single byte
2405		.883d		b0 01						bcs $8840				      BCS   LAB_IsByte        ; branch if byte received
2407		.883f		68							pla							      PLA                     ; string is null
2408		.8840																		LAB_IsByte
2409		.8840		20 48 91				jsr $9148				      JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
2411		.8843		f0 05						beq $884a				      BEQ   LAB_NoSt          ; skip store if null string
2413		.8845		68							pla							      PLA                     ; get character back
2414		.8846		a0 00						ldy #$00				      LDY   #$00              ; clear index
2415		.8848		91 ad						sta ($ad),y			      STA   (str_pl),Y        ; save byte in string (byte IS string!)
2416		.884a																		LAB_NoSt
2417		.884a		20 95 91				jsr $9195				      JSR   LAB_RTST          ; check for space on descriptor stack then put address
2420		.884d		4c d1 87				jmp $87d1				      JMP   LAB_17D5          ; do string LET and return
2424		.8850																		LAB_1829
2425		.8850		20 d7 88				jsr $88d7				      JSR   LAB_18C6          ; print string from Sutill/Sutilh
2426		.8853																		LAB_182C
2427		.8853		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; scan memory
2431		.8856																		LAB_PRINT
2432		.8856		f0 3b						beq $8893				      BEQ   LAB_CRLF          ; if nothing following just print CR/LF
2434		.8858																		LAB_1831
2435		.8858		c9 ab						cmp #$ab				      CMP   #TK_TAB           ; compare with TAB( token
2436		.885a		f0 56						beq $88b2				      BEQ   LAB_18A2          ; go do TAB/SPC
2438		.885c		c9 af						cmp #$af				      CMP   #TK_SPC           ; compare with SPC( token
2439		.885e		f0 52						beq $88b2				      BEQ   LAB_18A2          ; go do TAB/SPC
2441		.8860		c9 2c						cmp #$2c				      CMP   #','              ; compare with ","
2442		.8862		f0 38						beq $889c				      BEQ   LAB_188B          ; go do move to next TAB mark
2444		.8864		c9 3b						cmp #$3b				      CMP   #';'              ; compare with ";"
2445		.8866		f0 66						beq $88ce				      BEQ   LAB_18BD          ; if ";" continue with PRINT processing
2447		.8868		20 e1 8a				jsr $8ae1				      JSR   LAB_EVEX          ; evaluate expression
2448		.886b		24 5f						bit $5f					      BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
2449		.886d		30 e1						bmi $8850				      BMI   LAB_1829          ; branch if string
2451		.886f		20 a2 9a				jsr $9aa2				      JSR   LAB_296E          ; convert FAC1 to string
2452		.8872		20 52 91				jsr $9152				      JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
2453		.8875		a0 00						ldy #$00				      LDY   #$00              ; clear index
2457		.8877		a5 0f						lda $0f					      LDA   TWidth            ; get terminal width byte
2458		.8879		f0 0a						beq $8885				      BEQ   LAB_185E          ; skip check if zero
2460		.887b		38							sec							      SEC                     ; set carry for subtract
2461		.887c		e5 0e						sbc $0e					      SBC   TPos              ; subtract terminal position
2462		.887e		f1 ae						sbc ($ae),y			      SBC   (des_pl),Y        ; subtract string length
2463		.8880		b0 03						bcs $8885				      BCS   LAB_185E          ; branch if less than terminal width
2465		.8882		20 93 88				jsr $8893				      JSR   LAB_CRLF          ; else print CR/LF
2466		.8885																		LAB_185E
2467		.8885		20 d7 88				jsr $88d7				      JSR   LAB_18C6          ; print string from Sutill/Sutilh
2468		.8888		f0 c9						beq $8853				      BEQ   LAB_182C          ; always go continue processing line
2472		.888a																		LAB_1866
2473		.888a		a9 00						lda #$00				      LDA   #$00              ; clear byte
2474		.888c		9d 21 02				sta $0221,x			      STA   Ibuffs,X          ; null terminate input
2475		.888f		a2 21						ldx #$21				      LDX   #<Ibuffs          ; set X to buffer start-1 low byte
2476		.8891		a0 02						ldy #$02				      LDY   #>Ibuffs          ; set Y to buffer start-1 high byte
2480		.8893																		LAB_CRLF
2481		.8893		a9 0d						lda #$0d				      LDA   #$0D              ; load [CR]
2482		.8895		20 ee 88				jsr $88ee				      JSR   LAB_PRNA          ; go print the character
2483		.8898		a9 0a						lda #$0a				      LDA   #$0A              ; load [LF]
2484		.889a		d0 52						bne $88ee				      BNE   LAB_PRNA          ; go print the character and return, branch always
2486		.889c																		LAB_188B
2487		.889c		a5 0e						lda $0e					      LDA   TPos              ; get terminal position
2488		.889e		c5 10						cmp $10					      CMP   Iclim             ; compare with input column limit
2489		.88a0		90 05						bcc $88a7				      BCC   LAB_1897          ; branch if less
2491		.88a2		20 93 88				jsr $8893				      JSR   LAB_CRLF          ; else print CR/LF (next line)
2492		.88a5		d0 27						bne $88ce				      BNE   LAB_18BD          ; continue with PRINT processing (branch always)
2494		.88a7																		LAB_1897
2495		.88a7		38							sec							      SEC                     ; set carry for subtract
2496		.88a8																		LAB_1898
2497		.88a8		e5 64						sbc $64					      SBC   TabSiz            ; subtract TAB size
2498		.88aa		b0 fc						bcs $88a8				      BCS   LAB_1898          ; loop if result was +ve
2500		.88ac		49 ff						eor #$ff				      EOR   #$FF              ; complement it
2501		.88ae		69 01						adc #$01				      ADC   #$01              ; +1 (twos complement)
2502		.88b0		d0 12						bne $88c4				      BNE   LAB_18B6          ; always print A spaces (result is never $00)
2505		.88b2																		LAB_18A2
2506		.88b2		48							pha							      PHA                     ; save token
2507		.88b3		20 9d 94				jsr $949d				      JSR   LAB_SGBY          ; scan and get byte parameter
2508		.88b6		c9 29						cmp #$29				      CMP   #$29              ; is next character )
2509		.88b8		d0 7b						bne $8935				      BNE   LAB_1910          ; if not do syntax error then warm start
2511		.88ba		68							pla							      PLA                     ; get token back
2512		.88bb		c9 ab						cmp #$ab				      CMP   #TK_TAB           ; was it TAB ?
2513		.88bd		d0 06						bne $88c5				      BNE   LAB_18B7          ; if not go do SPC
2516		.88bf		8a							txa							      TXA                     ; copy integer value to A
2517		.88c0		e5 0e						sbc $0e					      SBC   TPos              ; subtract terminal position
2518		.88c2		90 0a						bcc $88ce				      BCC   LAB_18BD          ; branch if result was < 0 (can't TAB backwards)
2521		.88c4																		LAB_18B6
2522		.88c4		aa							tax							      TAX                     ; copy result to X
2523		.88c5																		LAB_18B7
2524		.88c5		8a							txa							      TXA                     ; set flags on size for SPC
2525		.88c6		f0 06						beq $88ce				      BEQ   LAB_18BD          ; branch if result was = $0, already here
2528		.88c8																		LAB_18BA
2529		.88c8		20 e9 88				jsr $88e9				      JSR   LAB_18E0          ; print " "
2530		.88cb		ca							dex							      DEX                     ; decrement count
2531		.88cc		d0 fa						bne $88c8				      BNE   LAB_18BA          ; loop if not all done
2534		.88ce																		LAB_18BD
2535		.88ce		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment and scan memory
2536		.88d1		d0 85						bne $8858				      BNE   LAB_1831          ; if more to print go do it
2538		.88d3		60							rts							      RTS
2542		.88d4																		LAB_18C3
2543		.88d4		20 52 91				jsr $9152				      JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
2547		.88d7																		LAB_18C6
2548		.88d7		20 52 93				jsr $9352				      JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
2551		.88da		a0 00						ldy #$00				      LDY   #$00              ; reset index
2552		.88dc		aa							tax							      TAX                     ; copy length to X
2553		.88dd		f0 49						beq $8928				      BEQ   LAB_188C          ; exit (RTS) if null string
2555		.88df																		LAB_18CD
2557		.88df		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get next byte
2558		.88e1		20 ee 88				jsr $88ee				      JSR   LAB_PRNA          ; go print the character
2559		.88e4		c8							iny							      INY                     ; increment index
2560		.88e5		ca							dex							      DEX                     ; decrement count
2561		.88e6		d0 f7						bne $88df				      BNE   LAB_18CD          ; loop if not done yet
2563		.88e8		60							rts							      RTS
2568		.88e9																		LAB_18E0
2569		.88e9		a9 20						lda #$20				      LDA   #$20              ; load " "
2570		>88eb		2c															      .byte $2C               ; change next line to BIT LAB_3FA9
2574		.88ec																		LAB_18E3
2575		.88ec		a9 3f						lda #$3f				      LDA   #$3F              ; load "?" character
2582		.88ee																		LAB_PRNA
2583		.88ee		c9 20						cmp #$20				      CMP   #' '              ; compare with " "
2584		.88f0		90 19						bcc $890b				      BCC   LAB_18F9          ; branch if less (non printing)
2587		.88f2		48							pha							      PHA                     ; save the character
2591		.88f3		a5 0f						lda $0f					      LDA   TWidth            ; get terminal width
2592		.88f5		d0 0a						bne $8901				      BNE   LAB_18F0          ; branch if not zero (not infinite length)
2596		.88f7		a5 0e						lda $0e					      LDA   TPos              ; get position
2597		.88f9		e5 64						sbc $64					      SBC   TabSiz            ; subtract TAB size, carry set by CMP #$20 above
2598		.88fb		d0 0b						bne $8908				      BNE   LAB_18F7          ; skip reset if different
2600		.88fd		85 0e						sta $0e					      STA   TPos              ; else reset position
2601		.88ff		f0 07						beq $8908				      BEQ   LAB_18F7          ; go print character
2603		.8901																		LAB_18F0
2604		.8901		c5 0e						cmp $0e					      CMP   TPos              ; compare with terminal character position
2605		.8903		d0 03						bne $8908				      BNE   LAB_18F7          ; branch if not at end of line
2607		.8905		20 93 88				jsr $8893				      JSR   LAB_CRLF          ; else print CR/LF
2608		.8908																		LAB_18F7
2609		.8908		e6 0e						inc $0e					      INC   TPos              ; increment terminal position
2610		.890a		68							pla							      PLA                     ; get character back
2611		.890b																		LAB_18F9
2612		.890b		20 fc a0				jsr $a0fc				      JSR   V_OUTP            ; output byte via output vector
2613		.890e		c9 0d						cmp #$0d				      CMP   #$0D              ; compare with [CR]
2614		.8910		d0 14						bne $8926				      BNE   LAB_188A          ; branch if not [CR]
2617		.8912		86 78						stx $78					      STX   TempB             ; save buffer index
2618		.8914		a6 0d						ldx $0d					      LDX   Nullct            ; get null count
2619		.8916		f0 0a						beq $8922				      BEQ   LAB_1886          ; branch if no nulls
2621		.8918		a9 00						lda #$00				      LDA   #$00              ; load [NULL]
2622		.891a																		LAB_1880
2623		.891a		20 ee 88				jsr $88ee				      JSR   LAB_PRNA          ; go print the character
2624		.891d		ca							dex							      DEX                     ; decrement count
2625		.891e		d0 fa						bne $891a				      BNE   LAB_1880          ; loop if not all done
2627		.8920		a9 0d						lda #$0d				      LDA   #$0D              ; restore the character (and set the flags)
2628		.8922																		LAB_1886
2629		.8922		86 0e						stx $0e					      STX   TPos              ; clear terminal position (X always = zero when we get here)
2630		.8924		a6 78						ldx $78					      LDX   TempB             ; restore buffer index
2631		.8926																		LAB_188A
2632		.8926		29 ff						and #$ff				      AND   #$FF              ; set the flags
2633		.8928																		LAB_188C
2634		.8928		60							rts							      RTS
2638		.8929																		LAB_1904
2639		.8929		a5 62						lda $62					      LDA   Imode             ; get input mode flag, $00=INPUT, $00=READ
2640		.892b		10 0b						bpl $8938				      BPL   LAB_1913          ; branch if INPUT (go do redo)
2642		.892d		a5 8d						lda $8d					      LDA   Dlinel            ; get current DATA line low byte
2643		.892f		a4 8e						ldy $8e					      LDY   Dlineh            ; get current DATA line high byte
2644		.8931		85 87						sta $87					      STA   Clinel            ; save current line low byte
2645		.8933		84 88						sty $88					      STY   Clineh            ; save current line high byte
2646		.8935																		LAB_1910
2647		.8935		4c 02 8c				jmp $8c02				      JMP   LAB_SNER          ; do syntax error then warm start
2650		.8938																		LAB_1913
2651		.8938		a9 23						lda #$23				      LDA   #<LAB_REDO        ; point to redo message (low addr)
2652		.893a		a0 a8						ldy #$a8				      LDY   #>LAB_REDO        ; point to redo message (high addr)
2653		.893c		20 d4 88				jsr $88d4				      JSR   LAB_18C3          ; print null terminated string from memory
2654		.893f		a5 8b						lda $8b					      LDA   Cpntrl            ; get continue pointer low byte
2655		.8941		a4 8c						ldy $8c					      LDY   Cpntrh            ; get continue pointer high byte
2656		.8943		85 c3						sta $c3					      STA   Bpntrl            ; save BASIC execute pointer low byte
2657		.8945		84 c4						sty $c4					      STY   Bpntrh            ; save BASIC execute pointer high byte
2658		.8947		60							rts							      RTS
2662		.8948																		LAB_INPUT
2663		.8948		c9 22						cmp #$22				      CMP   #$22              ; compare next byte with open quote
2664		.894a		d0 0b						bne $8957				      BNE   LAB_1934          ; branch if no prompt string
2666		.894c		20 be 8b				jsr $8bbe				      JSR   LAB_1BC1          ; print "..." string
2667		.894f		a9 3b						lda #$3b				      LDA   #$3B              ; load A with ";"
2668		.8951		20 f1 8b				jsr $8bf1				      JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
2669		.8954		20 d7 88				jsr $88d7				      JSR   LAB_18C6          ; print string from Sutill/Sutilh
2672		.8957																		LAB_1934
2673		.8957		20 78 90				jsr $9078				      JSR   LAB_CKRN          ; check not Direct, back here if ok
2674		.895a		20 43 82				jsr $8243				      JSR   LAB_INLN          ; print "? " and get BASIC input
2675		.895d		a9 00						lda #$00				      LDA   #$00              ; set mode = INPUT
2676		.895f		cd 21 02				cmp $0221				      CMP   Ibuffs            ; test first byte in buffer
2677		.8962		d0 09						bne $896d				      BNE   LAB_1953          ; branch if not null input
2681		.8964		4c 28 85				jmp $8528				      JMP   LAB_1647          ; go do BREAK exit
2685		.8967																		LAB_READ
2686		.8967		a6 8f						ldx $8f					      LDX   Dptrl             ; get DATA pointer low byte
2687		.8969		a4 90						ldy $90					      LDY   Dptrh             ; get DATA pointer high byte
2688		.896b		a9 80						lda #$80				      LDA   #$80              ; set mode = READ
2690		.896d																		LAB_1953
2691		.896d		85 62						sta $62					      STA   Imode             ; set input mode flag, $00=INPUT, $80=READ
2692		.896f		86 91						stx $91					      STX   Rdptrl            ; save READ pointer low byte
2693		.8971		84 92						sty $92					      STY   Rdptrh            ; save READ pointer high byte
2696		.8973																		LAB_195B
2697		.8973		20 b8 8d				jsr $8db8				      JSR   LAB_GVAR          ; get (var) address
2698		.8976		85 97						sta $97					      STA   Lvarpl            ; save address low byte
2699		.8978		84 98						sty $98					      STY   Lvarph            ; save address high byte
2700		.897a		a5 c3						lda $c3					      LDA   Bpntrl            ; get BASIC execute pointer low byte
2701		.897c		a4 c4						ldy $c4					      LDY   Bpntrh            ; get BASIC execute pointer high byte
2702		.897e		85 11						sta $11					      STA   Itempl            ; save as temporary integer low byte
2703		.8980		84 12						sty $12					      STY   Itemph            ; save as temporary integer high byte
2704		.8982		a6 91						ldx $91					      LDX   Rdptrl            ; get READ pointer low byte
2705		.8984		a4 92						ldy $92					      LDY   Rdptrh            ; get READ pointer high byte
2706		.8986		86 c3						stx $c3					      STX   Bpntrl            ; set BASIC execute pointer low byte
2707		.8988		84 c4						sty $c4					      STY   Bpntrh            ; set BASIC execute pointer high byte
2708		.898a		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; scan memory
2709		.898d		d0 11						bne $89a0				      BNE   LAB_1988          ; branch if not null
2712		.898f		24 62						bit $62					      BIT   Imode             ; test input mode flag, $00=INPUT, $80=READ
2713		.8991		30 65						bmi $89f8				      BMI   LAB_19DD          ; branch if READ
2716		.8993		20 ec 88				jsr $88ec				      JSR   LAB_18E3          ; print "?" character (double ? for extended input)
2717		.8996		20 43 82				jsr $8243				      JSR   LAB_INLN          ; print "? " and get BASIC input
2718		.8999		86 c3						stx $c3					      STX   Bpntrl            ; set BASIC execute pointer low byte
2719		.899b		84 c4						sty $c4					      STY   Bpntrh            ; set BASIC execute pointer high byte
2720		.899d																		LAB_1985
2721		.899d		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; scan memory
2722		.89a0																		LAB_1988
2723		.89a0		24 5f						bit $5f					      BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
2724		.89a2		10 24						bpl $89c8				      BPL   LAB_19B0          ; branch if numeric
2727		.89a4		85 5b						sta $5b					      STA   Srchc             ; save search character
2728		.89a6		c9 22						cmp #$22				      CMP   #$22              ; was it " ?
2729		.89a8		f0 07						beq $89b1				      BEQ   LAB_1999          ; branch if so
2731		.89aa		a9 3a						lda #$3a				      LDA   #':'              ; else search character is ":"
2732		.89ac		85 5b						sta $5b					      STA   Srchc             ; set new search character
2733		.89ae		a9 2c						lda #$2c				      LDA   #','              ; other search character is ","
2734		.89b0		18							clc							      CLC                     ; clear carry for add
2735		.89b1																		LAB_1999
2736		.89b1		85 5c						sta $5c					      STA   Asrch             ; set second search character
2737		.89b3		a5 c3						lda $c3					      LDA   Bpntrl            ; get BASIC execute pointer low byte
2738		.89b5		a4 c4						ldy $c4					      LDY   Bpntrh            ; get BASIC execute pointer high byte
2740		.89b7		69 00						adc #$00				      ADC   #$00              ; c is =1 if we came via the BEQ LAB_1999, else =0
2741		.89b9		90 01						bcc $89bc				      BCC   LAB_19A4          ; branch if no execute pointer low byte rollover
2743		.89bb		c8							iny							      INY                     ; else increment high byte
2744		.89bc																		LAB_19A4
2745		.89bc		20 58 91				jsr $9158				      JSR   LAB_20B4          ; print Srchc or Asrch terminated string to Sutill/Sutilh
2746		.89bf		20 dc 94				jsr $94dc				      JSR   LAB_23F3          ; restore BASIC execute pointer from temp (Btmpl/Btmph)
2747		.89c2		20 d1 87				jsr $87d1				      JSR   LAB_17D5          ; go do string LET
2748		.89c5		4c ce 89				jmp $89ce				      JMP   LAB_19B6          ; go check string terminator
2751		.89c8																		LAB_19B0
2752		.89c8		20 b3 99				jsr $99b3				      JSR   LAB_2887          ; get FAC1 from string
2753		.89cb		20 b0 98				jsr $98b0				      JSR   LAB_PFAC          ; pack FAC1 into (Lvarpl)
2754		.89ce																		LAB_19B6
2755		.89ce		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; scan memory
2756		.89d1		f0 0a						beq $89dd				      BEQ   LAB_19C5          ; branch if null (last entry)
2758		.89d3		c9 2c						cmp #$2c				      CMP   #','              ; else compare with ","
2759		.89d5		f0 03						beq $89da				      BEQ   LAB_19C2          ; branch if ","
2761		.89d7		4c 29 89				jmp $8929				      JMP   LAB_1904          ; else go handle bad input data
2764		.89da																		LAB_19C2
2765		.89da		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment and scan memory
2766		.89dd																		LAB_19C5
2767		.89dd		a5 c3						lda $c3					      LDA   Bpntrl            ; get BASIC execute pointer low byte (temp READ/INPUT ptr)
2768		.89df		a4 c4						ldy $c4					      LDY   Bpntrh            ; get BASIC execute pointer high byte (temp READ/INPUT ptr)
2769		.89e1		85 91						sta $91					      STA   Rdptrl            ; save for now
2770		.89e3		84 92						sty $92					      STY   Rdptrh            ; save for now
2771		.89e5		a5 11						lda $11					      LDA   Itempl            ; get temporary integer low byte (temp BASIC execute ptr)
2772		.89e7		a4 12						ldy $12					      LDY   Itemph            ; get temporary integer high byte (temp BASIC execute ptr)
2773		.89e9		85 c3						sta $c3					      STA   Bpntrl            ; set BASIC execute pointer low byte
2774		.89eb		84 c4						sty $c4					      STY   Bpntrh            ; set BASIC execute pointer high byte
2775		.89ed		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; scan memory
2776		.89f0		f0 2c						beq $8a1e				      BEQ   LAB_1A03          ; if null go do extra ignored message
2778		.89f2		20 fe 8b				jsr $8bfe				      JSR   LAB_1C01          ; else scan for "," , else do syntax error then warm start
2779		.89f5		4c 73 89				jmp $8973				      JMP   LAB_195B          ; go INPUT next variable from list
2782		.89f8																		LAB_19DD
2783		.89f8		20 9b 86				jsr $869b				      JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
2784		.89fb		c8							iny							      INY                     ; increment index
2785		.89fc		aa							tax							      TAX                     ; copy character ([:] or [EOL])
2786		.89fd		d0 12						bne $8a11				      BNE   LAB_19F6          ; branch if [:]
2788		.89ff		a2 06						ldx #$06				      LDX   #$06              ; set for "Out of DATA" error
2789		.8a01		c8							iny							      INY                     ; increment index, now points to next line pointer high byte
2790		.8a02		b1 c3						lda ($c3),y			      LDA   (Bpntrl),Y        ; get next line pointer high byte
2791		.8a04		f0 73						beq $8a79				      BEQ   LAB_1A54          ; branch if end (eventually does error X)
2793		.8a06		c8							iny							      INY                     ; increment index
2794		.8a07		b1 c3						lda ($c3),y			      LDA   (Bpntrl),Y        ; get next line # low byte
2795		.8a09		85 8d						sta $8d					      STA   Dlinel            ; save current DATA line low byte
2796		.8a0b		c8							iny							      INY                     ; increment index
2797		.8a0c		b1 c3						lda ($c3),y			      LDA   (Bpntrl),Y        ; get next line # high byte
2798		.8a0e		c8							iny							      INY                     ; increment index
2799		.8a0f		85 8e						sta $8e					      STA   Dlineh            ; save current DATA line high byte
2800		.8a11																		LAB_19F6
2801		.8a11		b1 c3						lda ($c3),y			      LDA   (Bpntrl),Y        ; get byte
2802		.8a13		c8							iny							      INY                     ; increment index
2803		.8a14		aa							tax							      TAX                     ; copy to X
2804		.8a15		20 8d 86				jsr $868d				      JSR   LAB_170F          ; set BASIC execute pointer
2805		.8a18		e0 83						cpx #$83				      CPX   #TK_DATA          ; compare with "DATA" token
2806		.8a1a		f0 81						beq $899d				      BEQ   LAB_1985          ; was "DATA" so go do next READ
2808		.8a1c		d0 da						bne $89f8				      BNE   LAB_19DD          ; go find next statement if not "DATA"
2812		.8a1e																		LAB_1A03
2813		.8a1e		a5 91						lda $91					      LDA   Rdptrl            ; get temp READ pointer low byte
2814		.8a20		a4 92						ldy $92					      LDY   Rdptrh            ; get temp READ pointer high byte
2815		.8a22		a6 62						ldx $62					      LDX   Imode             ; get input mode flag, $00=INPUT, $80=READ
2816		.8a24		10 03						bpl $8a29				      BPL   LAB_1A0E          ; branch if INPUT
2818		.8a26		4c 4a 85				jmp $854a				      JMP   LAB_1624          ; save AY as DATA pointer and return
2821		.8a29																		LAB_1A0E
2822		.8a29		a0 00						ldy #$00				      LDY   #$00              ; clear index
2823		.8a2b		b1 91						lda ($91),y			      LDA   (Rdptrl),Y        ; get next byte
2824		.8a2d		d0 01						bne $8a30				      BNE   LAB_1A1B          ; error if not end of INPUT
2826		.8a2f		60							rts							      RTS
2829		.8a30																		LAB_1A1B
2830		.8a30		a9 12						lda #$12				      LDA   #<LAB_IMSG        ; point to extra ignored message (low addr)
2831		.8a32		a0 a8						ldy #$a8				      LDY   #>LAB_IMSG        ; point to extra ignored message (high addr)
2832		.8a34		4c d4 88				jmp $88d4				      JMP   LAB_18C3          ; print null terminated string from memory and return
2837		.8a37																		LAB_11A1
2838		.8a37		ba							tsx							      TSX                     ; copy stack pointer
2839		.8a38		e8							inx							      INX                     ; +1 pass return address
2840		.8a39		e8							inx							      INX                     ; +2 pass return address
2841		.8a3a		e8							inx							      INX                     ; +3 pass calling routine return address
2842		.8a3b		e8							inx							      INX                     ; +4 pass calling routine return address
2843		.8a3c																		LAB_11A6
2844		.8a3c		bd 01 01				lda $0101,x			      LDA   LAB_STAK+1,X      ; get token byte from stack
2845		.8a3f		c9 81						cmp #$81				      CMP   #TK_FOR           ; is it FOR token
2846		.8a41		d0 21						bne $8a64				      BNE   LAB_11CE          ; exit if not FOR token
2849		.8a43		a5 98						lda $98					      LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
2850		.8a45		d0 0a						bne $8a51				      BNE   LAB_11BB          ; branch if not null
2852		.8a47		bd 02 01				lda $0102,x			      LDA   LAB_STAK+2,X      ; get FOR variable pointer low byte
2853		.8a4a		85 97						sta $97					      STA   Frnxtl            ; save var pointer for FOR/NEXT low byte
2854		.8a4c		bd 03 01				lda $0103,x			      LDA   LAB_STAK+3,X      ; get FOR variable pointer high byte
2855		.8a4f		85 98						sta $98					      STA   Frnxth            ; save var pointer for FOR/NEXT high byte
2856		.8a51																		LAB_11BB
2857		.8a51		dd 03 01				cmp $0103,x			      CMP   LAB_STAK+3,X      ; compare var pointer with stacked var pointer (high byte)
2858		.8a54		d0 07						bne $8a5d				      BNE   LAB_11C7          ; branch if no match
2860		.8a56		a5 97						lda $97					      LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
2861		.8a58		dd 02 01				cmp $0102,x			      CMP   LAB_STAK+2,X      ; compare var pointer with stacked var pointer (low byte)
2862		.8a5b		f0 07						beq $8a64				      BEQ   LAB_11CE          ; exit if match found
2864		.8a5d																		LAB_11C7
2865		.8a5d		8a							txa							      TXA                     ; copy index
2866		.8a5e		18							clc							      CLC                     ; clear carry for add
2867		.8a5f		69 10						adc #$10				      ADC   #$10              ; add FOR stack use size
2868		.8a61		aa							tax							      TAX                     ; copy back to index
2869		.8a62		d0 d8						bne $8a3c				      BNE   LAB_11A6          ; loop if not at start of stack
2871		.8a64																		LAB_11CE
2872		.8a64		60							rts							      RTS
2876		.8a65																		LAB_NEXT
2877		.8a65		d0 04						bne $8a6b				      BNE   LAB_1A46          ; branch if NEXT var
2879		.8a67		a0 00						ldy #$00				      LDY   #$00              ; else clear Y
2880		.8a69		f0 03						beq $8a6e				      BEQ   LAB_1A49          ; branch always (no variable to search for)
2884		.8a6b																		LAB_1A46
2885		.8a6b		20 b8 8d				jsr $8db8				      JSR   LAB_GVAR          ; get variable address
2886		.8a6e																		LAB_1A49
2887		.8a6e		85 97						sta $97					      STA   Frnxtl            ; store variable pointer low byte
2888		.8a70		84 98						sty $98					      STY   Frnxth            ; store variable pointer high byte
2890		.8a72		20 37 8a				jsr $8a37				      JSR   LAB_11A1          ; search the stack for FOR activity
2891		.8a75		f0 04						beq $8a7b				      BEQ   LAB_1A56          ; branch if found
2893		.8a77		a2 00						ldx #$00				      LDX   #$00              ; else set error $00 ("NEXT without FOR" error)
2894		.8a79																		LAB_1A54
2895		.8a79		f0 63						beq $8ade				      BEQ   LAB_1ABE          ; do error #X, then warm start
2897		.8a7b																		LAB_1A56
2898		.8a7b		9a							txs							      TXS                     ; set stack pointer, X set by search, dumps return addresses
2900		.8a7c		8a							txa							      TXA                     ; copy stack pointer
2901		.8a7d		38							sec							      SEC                     ; set carry for subtract
2902		.8a7e		e9 f7						sbc #$f7				      SBC   #$F7              ; point to TO var
2903		.8a80		85 73						sta $73					      STA   ut2_pl            ; save pointer to TO var for compare
2904		.8a82		69 fb						adc #$fb				      ADC   #$FB              ; point to STEP var
2906		.8a84		a0 01						ldy #$01				      LDY   #>LAB_STAK        ; point to stack page high byte
2907		.8a86		20 8a 98				jsr $988a				      JSR   LAB_UFAC          ; unpack memory (STEP value) into FAC1
2908		.8a89		ba							tsx							      TSX                     ; get stack pointer back
2909		.8a8a		bd 08 01				lda $0108,x			      LDA   LAB_STAK+8,X      ; get step sign
2910		.8a8d		85 b0						sta $b0					      STA   FAC1_s            ; save FAC1 sign (b7)
2911		.8a8f		a5 97						lda $97					      LDA   Frnxtl            ; get FOR variable pointer low byte
2912		.8a91		a4 98						ldy $98					      LDY   Frnxth            ; get FOR variable pointer high byte
2913		.8a93		20 cb 95				jsr $95cb				      JSR   LAB_246C          ; add (FOR variable) to FAC1
2914		.8a96		20 b0 98				jsr $98b0				      JSR   LAB_PFAC          ; pack FAC1 into (FOR variable)
2915		.8a99		a0 01						ldy #$01				      LDY   #>LAB_STAK        ; point to stack page high byte
2916		.8a9b		20 26 99				jsr $9926				      JSR   LAB_27FA          ; compare FAC1 with (Y,ut2_pl) (TO value)
2917		.8a9e		ba							tsx							      TSX                     ; get stack pointer back
2918		.8a9f		dd 08 01				cmp $0108,x			      CMP   LAB_STAK+8,X      ; compare step sign
2919		.8aa2		f0 17						beq $8abb				      BEQ   LAB_1A9B          ; branch if = (loop complete)
2922		.8aa4		bd 0d 01				lda $010d,x			      LDA   LAB_STAK+$0D,X    ; get FOR line low byte
2923		.8aa7		85 87						sta $87					      STA   Clinel            ; save current line low byte
2924		.8aa9		bd 0e 01				lda $010e,x			      LDA   LAB_STAK+$0E,X    ; get FOR line high byte
2925		.8aac		85 88						sta $88					      STA   Clineh            ; save current line high byte
2926		.8aae		bd 10 01				lda $0110,x			      LDA   LAB_STAK+$10,X    ; get BASIC execute pointer low byte
2927		.8ab1		85 c3						sta $c3					      STA   Bpntrl            ; save BASIC execute pointer low byte
2928		.8ab3		bd 0f 01				lda $010f,x			      LDA   LAB_STAK+$0F,X    ; get BASIC execute pointer high byte
2929		.8ab6		85 c4						sta $c4					      STA   Bpntrh            ; save BASIC execute pointer high byte
2930		.8ab8																		LAB_1A98
2931		.8ab8		4c c0 84				jmp $84c0				      JMP   LAB_15C2          ; go do interpreter inner loop
2934		.8abb																		LAB_1A9B
2935		.8abb		8a							txa							      TXA                     ; stack copy to A
2936		.8abc		69 0f						adc #$0f				      ADC   #$0F              ; add $10 ($0F+carry) to dump FOR structure
2937		.8abe		aa							tax							      TAX                     ; copy back to index
2938		.8abf		9a							txs							      TXS                     ; copy to stack pointer
2939		.8ac0		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; scan memory
2940		.8ac3		c9 2c						cmp #$2c				      CMP   #','              ; compare with ","
2941		.8ac5		d0 f1						bne $8ab8				      BNE   LAB_1A98          ; branch if not "," (go do interpreter inner loop)
2944		.8ac7		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; else increment and scan memory
2945		.8aca		20 6b 8a				jsr $8a6b				      JSR   LAB_1A46          ; do NEXT (var)
2949		.8acd																		LAB_EVNM
2950		.8acd		20 e1 8a				jsr $8ae1				      JSR   LAB_EVEX          ; evaluate expression
2954		.8ad0																		LAB_CTNM
2955		.8ad0		18							clc							      CLC                     ; destination is numeric
2956		>8ad1		24															      .byte $24               ; makes next line BIT $38
2960		.8ad2																		LAB_CTST
2961		.8ad2		38							sec							      SEC                     ; required type is string
2965		.8ad3																		LAB_CKTM
2966		.8ad3		24 5f						bit $5f					      BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
2967		.8ad5		30 03						bmi $8ada				      BMI   LAB_1ABA          ; branch if data type is string
2970		.8ad7		b0 03						bcs $8adc				      BCS   LAB_1ABC          ; if required type is string do type mismatch error
2971		.8ad9																		LAB_1AB9
2972		.8ad9		60							rts							      RTS
2975		.8ada																		LAB_1ABA
2976		.8ada		b0 fd						bcs $8ad9				      BCS   LAB_1AB9          ; exit if required type is string
2979		.8adc																		LAB_1ABC
2980		.8adc		a2 18						ldx #$18				      LDX   #$18              ; error code $18 ("Type mismatch" error)
2981		.8ade																		LAB_1ABE
2982		.8ade		4c 3f 81				jmp $813f				      JMP   LAB_XERR          ; do error #X, then warm start
2986		.8ae1																		LAB_EVEX
2987		.8ae1		a6 c3						ldx $c3					      LDX   Bpntrl            ; get BASIC execute pointer low byte
2988		.8ae3		d0 02						bne $8ae7				      BNE   LAB_1AC7          ; skip next if not zero
2990		.8ae5		c6 c4						dec $c4					      DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
2991		.8ae7																		LAB_1AC7
2992		.8ae7		c6 c3						dec $c3					      DEC   Bpntrl            ; decrement BASIC execute pointer low byte
2994		.8ae9																		LAB_EVEZ
2995		.8ae9		a9 00						lda #$00				      LDA   #$00              ; set null precedence (flag done)
2996		.8aeb																		LAB_1ACC
2997		.8aeb		48							pha							      PHA                     ; push precedence byte
2998		.8aec		a9 02						lda #$02				      LDA   #$02              ; 2 bytes
2999		.8aee		20 03 81				jsr $8103				      JSR   LAB_1212          ; check room on stack for A bytes
3000		.8af1		20 cd 8b				jsr $8bcd				      JSR   LAB_GVAL          ; get value from line
3001		.8af4		a9 00						lda #$00				      LDA   #$00              ; clear A
3002		.8af6		85 9b						sta $9b					      STA   comp_f            ; clear compare function flag
3003		.8af8																		LAB_1ADB
3004		.8af8		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; scan memory
3005		.8afb																		LAB_1ADE
3006		.8afb		38							sec							      SEC                     ; set carry for subtract
3007		.8afc		e9 c0						sbc #$c0				      SBC   #TK_GT            ; subtract token for > (lowest comparison function)
3008		.8afe		90 17						bcc $8b17				      BCC   LAB_1AFA          ; branch if < TK_GT
3010		.8b00		c9 03						cmp #$03				      CMP   #$03              ; compare with ">" to "<" tokens
3011		.8b02		b0 13						bcs $8b17				      BCS   LAB_1AFA          ; branch if >= TK_SGN (highest evaluation function +1)
3014		.8b04		c9 01						cmp #$01				      CMP   #$01              ; compare with token for =
3015		.8b06		2a							rol a						      ROL                     ; *2, b0 = carry (=1 if token was = or <)
3017		.8b07		49 01						eor #$01				      EOR   #$01              ; toggle b0
3019		.8b09		45 9b						eor $9b					      EOR   comp_f            ; EOR with compare function flag bits
3020		.8b0b		c5 9b						cmp $9b					      CMP   comp_f            ; compare with compare function flag
3021		.8b0d		90 67						bcc $8b76				      BCC   LAB_1B53          ; if <(comp_f) do syntax error then warm start
3024		.8b0f		85 9b						sta $9b					      STA   comp_f            ; save new compare function flag
3025		.8b11		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment and scan memory
3026		.8b14		4c fb 8a				jmp $8afb				      JMP   LAB_1ADE          ; go do next character
3029		.8b17																		LAB_1AFA
3030		.8b17		a6 9b						ldx $9b					      LDX   comp_f            ; get compare function flag
3031		.8b19		d0 2c						bne $8b47				      BNE   LAB_1B2A          ; branch if compare function
3033		.8b1b		b0 79						bcs $8b96				      BCS   LAB_1B78          ; go do functions
3036		.8b1d		69 0a						adc #$0a				      ADC   #TK_GT-TK_PLUS    ; add # of operators (+, -, *, /, ^, AND, OR or EOR)
3037		.8b1f		90 75						bcc $8b96				      BCC   LAB_1B78          ; branch if < + operator
3040		.8b21		d0 07						bne $8b2a				      BNE   LAB_1B0B          ; branch if not + token
3042		.8b23		24 5f						bit $5f					      BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
3043		.8b25		10 03						bpl $8b2a				      BPL   LAB_1B0B          ; branch if not string
3046		.8b27		4c e8 92				jmp $92e8				      JMP   LAB_224D          ; add strings, string 1 is in descriptor des_pl, string 2
3049		.8b2a																		LAB_1B0B
3050		.8b2a		85 71						sta $71					      STA   ut1_pl            ; save it
3051		.8b2c		0a							asl a						      ASL                     ; *2
3052		.8b2d		65 71						adc $71					      ADC   ut1_pl            ; *3
3053		.8b2f		a8							tay							      TAY                     ; copy to index
3054		.8b30																		LAB_1B13
3055		.8b30		68							pla							      PLA                     ; pull previous precedence
3056		.8b31		d9 fa a2				cmp $a2fa,y			      CMP   LAB_OPPT,Y        ; compare with precedence byte
3057		.8b34		b0 65						bcs $8b9b				      BCS   LAB_1B7D          ; branch if A >=
3059		.8b36		20 d0 8a				jsr $8ad0				      JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
3060		.8b39																		LAB_1B1C
3061		.8b39		48							pha							      PHA                     ; save precedence
3062		.8b3a																		LAB_1B1D
3063		.8b3a		20 62 8b				jsr $8b62				      JSR   LAB_1B43          ; get vector, execute function then continue evaluation
3064		.8b3d		68							pla							      PLA                     ; restore precedence
3065		.8b3e		a4 99						ldy $99					      LDY   prstk             ; get precedence stacked flag
3066		.8b40		10 19						bpl $8b5b				      BPL   LAB_1B3C          ; branch if stacked values
3068		.8b42		aa							tax							      TAX                     ; copy precedence (set flags)
3069		.8b43		f0 76						beq $8bbb				      BEQ   LAB_1B9D          ; exit if done
3071		.8b45		d0 5d						bne $8ba4				      BNE   LAB_1B86          ; else pop FAC2 and return, branch always
3073		.8b47																		LAB_1B2A
3074		.8b47		26 5f						rol $5f					      ROL   Dtypef            ; shift data type flag into Cb
3075		.8b49		8a							txa							      TXA                     ; copy compare function flag
3076		.8b4a		85 5f						sta $5f					      STA   Dtypef            ; clear data type flag, X is 0xxx xxxx
3077		.8b4c		2a							rol a						      ROL                     ; shift data type into compare function byte b0
3078		.8b4d		a6 c3						ldx $c3					      LDX   Bpntrl            ; get BASIC execute pointer low byte
3079		.8b4f		d0 02						bne $8b53				      BNE   LAB_1B34          ; branch if no underflow
3081		.8b51		c6 c4						dec $c4					      DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
3082		.8b53																		LAB_1B34
3083		.8b53		c6 c3						dec $c3					      DEC   Bpntrl            ; decrement BASIC execute pointer low byte
3084		=12																			TK_LT_PLUS  = TK_LT-TK_PLUS
3085		.8b55		a0 24						ldy #$24				      LDY   #TK_LT_PLUS*3     ; set offset to last operator entry
3086		.8b57		85 9b						sta $9b					      STA   comp_f            ; save new compare function flag
3087		.8b59		d0 d5						bne $8b30				      BNE   LAB_1B13          ; branch always
3089		.8b5b																		LAB_1B3C
3090		.8b5b		d9 fa a2				cmp $a2fa,y			      CMP   LAB_OPPT,Y        ;.compare with stacked function precedence
3091		.8b5e		b0 44						bcs $8ba4				      BCS   LAB_1B86          ; branch if A >=, pop FAC2 and return
3093		.8b60		90 d7						bcc $8b39				      BCC   LAB_1B1C          ; branch always
3097		.8b62																		LAB_1B43
3098		.8b62		b9 fc a2				lda $a2fc,y			      LDA   LAB_OPPT+2,Y      ; get function vector high byte
3099		.8b65		48							pha							      PHA                     ; onto stack
3100		.8b66		b9 fb a2				lda $a2fb,y			      LDA   LAB_OPPT+1,Y      ; get function vector low byte
3101		.8b69		48							pha							      PHA                     ; onto stack
3109		.8b6a		20 79 8b				jsr $8b79				      JSR   LAB_1B5B          ; function will return here, then the next RTS will call
3111		.8b6d		a5 9b						lda $9b					      LDA   comp_f            ; get compare function flag
3112		.8b6f		48							pha							      PHA                     ; push compare evaluation byte
3113		.8b70		b9 fa a2				lda $a2fa,y			      LDA   LAB_OPPT,Y        ; get precedence byte
3114		.8b73		4c eb 8a				jmp $8aeb				      JMP   LAB_1ACC          ; continue evaluating expression
3116		.8b76																		LAB_1B53
3117		.8b76		4c 02 8c				jmp $8c02				      JMP   LAB_SNER          ; do syntax error then warm start
3121		.8b79																		LAB_1B5B
3122		.8b79		68							pla							      PLA                     ; get return addr low byte
3123		.8b7a		85 71						sta $71					      STA   ut1_pl            ; save it
3124		.8b7c		e6 71						inc $71					      INC   ut1_pl            ; increment it (was ret-1 pushed? yes!)
3128		.8b7e		68							pla							      PLA                     ; get return addr high byte
3129		.8b7f		85 72						sta $72					      STA   ut1_ph            ; save it
3130		.8b81		a5 b0						lda $b0					      LDA   FAC1_s            ; get FAC1 sign (b7)
3131		.8b83		48							pha							      PHA                     ; push sign
3140		.8b84		20 e6 98				jsr $98e6				      JSR   LAB_27BA          ; round FAC1
3141		.8b87																		LAB_1B66
3143		.8b87		a5 af						lda $af					      LDA   FAC1_3            ; get FAC1 mantissa3
3144		.8b89		48							pha							      PHA                     ; push on stack
3145		.8b8a		a5 ae						lda $ae					      LDA   FAC1_2            ; get FAC1 mantissa2
3146		.8b8c		48							pha							      PHA                     ; push on stack
3147		.8b8d		a5 ad						lda $ad					      LDA   FAC1_1            ; get FAC1 mantissa1
3148		.8b8f		48							pha							      PHA                     ; push on stack
3149		.8b90		a5 ac						lda $ac					      LDA   FAC1_e            ; get FAC1 exponent
3150		.8b92		48							pha							      PHA                     ; push on stack
3151		.8b93		6c 71 00				jmp ($0071)			      JMP   (ut1_pl)          ; return, sort of
3155		.8b96																		LAB_1B78
3156		.8b96		a0 ff						ldy #$ff				      LDY   #$FF              ; flag function
3157		.8b98		68							pla							      PLA                     ; pull precedence byte
3158		.8b99																		LAB_1B7B
3159		.8b99		f0 20						beq $8bbb				      BEQ   LAB_1B9D          ; exit if done
3161		.8b9b																		LAB_1B7D
3162		.8b9b		c9 64						cmp #$64				      CMP   #$64              ; compare previous precedence with $64
3163		.8b9d		f0 03						beq $8ba2				      BEQ   LAB_1B84          ; branch if was $64 (< function)
3165		.8b9f		20 d0 8a				jsr $8ad0				      JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
3166		.8ba2																		LAB_1B84
3167		.8ba2		84 99						sty $99					      STY   prstk             ; save precedence stacked flag
3170		.8ba4																		LAB_1B86
3171		.8ba4		68							pla							      PLA                     ; pop byte
3172		.8ba5		4a							lsr a						      LSR                     ; shift out comparison evaluation lowest bit
3173		.8ba6		85 63						sta $63					      STA   Cflag             ; save comparison evaluation flag
3174		.8ba8		68							pla							      PLA                     ; pop exponent
3175		.8ba9		85 b3						sta $b3					      STA   FAC2_e            ; save FAC2 exponent
3176		.8bab		68							pla							      PLA                     ; pop mantissa1
3177		.8bac		85 b4						sta $b4					      STA   FAC2_1            ; save FAC2 mantissa1
3178		.8bae		68							pla							      PLA                     ; pop mantissa2
3179		.8baf		85 b5						sta $b5					      STA   FAC2_2            ; save FAC2 mantissa2
3180		.8bb1		68							pla							      PLA                     ; pop mantissa3
3181		.8bb2		85 b6						sta $b6					      STA   FAC2_3            ; save FAC2 mantissa3
3182		.8bb4		68							pla							      PLA                     ; pop sign
3183		.8bb5		85 b7						sta $b7					      STA   FAC2_s            ; save FAC2 sign (b7)
3184		.8bb7		45 b0						eor $b0					      EOR   FAC1_s            ; EOR FAC1 sign (b7)
3185		.8bb9		85 b8						sta $b8					      STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
3186		.8bbb																		LAB_1B9D
3187		.8bbb		a5 ac						lda $ac					      LDA   FAC1_e            ; get FAC1 exponent
3188		.8bbd		60							rts							      RTS
3192		.8bbe																		LAB_1BC1
3193		.8bbe		a5 c3						lda $c3					      LDA   Bpntrl            ; get BASIC execute pointer low byte
3194		.8bc0		a4 c4						ldy $c4					      LDY   Bpntrh            ; get BASIC execute pointer high byte
3195		.8bc2		69 00						adc #$00				      ADC   #$00              ; add carry to low byte
3196		.8bc4		90 01						bcc $8bc7				      BCC   LAB_1BCA          ; branch if no overflow
3198		.8bc6		c8							iny							      INY                     ; increment high byte
3199		.8bc7																		LAB_1BCA
3200		.8bc7		20 52 91				jsr $9152				      JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
3201		.8bca		4c dc 94				jmp $94dc				      JMP   LAB_23F3          ; restore BASIC execute pointer from temp and return
3205		.8bcd																		LAB_GVAL
3206		.8bcd		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment and scan memory
3207		.8bd0		b0 03						bcs $8bd5				      BCS   LAB_1BAC          ; branch if not numeric character
3210		.8bd2																		LAB_1BA9
3211		.8bd2		4c b3 99				jmp $99b3				      JMP   LAB_2887          ; get FAC1 from string and return
3216		.8bd5																		LAB_1BAC
3217		.8bd5		aa							tax							      TAX                     ; set the flags
3218		.8bd6		30 2f						bmi $8c07				      BMI   LAB_1BD0          ; if -ve go test token values
3221		.8bd8		c9 24						cmp #$24				      CMP   #'$'              ; compare with "$"
3222		.8bda		f0 f6						beq $8bd2				      BEQ   LAB_1BA9          ; branch if "$", hex number
3224		.8bdc		c9 25						cmp #$25				      CMP   #'%'              ; else compare with "%"
3225		.8bde		f0 f2						beq $8bd2				      BEQ   LAB_1BA9          ; branch if "%", binary number
3227		.8be0		c9 2e						cmp #$2e				      CMP   #'.'              ; compare with "."
3228		.8be2		f0 ee						beq $8bd2				      BEQ   LAB_1BA9          ; if so get FAC1 from string and return (e.g. was .123)
3231		.8be4		c9 22						cmp #$22				      CMP   #$22              ; compare with "
3232		.8be6		f0 d6						beq $8bbe				      BEQ   LAB_1BC1          ; branch if open quote
3238		.8be8		c9 28						cmp #$28				      CMP   #'('              ; compare with "("
3239		.8bea		d0 5b						bne $8c47				      BNE   LAB_1C18          ; if not "(" get (var), return value in FAC1 and $ flag
3241		.8bec																		LAB_1BF7
3242		.8bec		20 e9 8a				jsr $8ae9				      JSR   LAB_EVEZ          ; evaluate expression, no decrement
3248		.8bef																		LAB_1BFB
3249		.8bef		a9 29						lda #$29				      LDA   #$29              ; load A with ")"
3253		.8bf1																		LAB_SCCA
3254		.8bf1		a0 00						ldy #$00				      LDY   #$00              ; clear index
3255		.8bf3		d1 c3						cmp ($c3),y			      CMP   (Bpntrl),Y        ; check next byte is = A
3256		.8bf5		d0 0b						bne $8c02				      BNE   LAB_SNER          ; if not do syntax error then warm start
3258		.8bf7		4c bc 00				jmp $00bc				      JMP   LAB_IGBY          ; increment and scan memory then return
3262		.8bfa																		LAB_1BFE
3263		.8bfa		a9 28						lda #$28				      LDA   #$28              ; load A with "("
3264		.8bfc		d0 f3						bne $8bf1				      BNE   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
3269		.8bfe																		LAB_1C01
3270		.8bfe		a9 2c						lda #$2c				      LDA   #$2C              ; load A with ","
3271		.8c00		d0 ef						bne $8bf1				      BNE   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
3276		.8c02																		LAB_SNER
3277		.8c02		a2 02						ldx #$02				      LDX   #$02              ; error code $02 ("Syntax" error)
3278		.8c04		4c 3f 81				jmp $813f				      JMP   LAB_XERR          ; do error #X, then warm start
3283		.8c07																		LAB_1BD0
3284		.8c07		c9 b7						cmp #$b7				      CMP   #TK_MINUS         ; compare with token for -
3285		.8c09		f0 29						beq $8c34				      BEQ   LAB_1C11          ; branch if - token (do set-up for functions)
3288		.8c0b		c9 b6						cmp #$b6				      CMP   #TK_PLUS          ; compare with token for +
3289		.8c0d		f0 be						beq $8bcd				      BEQ   LAB_GVAL          ; branch if + token (+n = n so ignore leading +)
3291		.8c0f		c9 b1						cmp #$b1				      CMP   #TK_NOT           ; compare with token for NOT
3292		.8c11		d0 13						bne $8c26				      BNE   LAB_1BE7          ; branch if not token for NOT
3295		=11																			TK_EQUAL_PLUS     = TK_EQUAL-TK_PLUS
3296		.8c13		a0 21						ldy #$21				      LDY   #TK_EQUAL_PLUS*3  ; offset to NOT function
3297		.8c15		d0 1f						bne $8c36				      BNE   LAB_1C13          ; do set-up for function then execute (branch always)
3301		.8c17																		LAB_EQUAL
3302		.8c17		20 b4 8e				jsr $8eb4				      JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
3303		.8c1a		a5 af						lda $af					      LDA   FAC1_3            ; get FAC1 mantissa3
3304		.8c1c		49 ff						eor #$ff				      EOR   #$FF              ; invert it
3305		.8c1e		a8							tay							      TAY                     ; copy it
3306		.8c1f		a5 ae						lda $ae					      LDA   FAC1_2            ; get FAC1 mantissa2
3307		.8c21		49 ff						eor #$ff				      EOR   #$FF              ; invert it
3308		.8c23		4c 67 90				jmp $9067				      JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
3313		.8c26																		LAB_1BE7
3314		.8c26		c9 ae						cmp #$ae				      CMP   #TK_FN            ; compare with token for FN
3315		.8c28		d0 03						bne $8c2d				      BNE   LAB_1BEE          ; branch if not token for FN
3317		.8c2a		4c c2 90				jmp $90c2				      JMP   LAB_201E          ; go evaluate FNx
3322		.8c2d																		LAB_1BEE
3323		.8c2d		e9 c3						sbc #$c3				      SBC   #TK_SGN           ; subtract with token for SGN
3324		.8c2f		b0 27						bcs $8c58				      BCS   LAB_1C27          ; if a function token go do it
3326		.8c31		4c 02 8c				jmp $8c02				      JMP   LAB_SNER          ; else do syntax error
3330		.8c34																		LAB_1C11
3331		=10																			TK_GT_PLUS  = TK_GT-TK_PLUS
3332		.8c34		a0 1e						ldy #$1e				      LDY   #TK_GT_PLUS*3     ; set offset from base to > operator
3333		.8c36																		LAB_1C13
3334		.8c36		68							pla							      PLA                     ; dump return address low byte
3340		.8c37		aa							tax							      TAX                     ; save to trap concatenate
3341		.8c38		68							pla							      PLA                     ; dump return address high byte
3342		.8c39		e0 f0						cpx #$f0				      CPX   #<(LAB_224Da+2)   ; from concatenate low return address?
3343		.8c3b		d0 04						bne $8c41				      BNE   LAB_1C13b         ; No - continue!
3344		.8c3d		c9 92						cmp #$92				      CMP   #>(LAB_224Da+2)   ; from concatenate high return address?
3345		.8c3f		f0 03						beq $8c44				      BEQ   LAB_1C13a         ; Yes - error!
3346		.8c41																		LAB_1C13b
3347		.8c41		4c 3a 8b				jmp $8b3a				      JMP   LAB_1B1D          ; execute function then continue evaluation
3348		.8c44																		LAB_1C13a
3349		.8c44		4c dc 8a				jmp $8adc				      JMP   LAB_1ABC          ; throw "type mismatch error" then warm start
3355		.8c47																		LAB_1C18
3356		.8c47		20 b8 8d				jsr $8db8				      JSR   LAB_GVAR          ; get (var) address
3357		.8c4a		85 ae						sta $ae					      STA   FAC1_2            ; save address low byte in FAC1 mantissa2
3358		.8c4c		84 af						sty $af					      STY   FAC1_3            ; save address high byte in FAC1 mantissa3
3359		.8c4e		a6 5f						ldx $5f					      LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
3360		.8c50		30 03						bmi $8c55				      BMI   LAB_1C25          ; if string then return (does RTS)
3362		.8c52																		LAB_1C24
3363		.8c52		4c 8a 98				jmp $988a				      JMP   LAB_UFAC          ; unpack memory (AY) into FAC1
3365		.8c55																		LAB_1C25
3368		.8c55		46 b9						lsr $b9					      LSR   FAC1_r            ; clear bit 7 (<$80) = do not round up
3370		.8c57		60							rts							      RTS
3387		.8c58																		LAB_1C27
3388		.8c58		0a							asl a						      ASL                     ; *2 (2 bytes per function address)
3389		.8c59		a8							tay							      TAY                     ; copy to index
3391		.8c5a		b9 b5 a2				lda $a2b5,y			      LDA   LAB_FTBM,Y        ; get function jump vector high byte
3392		.8c5d		48							pha							      PHA                     ; push functions jump vector high byte
3393		.8c5e		b9 b4 a2				lda $a2b4,y			      LDA   LAB_FTBL,Y        ; get function jump vector low byte
3394		.8c61		48							pha							      PHA                     ; push functions jump vector low byte
3396		.8c62		b9 6f a2				lda $a26f,y			      LDA   LAB_FTPM,Y        ; get function pre process vector high byte
3397		.8c65		f0 05						beq $8c6c				      BEQ   LAB_1C56          ; skip pre process if null vector
3399		.8c67		48							pha							      PHA                     ; push functions pre process vector high byte
3400		.8c68		b9 6e a2				lda $a26e,y			      LDA   LAB_FTPL,Y        ; get function pre process vector low byte
3401		.8c6b		48							pha							      PHA                     ; push functions pre process vector low byte
3403		.8c6c																		LAB_1C56
3404		.8c6c		60							rts							      RTS                     ; do function, or pre process, call
3408		.8c6d																		LAB_PPFS
3409		.8c6d		20 ec 8b				jsr $8bec				      JSR   LAB_1BF7          ; process expression in parenthesis
3410		.8c70		4c d2 8a				jmp $8ad2				      JMP   LAB_CTST          ; check if source is string then do function,
3415		.8c73																		LAB_PPFN
3416		.8c73		20 ec 8b				jsr $8bec				      JSR   LAB_1BF7          ; process expression in parenthesis
3417		.8c76		4c d0 8a				jmp $8ad0				      JMP   LAB_CTNM          ; check if source is numeric then do function,
3422		.8c79																		LAB_PPBI
3423		.8c79		46 5f						lsr $5f					      LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
3424		.8c7b		4c bc 00				jmp $00bc				      JMP   LAB_IGBY          ; increment and scan memory then do function
3428		.8c7e																		LAB_LRMS
3429		.8c7e		20 e9 8a				jsr $8ae9				      JSR   LAB_EVEZ          ; evaluate (should be string) expression
3430		.8c81		20 fe 8b				jsr $8bfe				      JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
3431		.8c84		20 d2 8a				jsr $8ad2				      JSR   LAB_CTST          ; check if source is string, else do type mismatch
3433		.8c87		68							pla							      PLA                     ; get function jump vector low byte
3434		.8c88		aa							tax							      TAX                     ; save functions jump vector low byte
3435		.8c89		68							pla							      PLA                     ; get function jump vector high byte
3436		.8c8a		a8							tay							      TAY                     ; save functions jump vector high byte
3437		.8c8b		a5 af						lda $af					      LDA   des_ph            ; get descriptor pointer high byte
3438		.8c8d		48							pha							      PHA                     ; push string pointer high byte
3439		.8c8e		a5 ae						lda $ae					      LDA   des_pl            ; get descriptor pointer low byte
3440		.8c90		48							pha							      PHA                     ; push string pointer low byte
3441		.8c91		98							tya							      TYA                     ; get function jump vector high byte back
3442		.8c92		48							pha							      PHA                     ; save functions jump vector high byte
3443		.8c93		8a							txa							      TXA                     ; get function jump vector low byte back
3444		.8c94		48							pha							      PHA                     ; save functions jump vector low byte
3445		.8c95		20 a0 94				jsr $94a0				      JSR   LAB_GTBY          ; get byte parameter
3446		.8c98		8a							txa							      TXA                     ; copy byte parameter to A
3447		.8c99		60							rts							      RTS                     ; go do function
3451		.8c9a																		LAB_BHSS
3452		.8c9a		20 e9 8a				jsr $8ae9				      JSR   LAB_EVEZ          ; process expression
3453		.8c9d		20 d0 8a				jsr $8ad0				      JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
3454		.8ca0		a5 ac						lda $ac					      LDA   FAC1_e            ; get FAC1 exponent
3455		.8ca2		c9 98						cmp #$98				      CMP   #$98              ; compare with exponent = 2^24
3456		.8ca4		b0 20						bcs $8cc6				      BCS   LAB_BHER          ; branch if n>=2^24 (is too big)
3458		.8ca6		20 5d 99				jsr $995d				      JSR   LAB_2831          ; convert FAC1 floating-to-fixed
3459		.8ca9		a2 02						ldx #$02				      LDX   #$02              ; 3 bytes to do
3460		.8cab																		LAB_CFAC
3461		.8cab		b5 ad						lda $ad,x				      LDA   FAC1_1,X          ; get byte from FAC1
3462		.8cad		95 11						sta $11,x				      STA   nums_1,X          ; save byte to temp
3463		.8caf		ca							dex							      DEX                     ; decrement index
3464		.8cb0		10 f9						bpl $8cab				      BPL   LAB_CFAC          ; copy FAC1 mantissa to temp
3466		.8cb2		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; get next BASIC byte
3467		.8cb5		a2 00						ldx #$00				      LDX   #$00              ; set default to no leading "0"s
3468		.8cb7		c9 29						cmp #$29				      CMP   #')'              ; compare with close bracket
3469		.8cb9		f0 0a						beq $8cc5				      BEQ   LAB_1C54          ; if ")" go do rest of function
3471		.8cbb		20 eb 94				jsr $94eb				      JSR   LAB_SCGB          ; scan for "," and get byte
3472		.8cbe		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; get last byte back
3473		.8cc1		c9 29						cmp #$29				      CMP   #')'              ; is next character )
3474		.8cc3		d0 01						bne $8cc6				      BNE   LAB_BHER          ; if not ")" go do error
3476		.8cc5																		LAB_1C54
3477		.8cc5		60							rts							      RTS                     ; else do function
3479		.8cc6																		LAB_BHER
3480		.8cc6		4c 37 8f				jmp $8f37				      JMP   LAB_FCER          ; do function call error then warm start
3489		.8cc9																		LAB_EOR
3490		.8cc9		20 f0 8c				jsr $8cf0				      JSR   GetFirst          ; get first integer expression (no sign check)
3491		.8ccc		45 5b						eor $5b					      EOR   XOAw_l            ; EOR with expression 1 low byte
3492		.8cce		a8							tay							      TAY                     ; save in Y
3493		.8ccf		a5 ae						lda $ae					      LDA   FAC1_2            ; get FAC1 mantissa2
3494		.8cd1		45 5c						eor $5c					      EOR   XOAw_h            ; EOR with expression 1 high byte
3495		.8cd3		4c 67 90				jmp $9067				      JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
3499		.8cd6																		LAB_OR
3500		.8cd6		20 f0 8c				jsr $8cf0				      JSR   GetFirst          ; get first integer expression (no sign check)
3501		.8cd9		05 5b						ora $5b					      ORA   XOAw_l            ; OR with expression 1 low byte
3502		.8cdb		a8							tay							      TAY                     ; save in Y
3503		.8cdc		a5 ae						lda $ae					      LDA   FAC1_2            ; get FAC1 mantissa2
3504		.8cde		05 5c						ora $5c					      ORA   XOAw_h            ; OR with expression 1 high byte
3505		.8ce0		4c 67 90				jmp $9067				      JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
3509		.8ce3																		LAB_AND
3510		.8ce3		20 f0 8c				jsr $8cf0				      JSR   GetFirst          ; get first integer expression (no sign check)
3511		.8ce6		25 5b						and $5b					      AND   XOAw_l            ; AND with expression 1 low byte
3512		.8ce8		a8							tay							      TAY                     ; save in Y
3513		.8ce9		a5 ae						lda $ae					      LDA   FAC1_2            ; get FAC1 mantissa2
3514		.8ceb		25 5c						and $5c					      AND   XOAw_h            ; AND with expression 1 high byte
3515		.8ced		4c 67 90				jmp $9067				      JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
3519		.8cf0																		GetFirst
3520		.8cf0		20 b4 8e				jsr $8eb4				      JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
3521		.8cf3		a5 ae						lda $ae					      LDA   FAC1_2            ; get FAC1 mantissa2
3522		.8cf5		85 5c						sta $5c					      STA   XOAw_h            ; save it
3523		.8cf7		a5 af						lda $af					      LDA   FAC1_3            ; get FAC1 mantissa3
3524		.8cf9		85 5b						sta $5b					      STA   XOAw_l            ; save it
3525		.8cfb		20 d0 95				jsr $95d0				      JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
3526		.8cfe		20 b4 8e				jsr $8eb4				      JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
3527		.8d01		a5 af						lda $af					      LDA   FAC1_3            ; get FAC1 mantissa3
3528		.8d03																		LAB_1C95
3529		.8d03		60							rts							      RTS
3535		.8d04																		LAB_LTHAN
3536		.8d04		20 d3 8a				jsr $8ad3				      JSR   LAB_CKTM          ; type match check, set C for string
3537		.8d07		b0 13						bcs $8d1c				      BCS   LAB_1CAE          ; branch if string
3540		.8d09		a5 b7						lda $b7					      LDA   FAC2_s            ; get FAC2 sign (b7)
3541		.8d0b		09 7f						ora #$7f				      ORA   #$7F              ; set all non sign bits
3542		.8d0d		25 b4						and $b4					      AND   FAC2_1            ; and FAC2 mantissa1 (AND in sign bit)
3543		.8d0f		85 b4						sta $b4					      STA   FAC2_1            ; save FAC2 mantissa1
3544		.8d11		a9 b3						lda #$b3				      LDA   #<FAC2_e          ; set pointer low byte to FAC2
3545		.8d13		a0 00						ldy #$00				      LDY   #>FAC2_e          ; set pointer high byte to FAC2
3546		.8d15		20 24 99				jsr $9924				      JSR   LAB_27F8          ; compare FAC1 with FAC2 (AY)
3547		.8d18		aa							tax							      TAX                     ; copy result
3548		.8d19		4c 4d 8d				jmp $8d4d				      JMP   LAB_1CE1          ; go evaluate result
3551		.8d1c																		LAB_1CAE
3552		.8d1c		46 5f						lsr $5f					      LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
3553		.8d1e		c6 9b						dec $9b					      DEC   comp_f            ; clear < bit in compare function flag
3554		.8d20		20 52 93				jsr $9352				      JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
3557		.8d23		85 ac						sta $ac					      STA   str_ln            ; save length
3558		.8d25		86 ad						stx $ad					      STX   str_pl            ; save string pointer low byte
3559		.8d27		84 ae						sty $ae					      STY   str_ph            ; save string pointer high byte
3560		.8d29		a5 b5						lda $b5					      LDA   FAC2_2            ; get descriptor pointer low byte
3561		.8d2b		a4 b6						ldy $b6					      LDY   FAC2_3            ; get descriptor pointer high byte
3562		.8d2d		20 56 93				jsr $9356				      JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
3565		.8d30		86 b5						stx $b5					      STX   FAC2_2            ; save string pointer low byte
3566		.8d32		84 b6						sty $b6					      STY   FAC2_3            ; save string pointer high byte
3567		.8d34		aa							tax							      TAX                     ; copy length
3568		.8d35		38							sec							      SEC                     ; set carry for subtract
3569		.8d36		e5 ac						sbc $ac					      SBC   str_ln            ; subtract string 1 length
3570		.8d38		f0 08						beq $8d42				      BEQ   LAB_1CD6          ; branch if str 1 length = string 2 length
3572		.8d3a		a9 01						lda #$01				      LDA   #$01              ; set str 1 length > string 2 length
3573		.8d3c		90 04						bcc $8d42				      BCC   LAB_1CD6          ; branch if so
3575		.8d3e		a6 ac						ldx $ac					      LDX   str_ln            ; get string 1 length
3576		.8d40		a9 ff						lda #$ff				      LDA   #$FF              ; set str 1 length < string 2 length
3577		.8d42																		LAB_1CD6
3578		.8d42		85 b0						sta $b0					      STA   FAC1_s            ; save length compare
3579		.8d44		a0 ff						ldy #$ff				      LDY   #$FF              ; set index
3580		.8d46		e8							inx							      INX                     ; adjust for loop
3581		.8d47																		LAB_1CDB
3582		.8d47		c8							iny							      INY                     ; increment index
3583		.8d48		ca							dex							      DEX                     ; decrement count
3584		.8d49		d0 07						bne $8d52				      BNE   LAB_1CE6          ; branch if still bytes to do
3586		.8d4b		a6 b0						ldx $b0					      LDX   FAC1_s            ; get length compare back
3587		.8d4d																		LAB_1CE1
3588		.8d4d		30 0f						bmi $8d5e				      BMI   LAB_1CF2          ; branch if str 1 < str 2
3590		.8d4f		18							clc							      CLC                     ; flag str 1 <= str 2
3591		.8d50		90 0c						bcc $8d5e				      BCC   LAB_1CF2          ; go evaluate result
3593		.8d52																		LAB_1CE6
3594		.8d52		b1 b5						lda ($b5),y			      LDA   (FAC2_2),Y        ; get string 2 byte
3595		.8d54		d1 ad						cmp ($ad),y			      CMP   (FAC1_1),Y        ; compare with string 1 byte
3596		.8d56		f0 ef						beq $8d47				      BEQ   LAB_1CDB          ; loop if bytes =
3598		.8d58		a2 ff						ldx #$ff				      LDX   #$FF              ; set str 1 < string 2
3599		.8d5a		b0 02						bcs $8d5e				      BCS   LAB_1CF2          ; branch if so
3601		.8d5c		a2 01						ldx #$01				      LDX   #$01              ;  set str 1 > string 2
3602		.8d5e																		LAB_1CF2
3603		.8d5e		e8							inx							      INX                     ; x = 0, 1 or 2
3604		.8d5f		8a							txa							      TXA                     ; copy to A
3605		.8d60		2a							rol a						      ROL                     ; *2 (1, 2 or 4)
3606		.8d61		25 63						and $63					      AND   Cflag             ; AND with comparison evaluation flag
3607		.8d63		f0 02						beq $8d67				      BEQ   LAB_1CFB          ; branch if 0 (compare is false)
3609		.8d65		a9 ff						lda #$ff				      LDA   #$FF              ; else set result true
3610		.8d67																		LAB_1CFB
3611		.8d67		4c 07 99				jmp $9907				      JMP   LAB_27DB          ; save A as integer byte and return
3613		.8d6a																		LAB_1CFE
3614		.8d6a		20 fe 8b				jsr $8bfe				      JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
3618		.8d6d																		LAB_DIM
3619		.8d6d		aa							tax							      TAX                     ; copy "DIM" flag to X
3620		.8d6e		20 bd 8d				jsr $8dbd				      JSR   LAB_1D10          ; search for variable
3621		.8d71		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; scan memory
3622		.8d74		d0 f4						bne $8d6a				      BNE   LAB_1CFE          ; scan for "," and loop if not null
3624		.8d76		60							rts							      RTS
3628		.8d77																		LAB_LSHIFT
3629		.8d77		20 ad 8d				jsr $8dad				      JSR   GetPair           ; get integer expression and byte (no sign check)
3630		.8d7a		a5 ae						lda $ae					      LDA   FAC1_2            ; get expression high byte
3631		.8d7c		a6 78						ldx $78					      LDX   TempB             ; get shift count
3632		.8d7e		f0 22						beq $8da2				      BEQ   NoShift           ; branch if zero
3634		.8d80		e0 10						cpx #$10				      CPX   #$10              ; compare bit count with 16d
3635		.8d82		b0 23						bcs $8da7				      BCS   TooBig            ; branch if >=
3637		.8d84																		Ls_loop
3638		.8d84		06 af						asl $af					      ASL   FAC1_3            ; shift low byte
3639		.8d86		2a							rol a						      ROL                     ; shift high byte
3640		.8d87		ca							dex							      DEX                     ; decrement bit count
3641		.8d88		d0 fa						bne $8d84				      BNE   Ls_loop           ; loop if shift not complete
3643		.8d8a		a4 af						ldy $af					      LDY   FAC1_3            ; get expression low byte
3644		.8d8c		4c 67 90				jmp $9067				      JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
3648		.8d8f																		LAB_RSHIFT
3649		.8d8f		20 ad 8d				jsr $8dad				      JSR   GetPair           ; get integer expression and byte (no sign check)
3650		.8d92		a5 ae						lda $ae					      LDA   FAC1_2            ; get expression high byte
3651		.8d94		a6 78						ldx $78					      LDX   TempB             ; get shift count
3652		.8d96		f0 0a						beq $8da2				      BEQ   NoShift           ; branch if zero
3654		.8d98		e0 10						cpx #$10				      CPX   #$10              ; compare bit count with 16d
3655		.8d9a		b0 0b						bcs $8da7				      BCS   TooBig            ; branch if >=
3657		.8d9c																		Rs_loop
3658		.8d9c		4a							lsr a						      LSR                     ; shift high byte
3659		.8d9d		66 af						ror $af					      ROR   FAC1_3            ; shift low byte
3660		.8d9f		ca							dex							      DEX                     ; decrement bit count
3661		.8da0		d0 fa						bne $8d9c				      BNE   Rs_loop           ; loop if shift not complete
3663		.8da2																		NoShift
3664		.8da2		a4 af						ldy $af					      LDY   FAC1_3            ; get expression low byte
3665		.8da4		4c 67 90				jmp $9067				      JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
3667		.8da7																		TooBig
3668		.8da7		a9 00						lda #$00				      LDA   #$00              ; clear high byte
3669		.8da9		a8							tay							      TAY                     ; copy to low byte
3670		.8daa		4c 67 90				jmp $9067				      JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
3672		.8dad																		GetPair
3673		.8dad		20 a3 94				jsr $94a3				      JSR   LAB_EVBY          ; evaluate byte expression, result in X
3674		.8db0		86 78						stx $78					      STX   TempB             ; save it
3675		.8db2		20 d0 95				jsr $95d0				      JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
3676		.8db5		4c b4 8e				jmp $8eb4				      JMP   LAB_EVIR          ; evaluate integer expression (no sign check)
3682		.8db8																		LAB_GVAR
3683		.8db8		a2 00						ldx #$00				      LDX   #$00              ; set DIM flag = $00
3684		.8dba		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; scan memory (1st character)
3685		.8dbd																		LAB_1D10
3686		.8dbd		86 5e						stx $5e					      STX   Defdim            ; save DIM flag
3687		.8dbf																		LAB_1D12
3688		.8dbf		85 93						sta $93					      STA   Varnm1            ; save 1st character
3689		.8dc1		29 7f						and #$7f				      AND   #$7F              ; clear FN flag bit
3690		.8dc3		20 2c 8e				jsr $8e2c				      JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
3691		.8dc6		b0 03						bcs $8dcb				      BCS   LAB_1D1F          ; branch if ok
3693		.8dc8		4c 02 8c				jmp $8c02				      JMP   LAB_SNER          ; else syntax error then warm start
3696		.8dcb																		LAB_1D1F
3697		.8dcb		a2 00						ldx #$00				      LDX   #$00              ; clear 2nd character temp
3698		.8dcd		86 5f						stx $5f					      STX   Dtypef            ; clear data type flag, $FF=string, $00=numeric
3699		.8dcf		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment and scan memory (2nd character)
3700		.8dd2		90 05						bcc $8dd9				      BCC   LAB_1D2D          ; branch if character = "0"-"9" (ok)
3703		.8dd4		20 2c 8e				jsr $8e2c				      JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
3704		.8dd7		90 0b						bcc $8de4				      BCC   LAB_1D38          ; branch if <"A" or >"Z" (go check if string)
3706		.8dd9																		LAB_1D2D
3707		.8dd9		aa							tax							      TAX                     ; copy 2nd character
3710		.8dda																		LAB_1D2E
3711		.8dda		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment and scan memory (3rd character)
3712		.8ddd		90 fb						bcc $8dda				      BCC   LAB_1D2E          ; loop if character = "0"-"9" (ignore)
3714		.8ddf		20 2c 8e				jsr $8e2c				      JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
3715		.8de2		b0 f6						bcs $8dda				      BCS   LAB_1D2E          ; loop if character = "A"-"Z" (ignore)
3718		.8de4																		LAB_1D38
3719		.8de4		c9 24						cmp #$24				      CMP   #'$'              ; compare with "$"
3720		.8de6		d0 0b						bne $8df3				      BNE   LAB_1D47          ; branch if not string
3726		.8de8		a9 ff						lda #$ff				      LDA   #$FF              ; set data type = string
3727		.8dea		85 5f						sta $5f					      STA   Dtypef            ; set data type flag, $FF=string, $00=numeric
3728		.8dec		8a							txa							      TXA                     ; get 2nd character back
3729		.8ded		09 80						ora #$80				      ORA   #$80              ; set top bit (indicate string var)
3730		.8def		aa							tax							      TAX                     ; copy back to 2nd character temp
3731		.8df0		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment and scan memory
3737		.8df3																		LAB_1D47
3738		.8df3		86 94						stx $94					      STX   Varnm2            ; save 2nd character
3739		.8df5		05 61						ora $61					      ORA   Sufnxf            ; or with subscript/FNX flag (or FN name)
3740		.8df7		c9 28						cmp #$28				      CMP   #'('              ; compare with "("
3741		.8df9		d0 03						bne $8dfe				      BNE   LAB_1D53          ; branch if not "("
3743		.8dfb		4c c6 8e				jmp $8ec6				      JMP   LAB_1E17          ; go find, or make, array
3749		.8dfe																		LAB_1D53
3750		.8dfe		a9 00						lda #$00				      LDA   #$00              ; clear A
3751		.8e00		85 61						sta $61					      STA   Sufnxf            ; clear subscript/FNX flag
3752		.8e02		a5 7b						lda $7b					      LDA   Svarl             ; get start of vars low byte
3753		.8e04		a6 7c						ldx $7c					      LDX   Svarh             ; get start of vars high byte
3754		.8e06		a0 00						ldy #$00				      LDY   #$00              ; clear index
3755		.8e08																		LAB_1D5D
3756		.8e08		86 ab						stx $ab					      STX   Vrschh            ; save search address high byte
3757		.8e0a																		LAB_1D5F
3758		.8e0a		85 aa						sta $aa					      STA   Vrschl            ; save search address low byte
3759		.8e0c		e4 7e						cpx $7e					      CPX   Sarryh            ; compare high address with var space end
3760		.8e0e		d0 04						bne $8e14				      BNE   LAB_1D69          ; skip next compare if <>
3763		.8e10		c5 7d						cmp $7d					      CMP   Sarryl            ; compare low address with var space end
3764		.8e12		f0 2c						beq $8e40				      BEQ   LAB_1D8B          ; if not found go make new var
3766		.8e14																		LAB_1D69
3767		.8e14		a5 93						lda $93					      LDA   Varnm1            ; get 1st character of var to find
3768		.8e16		d1 aa						cmp ($aa),y			      CMP   (Vrschl),Y        ; compare with variable name 1st character
3769		.8e18		d0 08						bne $8e22				      BNE   LAB_1D77          ; branch if no match
3772		.8e1a		a5 94						lda $94					      LDA   Varnm2            ; get 2nd character of var to find
3773		.8e1c		c8							iny							      INY                     ; index to point to variable name 2nd character
3774		.8e1d		d1 aa						cmp ($aa),y			      CMP   (Vrschl),Y        ; compare with variable name 2nd character
3775		.8e1f		f0 69						beq $8e8a				      BEQ   LAB_1DD7          ; branch if match (found var)
3777		.8e21		88							dey							      DEY                     ; else decrement index (now = $00)
3778		.8e22																		LAB_1D77
3779		.8e22		18							clc							      CLC                     ; clear carry for add
3780		.8e23		a5 aa						lda $aa					      LDA   Vrschl            ; get search address low byte
3781		.8e25		69 06						adc #$06				      ADC   #$06              ; +6 (offset to next var name)
3782		.8e27		90 e1						bcc $8e0a				      BCC   LAB_1D5F          ; loop if no overflow to high byte
3784		.8e29		e8							inx							      INX                     ; else increment high byte
3785		.8e2a		d0 dc						bne $8e08				      BNE   LAB_1D5D          ; loop always (RAM doesn't extend to $FFFF !)
3789		.8e2c																		LAB_CASC
3790		.8e2c		c9 61						cmp #$61				      CMP   #'a'              ; compare with "a"
3791		.8e2e		b0 0a						bcs $8e3a				      BCS   LAB_1D83          ; go check <"z"+1
3795		.8e30																		LAB_1D82
3796		.8e30		c9 41						cmp #$41				      CMP   #'A'              ; compare with "A"
3797		.8e32		90 05						bcc $8e39				      BCC   LAB_1D8A          ; exit if less
3800		.8e34		e9 5b						sbc #$5b				      SBC   #$5B              ; subtract "Z"+1
3801		.8e36		38							sec							      SEC                     ; set carry
3802		.8e37		e9 a5						sbc #$a5				      SBC   #$A5              ; subtract $A5 (restore byte)
3804		.8e39																		LAB_1D8A
3805		.8e39		60							rts							      RTS
3807		.8e3a																		LAB_1D83
3808		.8e3a		e9 7b						sbc #$7b				      SBC   #$7B              ; subtract "z"+1
3809		.8e3c		38							sec							      SEC                     ; set carry
3810		.8e3d		e9 85						sbc #$85				      SBC   #$85              ; subtract $85 (restore byte)
3812		.8e3f		60							rts							      RTS
3816		.8e40																		LAB_1D8B
3817		.8e40		68							pla							      PLA                     ; pop return address low byte
3818		.8e41		48							pha							      PHA                     ; push return address low byte
3819		=$8c49																	LAB_1C18p2  = LAB_1C18+2
3820		.8e42		c9 49						cmp #$49				      CMP   #<LAB_1C18p2      ; compare with expected calling routine return low byte
3821		.8e44		d0 05						bne $8e4b				      BNE   LAB_1D98          ; if not get (var) go create new var
3842		.8e46		a9 f2						lda #$f2				      LDA   #<LAB_1D96        ; low byte point to $00,$00
3844		.8e48		a0 a1						ldy #$a1				      LDY   #>LAB_1D96        ; high byte point to $00,$00
3845		.8e4a		60							rts							      RTS
3848		.8e4b																		LAB_1D98
3849		.8e4b		a5 7d						lda $7d					      LDA   Sarryl            ; get var mem end low byte
3850		.8e4d		a4 7e						ldy $7e					      LDY   Sarryh            ; get var mem end high byte
3851		.8e4f		85 aa						sta $aa					      STA   Ostrtl            ; save old block start low byte
3852		.8e51		84 ab						sty $ab					      STY   Ostrth            ; save old block start high byte
3853		.8e53		a5 7f						lda $7f					      LDA   Earryl            ; get array mem end low byte
3854		.8e55		a4 80						ldy $80					      LDY   Earryh            ; get array mem end high byte
3855		.8e57		85 a6						sta $a6					      STA   Obendl            ; save old block end low byte
3856		.8e59		84 a7						sty $a7					      STY   Obendh            ; save old block end high byte
3857		.8e5b		18							clc							      CLC                     ; clear carry for add
3858		.8e5c		69 06						adc #$06				      ADC   #$06              ; +6 (space for one var)
3859		.8e5e		90 01						bcc $8e61				      BCC   LAB_1DAE          ; branch if no overflow to high byte
3861		.8e60		c8							iny							      INY                     ; else increment high byte
3862		.8e61																		LAB_1DAE
3863		.8e61		85 a4						sta $a4					      STA   Nbendl            ; set new block end low byte
3864		.8e63		84 a5						sty $a5					      STY   Nbendh            ; set new block end high byte
3865		.8e65		20 c1 80				jsr $80c1				      JSR   LAB_11CF          ; open up space in memory
3866		.8e68		a5 a4						lda $a4					      LDA   Nbendl            ; get new start low byte
3867		.8e6a		a4 a5						ldy $a5					      LDY   Nbendh            ; get new start high byte (-$100)
3868		.8e6c		c8							iny							      INY                     ; correct high byte
3869		.8e6d		85 7d						sta $7d					      STA   Sarryl            ; save new var mem end low byte
3870		.8e6f		84 7e						sty $7e					      STY   Sarryh            ; save new var mem end high byte
3871		.8e71		a0 00						ldy #$00				      LDY   #$00              ; clear index
3872		.8e73		a5 93						lda $93					      LDA   Varnm1            ; get var name 1st character
3873		.8e75		91 aa						sta ($aa),y			      STA   (Vrschl),Y        ; save var name 1st character
3874		.8e77		c8							iny							      INY                     ; increment index
3875		.8e78		a5 94						lda $94					      LDA   Varnm2            ; get var name 2nd character
3876		.8e7a		91 aa						sta ($aa),y			      STA   (Vrschl),Y        ; save var name 2nd character
3877		.8e7c		a9 00						lda #$00				      LDA   #$00              ; clear A
3878		.8e7e		c8							iny							      INY                     ; increment index
3879		.8e7f		91 aa						sta ($aa),y			      STA   (Vrschl),Y        ; initialise var byte
3880		.8e81		c8							iny							      INY                     ; increment index
3881		.8e82		91 aa						sta ($aa),y			      STA   (Vrschl),Y        ; initialise var byte
3882		.8e84		c8							iny							      INY                     ; increment index
3883		.8e85		91 aa						sta ($aa),y			      STA   (Vrschl),Y        ; initialise var byte
3884		.8e87		c8							iny							      INY                     ; increment index
3885		.8e88		91 aa						sta ($aa),y			      STA   (Vrschl),Y        ; initialise var byte
3888		.8e8a																		LAB_1DD7
3889		.8e8a		a5 aa						lda $aa					      LDA   Vrschl            ; get var address low byte
3890		.8e8c		18							clc							      CLC                     ; clear carry for add
3891		.8e8d		69 02						adc #$02				      ADC   #$02              ; +2 (offset past var name bytes)
3892		.8e8f		a4 ab						ldy $ab					      LDY   Vrschh            ; get var address high byte
3893		.8e91		90 01						bcc $8e94				      BCC   LAB_1DE1          ; branch if no overflow from add
3895		.8e93		c8							iny							      INY                     ; else increment high byte
3896		.8e94																		LAB_1DE1
3897		.8e94		85 95						sta $95					      STA   Cvaral            ; save current var address low byte
3898		.8e96		84 96						sty $96					      STY   Cvarah            ; save current var address high byte
3899		.8e98		60							rts							      RTS
3904		.8e99																		LAB_1DE6
3905		.8e99		a5 5d						lda $5d					      LDA   Dimcnt            ; get # of dimensions (1, 2 or 3)
3906		.8e9b		0a							asl a						      ASL                     ; *2 (also clears the carry !)
3907		.8e9c		69 05						adc #$05				      ADC   #$05              ; +5 (result is 7, 9 or 11 here)
3908		.8e9e		65 aa						adc $aa					      ADC   Astrtl            ; add array start pointer low byte
3909		.8ea0		a4 ab						ldy $ab					      LDY   Astrth            ; get array pointer high byte
3910		.8ea2		90 01						bcc $8ea5				      BCC   LAB_1DF2          ; branch if no overflow
3912		.8ea4		c8							iny							      INY                     ; else increment high byte
3913		.8ea5																		LAB_1DF2
3914		.8ea5		85 a4						sta $a4					      STA   Adatal            ; save array data pointer low byte
3915		.8ea7		84 a5						sty $a5					      STY   Adatah            ; save array data pointer high byte
3916		.8ea9		60							rts							      RTS
3920		.8eaa																		LAB_EVIN
3921		.8eaa		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment and scan memory
3922		.8ead		20 cd 8a				jsr $8acd				      JSR   LAB_EVNM          ; evaluate expression and check is numeric,
3927		.8eb0																		LAB_EVPI
3928		.8eb0		a5 b0						lda $b0					      LDA   FAC1_s            ; get FAC1 sign (b7)
3929		.8eb2		30 0d						bmi $8ec1				      BMI   LAB_1E12          ; do function call error if -ve
3933		.8eb4																		LAB_EVIR
3934		.8eb4		a5 ac						lda $ac					      LDA   FAC1_e            ; get FAC1 exponent
3935		.8eb6		c9 90						cmp #$90				      CMP   #$90              ; compare with exponent = 2^16 (n>2^15)
3936		.8eb8		90 09						bcc $8ec3				      BCC   LAB_1E14          ; branch if n<2^16 (is ok)
3938		.8eba		a9 f9						lda #$f9				      LDA   #<LAB_1DF7        ; set pointer low byte to -32768
3939		.8ebc		a0 a1						ldy #$a1				      LDY   #>LAB_1DF7        ; set pointer high byte to -32768
3940		.8ebe		20 24 99				jsr $9924				      JSR   LAB_27F8          ; compare FAC1 with (AY)
3941		.8ec1																		LAB_1E12
3942		.8ec1		d0 74						bne $8f37				      BNE   LAB_FCER          ; if <> do function call error then warm start
3944		.8ec3																		LAB_1E14
3945		.8ec3		4c 5d 99				jmp $995d				      JMP   LAB_2831          ; convert FAC1 floating-to-fixed and return
3949		.8ec6																		LAB_1E17
3950		.8ec6		a5 5e						lda $5e					      LDA   Defdim            ; get DIM flag
3951		.8ec8		48							pha							      PHA                     ; push it
3952		.8ec9		a5 5f						lda $5f					      LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
3953		.8ecb		48							pha							      PHA                     ; push it
3954		.8ecc		a0 00						ldy #$00				      LDY   #$00              ; clear dimensions count
3958		.8ece																		LAB_1E1F
3959		.8ece		98							tya							      TYA                     ; copy dimensions count
3960		.8ecf		48							pha							      PHA                     ; save it
3961		.8ed0		a5 94						lda $94					      LDA   Varnm2            ; get array name 2nd byte
3962		.8ed2		48							pha							      PHA                     ; save it
3963		.8ed3		a5 93						lda $93					      LDA   Varnm1            ; get array name 1st byte
3964		.8ed5		48							pha							      PHA                     ; save it
3965		.8ed6		20 aa 8e				jsr $8eaa				      JSR   LAB_EVIN          ; evaluate integer expression
3966		.8ed9		68							pla							      PLA                     ; pull array name 1st byte
3967		.8eda		85 93						sta $93					      STA   Varnm1            ; restore array name 1st byte
3968		.8edc		68							pla							      PLA                     ; pull array name 2nd byte
3969		.8edd		85 94						sta $94					      STA   Varnm2            ; restore array name 2nd byte
3970		.8edf		68							pla							      PLA                     ; pull dimensions count
3971		.8ee0		a8							tay							      TAY                     ; restore it
3972		.8ee1		ba							tsx							      TSX                     ; copy stack pointer
3973		.8ee2		bd 02 01				lda $0102,x			      LDA   LAB_STAK+2,X      ; get DIM flag
3974		.8ee5		48							pha							      PHA                     ; push it
3975		.8ee6		bd 01 01				lda $0101,x			      LDA   LAB_STAK+1,X      ; get data type flag
3976		.8ee9		48							pha							      PHA                     ; push it
3977		.8eea		a5 ae						lda $ae					      LDA   FAC1_2            ; get this dimension size high byte
3978		.8eec		9d 02 01				sta $0102,x			      STA   LAB_STAK+2,X      ; stack before flag bytes
3979		.8eef		a5 af						lda $af					      LDA   FAC1_3            ; get this dimension size low byte
3980		.8ef1		9d 01 01				sta $0101,x			      STA   LAB_STAK+1,X      ; stack before flag bytes
3981		.8ef4		c8							iny							      INY                     ; increment dimensions count
3982		.8ef5		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; scan memory
3983		.8ef8		c9 2c						cmp #$2c				      CMP   #','              ; compare with ","
3984		.8efa		f0 d2						beq $8ece				      BEQ   LAB_1E1F          ; if found go do next dimension
3986		.8efc		84 5d						sty $5d					      STY   Dimcnt            ; store dimensions count
3987		.8efe		20 ef 8b				jsr $8bef				      JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
3988		.8f01		68							pla							      PLA                     ; pull data type flag
3989		.8f02		85 5f						sta $5f					      STA   Dtypef            ; restore data type flag, $FF=string, $00=numeric
3990		.8f04		68							pla							      PLA                     ; pull DIM flag
3991		.8f05		85 5e						sta $5e					      STA   Defdim            ; restore DIM flag
3992		.8f07		a6 7d						ldx $7d					      LDX   Sarryl            ; get array mem start low byte
3993		.8f09		a5 7e						lda $7e					      LDA   Sarryh            ; get array mem start high byte
3998		.8f0b																		LAB_1E5C
3999		.8f0b		86 aa						stx $aa					      STX   Astrtl            ; save as array start pointer low byte
4000		.8f0d		85 ab						sta $ab					      STA   Astrth            ; save as array start pointer high byte
4001		.8f0f		c5 80						cmp $80					      CMP   Earryh            ; compare with array mem end high byte
4002		.8f11		d0 04						bne $8f17				      BNE   LAB_1E68          ; branch if not reached array mem end
4004		.8f13		e4 7f						cpx $7f					      CPX   Earryl            ; else compare with array mem end low byte
4005		.8f15		f0 39						beq $8f50				      BEQ   LAB_1EA1          ; go build array if not found
4008		.8f17																		LAB_1E68
4009		.8f17		a0 00						ldy #$00				      LDY   #$00              ; clear index
4010		.8f19		b1 aa						lda ($aa),y			      LDA   (Astrtl),Y        ; get array name first byte
4011		.8f1b		c8							iny							      INY                     ; increment index to second name byte
4012		.8f1c		c5 93						cmp $93					      CMP   Varnm1            ; compare with this array name first byte
4013		.8f1e		d0 06						bne $8f26				      BNE   LAB_1E77          ; branch if no match
4015		.8f20		a5 94						lda $94					      LDA   Varnm2            ; else get this array name second byte
4016		.8f22		d1 aa						cmp ($aa),y			      CMP   (Astrtl),Y        ; compare with array name second byte
4017		.8f24		f0 16						beq $8f3c				      BEQ   LAB_1E8D          ; array found so branch
4020		.8f26																		LAB_1E77
4021		.8f26		c8							iny							      INY                     ; increment index
4022		.8f27		b1 aa						lda ($aa),y			      LDA   (Astrtl),Y        ; get array size low byte
4023		.8f29		18							clc							      CLC                     ; clear carry for add
4024		.8f2a		65 aa						adc $aa					      ADC   Astrtl            ; add array start pointer low byte
4025		.8f2c		aa							tax							      TAX                     ; copy low byte to X
4026		.8f2d		c8							iny							      INY                     ; increment index
4027		.8f2e		b1 aa						lda ($aa),y			      LDA   (Astrtl),Y        ; get array size high byte
4028		.8f30		65 ab						adc $ab					      ADC   Astrth            ; add array mem pointer high byte
4029		.8f32		90 d7						bcc $8f0b				      BCC   LAB_1E5C          ; if no overflow go check next array
4033		.8f34																		LAB_1E85
4034		.8f34		a2 10						ldx #$10				      LDX   #$10              ; error code $10 ("Array bounds" error)
4035		>8f36		2c															      .byte $2C               ; makes next bit BIT LAB_08A2
4039		.8f37																		LAB_FCER
4040		.8f37		a2 08						ldx #$08				      LDX   #$08              ; error code $08 ("Function call" error)
4041		.8f39																		LAB_1E8A
4042		.8f39		4c 3f 81				jmp $813f				      JMP   LAB_XERR          ; do error #X, then warm start
4045		.8f3c																		LAB_1E8D
4046		.8f3c		a2 12						ldx #$12				      LDX   #$12              ; set error $12 ("Double dimension" error)
4047		.8f3e		a5 5e						lda $5e					      LDA   Defdim            ; get DIM flag
4048		.8f40		d0 f7						bne $8f39				      BNE   LAB_1E8A          ; if we are trying to dimension it do error #X, then warm
4053		.8f42		20 99 8e				jsr $8e99				      JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
4055		.8f45		a5 5d						lda $5d					      LDA   Dimcnt            ; get dimensions count
4056		.8f47		a0 04						ldy #$04				      LDY   #$04              ; set index to array's # of dimensions
4057		.8f49		d1 aa						cmp ($aa),y			      CMP   (Astrtl),Y        ; compare with no of dimensions
4058		.8f4b		d0 e7						bne $8f34				      BNE   LAB_1E85          ; if wrong do array bounds error, could do "Wrong
4062		.8f4d		4c d3 8f				jmp $8fd3				      JMP   LAB_1F28          ; found array so go get element
4068		.8f50																		LAB_1EA1
4069		.8f50		20 99 8e				jsr $8e99				      JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
4071		.8f53		20 0e 81				jsr $810e				      JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
4073		.8f56		a0 00						ldy #$00				      LDY   #$00              ; clear Y (don't need to clear A)
4074		.8f58		84 bb						sty $bb					      STY   Aspth             ; clear array data size high byte
4075		.8f5a		a5 93						lda $93					      LDA   Varnm1            ; get variable name 1st byte
4076		.8f5c		91 aa						sta ($aa),y			      STA   (Astrtl),Y        ; save array name 1st byte
4077		.8f5e		c8							iny							      INY                     ; increment index
4078		.8f5f		a5 94						lda $94					      LDA   Varnm2            ; get variable name 2nd byte
4079		.8f61		91 aa						sta ($aa),y			      STA   (Astrtl),Y        ; save array name 2nd byte
4080		.8f63		a5 5d						lda $5d					      LDA   Dimcnt            ; get dimensions count
4081		.8f65		a0 04						ldy #$04				      LDY   #$04              ; index to dimension count
4082		.8f67		84 ba						sty $ba					      STY   Asptl             ; set array data size low byte (four bytes per element)
4083		.8f69		91 aa						sta ($aa),y			      STA   (Astrtl),Y        ; set array's dimensions count
4086		.8f6b		18							clc							      CLC                     ; clear carry for add (clear on subsequent loops)
4087		.8f6c																		LAB_1EC0
4088		.8f6c		a2 0b						ldx #$0b				      LDX   #$0B              ; set default dimension value low byte
4089		.8f6e		a9 00						lda #$00				      LDA   #$00              ; set default dimension value high byte
4090		.8f70		24 5e						bit $5e					      BIT   Defdim            ; test default DIM flag
4091		.8f72		50 07						bvc $8f7b				      BVC   LAB_1ED0          ; branch if b6 of Defdim is clear
4093		.8f74		68							pla							      PLA                     ; else pull dimension value low byte
4094		.8f75		69 01						adc #$01				      ADC   #$01              ; +1 (allow for zeroeth element)
4095		.8f77		aa							tax							      TAX                     ; copy low byte to X
4096		.8f78		68							pla							      PLA                     ; pull dimension value high byte
4097		.8f79		69 00						adc #$00				      ADC   #$00              ; add carry from low byte
4099		.8f7b																		LAB_1ED0
4100		.8f7b		c8							iny							      INY                     ; index to dimension value high byte
4101		.8f7c		91 aa						sta ($aa),y			      STA   (Astrtl),Y        ; save dimension value high byte
4102		.8f7e		c8							iny							      INY                     ; index to dimension value high byte
4103		.8f7f		8a							txa							      TXA                     ; get dimension value low byte
4104		.8f80		91 aa						sta ($aa),y			      STA   (Astrtl),Y        ; save dimension value low byte
4105		.8f82		20 22 90				jsr $9022				      JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
4106		.8f85		86 ba						stx $ba					      STX   Asptl             ; save array data size low byte
4107		.8f87		85 bb						sta $bb					      STA   Aspth             ; save array data size high byte
4108		.8f89		a4 71						ldy $71					      LDY   ut1_pl            ; restore index (saved by subroutine)
4109		.8f8b		c6 5d						dec $5d					      DEC   Dimcnt            ; decrement dimensions count
4110		.8f8d		d0 dd						bne $8f6c				      BNE   LAB_1EC0          ; loop while not = 0
4112		.8f8f		65 a5						adc $a5					      ADC   Adatah            ; add size high byte to first element high byte
4114		.8f91		b0 5d						bcs $8ff0				      BCS   LAB_1F45          ; if overflow go do "Out of memory" error
4116		.8f93		85 a5						sta $a5					      STA   Adatah            ; save end of array high byte
4117		.8f95		a8							tay							      TAY                     ; copy end high byte to Y
4118		.8f96		8a							txa							      TXA                     ; get array size low byte
4119		.8f97		65 a4						adc $a4					      ADC   Adatal            ; add array start low byte
4120		.8f99		90 03						bcc $8f9e				      BCC   LAB_1EF3          ; branch if no carry
4122		.8f9b		c8							iny							      INY                     ; else increment end of array high byte
4123		.8f9c		f0 52						beq $8ff0				      BEQ   LAB_1F45          ; if overflow go do "Out of memory" error
4126		.8f9e																		LAB_1EF3
4127		.8f9e		20 0e 81				jsr $810e				      JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
4129		.8fa1		85 7f						sta $7f					      STA   Earryl            ; save array mem end low byte
4130		.8fa3		84 80						sty $80					      STY   Earryh            ; save array mem end high byte
4131		.8fa5		a9 00						lda #$00				      LDA   #$00              ; clear byte for array clear
4132		.8fa7		e6 bb						inc $bb					      INC   Aspth             ; increment array size high byte (now block count)
4133		.8fa9		a4 ba						ldy $ba					      LDY   Asptl             ; get array size low byte (now index to block)
4134		.8fab		f0 05						beq $8fb2				      BEQ   LAB_1F07          ; branch if low byte = $00
4136		.8fad																		LAB_1F02
4137		.8fad		88							dey							      DEY                     ; decrement index (do 0 to n-1)
4138		.8fae		91 a4						sta ($a4),y			      STA   (Adatal),Y        ; zero byte
4139		.8fb0		d0 fb						bne $8fad				      BNE   LAB_1F02          ; loop until this block done
4141		.8fb2																		LAB_1F07
4142		.8fb2		c6 a5						dec $a5					      DEC   Adatah            ; decrement array pointer high byte
4143		.8fb4		c6 bb						dec $bb					      DEC   Aspth             ; decrement block count high byte
4144		.8fb6		d0 f5						bne $8fad				      BNE   LAB_1F02          ; loop until all blocks done
4146		.8fb8		e6 a5						inc $a5					      INC   Adatah            ; correct for last loop
4147		.8fba		38							sec							      SEC                     ; set carry for subtract
4148		.8fbb		a0 02						ldy #$02				      LDY   #$02              ; index to array size low byte
4149		.8fbd		a5 7f						lda $7f					      LDA   Earryl            ; get array mem end low byte
4150		.8fbf		e5 aa						sbc $aa					      SBC   Astrtl            ; subtract array start low byte
4151		.8fc1		91 aa						sta ($aa),y			      STA   (Astrtl),Y        ; save array size low byte
4152		.8fc3		c8							iny							      INY                     ; index to array size high byte
4153		.8fc4		a5 80						lda $80					      LDA   Earryh            ; get array mem end high byte
4154		.8fc6		e5 ab						sbc $ab					      SBC   Astrth            ; subtract array start high byte
4155		.8fc8		91 aa						sta ($aa),y			      STA   (Astrtl),Y        ; save array size high byte
4156		.8fca		a5 5e						lda $5e					      LDA   Defdim            ; get default DIM flag
4157		.8fcc		d0 53						bne $9021				      BNE   LAB_1F7B          ; exit (RET) if this was a DIM command
4160		.8fce		c8							iny							      INY                     ; index to # of dimensions
4162		.8fcf																		LAB_1F24
4163		.8fcf		b1 aa						lda ($aa),y			      LDA   (Astrtl),Y        ; get array's dimension count
4164		.8fd1		85 5d						sta $5d					      STA   Dimcnt            ; save it
4168		.8fd3																		LAB_1F28
4169		.8fd3		a9 00						lda #$00				      LDA   #$00              ; clear byte
4170		.8fd5		85 ba						sta $ba					      STA   Asptl             ; clear array data pointer low byte
4171		.8fd7																		LAB_1F2C
4172		.8fd7		85 bb						sta $bb					      STA   Aspth             ; save array data pointer high byte
4173		.8fd9		c8							iny							      INY                     ; increment index (point to array bound high byte)
4174		.8fda		68							pla							      PLA                     ; pull array index low byte
4175		.8fdb		aa							tax							      TAX                     ; copy to X
4176		.8fdc		85 ae						sta $ae					      STA   FAC1_2            ; save index low byte to FAC1 mantissa2
4177		.8fde		68							pla							      PLA                     ; pull array index high byte
4178		.8fdf		85 af						sta $af					      STA   FAC1_3            ; save index high byte to FAC1 mantissa3
4179		.8fe1		d1 aa						cmp ($aa),y			      CMP   (Astrtl),Y        ; compare with array bound high byte
4180		.8fe3		90 0e						bcc $8ff3				      BCC   LAB_1F48          ; branch if within bounds
4182		.8fe5		d0 06						bne $8fed				      BNE   LAB_1F42          ; if outside bounds do array bounds error
4185		.8fe7		c8							iny							      INY                     ; index to array bound low byte
4186		.8fe8		8a							txa							      TXA                     ; get array index low byte
4187		.8fe9		d1 aa						cmp ($aa),y			      CMP   (Astrtl),Y        ; compare with array bound low byte
4188		.8feb		90 07						bcc $8ff4				      BCC   LAB_1F49          ; branch if within bounds
4190		.8fed																		LAB_1F42
4191		.8fed		4c 34 8f				jmp $8f34				      JMP   LAB_1E85          ; else do array bounds error
4193		.8ff0																		LAB_1F45
4194		.8ff0		4c 3d 81				jmp $813d				      JMP   LAB_OMER          ; do "Out of memory" error then warm start
4196		.8ff3																		LAB_1F48
4197		.8ff3		c8							iny							      INY                     ; index to array bound low byte
4198		.8ff4																		LAB_1F49
4199		.8ff4		a5 bb						lda $bb					      LDA   Aspth             ; get array data pointer high byte
4200		.8ff6		05 ba						ora $ba					      ORA   Asptl             ; OR with array data pointer low byte
4201		.8ff8		f0 0a						beq $9004				      BEQ   LAB_1F5A          ; branch if array data pointer = null (skip multiply)
4203		.8ffa		20 22 90				jsr $9022				      JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
4204		.8ffd		8a							txa							      TXA                     ; get result low byte
4205		.8ffe		65 ae						adc $ae					      ADC   FAC1_2            ; add index low byte from FAC1 mantissa2
4206		.9000		aa							tax							      TAX                     ; save result low byte
4207		.9001		98							tya							      TYA                     ; get result high byte
4208		.9002		a4 71						ldy $71					      LDY   ut1_pl            ; restore index
4209		.9004																		LAB_1F5A
4210		.9004		65 af						adc $af					      ADC   FAC1_3            ; add index high byte from FAC1 mantissa3
4211		.9006		86 ba						stx $ba					      STX   Asptl             ; save array data pointer low byte
4212		.9008		c6 5d						dec $5d					      DEC   Dimcnt            ; decrement dimensions count
4213		.900a		d0 cb						bne $8fd7				      BNE   LAB_1F2C          ; loop if dimensions still to do
4215		.900c		06 ba						asl $ba					      ASL   Asptl             ; array data pointer low byte * 2
4216		.900e		2a							rol a						      ROL                     ; array data pointer high byte * 2
4217		.900f		06 ba						asl $ba					      ASL   Asptl             ; array data pointer low byte * 4
4218		.9011		2a							rol a						      ROL                     ; array data pointer high byte * 4
4219		.9012		a8							tay							      TAY                     ; copy high byte
4220		.9013		a5 ba						lda $ba					      LDA   Asptl             ; get low byte
4221		.9015		65 a4						adc $a4					      ADC   Adatal            ; add array data start pointer low byte
4222		.9017		85 95						sta $95					      STA   Cvaral            ; save as current var address low byte
4223		.9019		98							tya							      TYA                     ; get high byte back
4224		.901a		65 a5						adc $a5					      ADC   Adatah            ; add array data start pointer high byte
4225		.901c		85 96						sta $96					      STA   Cvarah            ; save as current var address high byte
4226		.901e		a8							tay							      TAY                     ; copy high byte to Y
4227		.901f		a5 95						lda $95					      LDA   Cvaral            ; get current var address low byte
4228		.9021																		LAB_1F7B
4229		.9021		60							rts							      RTS
4233		.9022																		LAB_1F7C
4234		.9022		84 71						sty $71					      STY   ut1_pl            ; save index
4235		.9024		b1 aa						lda ($aa),y			      LDA   (Astrtl),Y        ; get dimension size low byte
4236		.9026		85 76						sta $76					      STA   dims_l            ; save dimension size low byte
4237		.9028		88							dey							      DEY                     ; decrement index
4238		.9029		b1 aa						lda ($aa),y			      LDA   (Astrtl),Y        ; get dimension size high byte
4239		.902b		85 77						sta $77					      STA   dims_h            ; save dimension size high byte
4241		.902d		a9 10						lda #$10				      LDA   #$10              ; count = $10 (16 bit multiply)
4242		.902f		85 a8						sta $a8					      STA   numbit            ; save bit count
4243		.9031		a2 00						ldx #$00				      LDX   #$00              ; clear result low byte
4244		.9033		a0 00						ldy #$00				      LDY   #$00              ; clear result high byte
4245		.9035																		LAB_1F8F
4246		.9035		8a							txa							      TXA                     ; get result low byte
4247		.9036		0a							asl a						      ASL                     ; *2
4248		.9037		aa							tax							      TAX                     ; save result low byte
4249		.9038		98							tya							      TYA                     ; get result high byte
4250		.9039		2a							rol a						      ROL                     ; *2
4251		.903a		a8							tay							      TAY                     ; save result high byte
4252		.903b		b0 b3						bcs $8ff0				      BCS   LAB_1F45          ; if overflow go do "Out of memory" error
4254		.903d		06 ba						asl $ba					      ASL   Asptl             ; shift multiplier low byte
4255		.903f		26 bb						rol $bb					      ROL   Aspth             ; shift multiplier high byte
4256		.9041		90 0b						bcc $904e				      BCC   LAB_1FA8          ; skip add if no carry
4258		.9043		18							clc							      CLC                     ; else clear carry for add
4259		.9044		8a							txa							      TXA                     ; get result low byte
4260		.9045		65 76						adc $76					      ADC   dims_l            ; add dimension size low byte
4261		.9047		aa							tax							      TAX                     ; save result low byte
4262		.9048		98							tya							      TYA                     ; get result high byte
4263		.9049		65 77						adc $77					      ADC   dims_h            ; add dimension size high byte
4264		.904b		a8							tay							      TAY                     ; save result high byte
4265		.904c		b0 a2						bcs $8ff0				      BCS   LAB_1F45          ; if overflow go do "Out of memory" error
4267		.904e																		LAB_1FA8
4268		.904e		c6 a8						dec $a8					      DEC   numbit            ; decrement bit count
4269		.9050		d0 e3						bne $9035				      BNE   LAB_1F8F          ; loop until all done
4271		.9052		60							rts							      RTS
4275		.9053																		LAB_FRE
4276		.9053		a5 5f						lda $5f					      LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
4277		.9055		10 03						bpl $905a				      BPL   LAB_1FB4          ; branch if numeric
4279		.9057		20 52 93				jsr $9352				      JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
4284		.905a																		LAB_1FB4
4285		.905a		20 ef 91				jsr $91ef				      JSR   LAB_GARB          ; go do garbage collection
4286		.905d		38							sec							      SEC                     ; set carry for subtract
4287		.905e		a5 81						lda $81					      LDA   Sstorl            ; get bottom of string space low byte
4288		.9060		e5 7f						sbc $7f					      SBC   Earryl            ; subtract array mem end low byte
4289		.9062		a8							tay							      TAY                     ; copy result to Y
4290		.9063		a5 82						lda $82					      LDA   Sstorh            ; get bottom of string space high byte
4291		.9065		e5 80						sbc $80					      SBC   Earryh            ; subtract array mem end high byte
4295		.9067																		LAB_AYFC
4296		.9067		46 5f						lsr $5f					      LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
4297		.9069		85 ad						sta $ad					      STA   FAC1_1            ; save FAC1 mantissa1
4298		.906b		84 ae						sty $ae					      STY   FAC1_2            ; save FAC1 mantissa2
4299		.906d		a2 90						ldx #$90				      LDX   #$90              ; set exponent=2^16 (integer)
4300		.906f		4c 0f 99				jmp $990f				      JMP   LAB_27E3          ; set exp=X, clear FAC1_3, normalise and return
4304		.9072																		LAB_POS
4305		.9072		a4 0e						ldy $0e					      LDY   TPos              ; get terminal position
4309		.9074																		LAB_1FD0
4310		.9074		a9 00						lda #$00				      LDA   #$00              ; clear high byte
4311		.9076		f0 ef						beq $9067				      BEQ   LAB_AYFC          ; always save and convert integer AY to FAC1 and return
4315		.9078																		LAB_CKRN
4316		.9078		a6 88						ldx $88					      LDX   Clineh            ; get current line high byte
4317		.907a		e8							inx							      INX                     ; increment it
4318		.907b		d0 a4						bne $9021				      BNE   LAB_1F7B          ; return if can continue not direct mode
4321		.907d																		LAB_1FD9
4322		.907d		a2 16						ldx #$16				      LDX   #$16              ; error code $16 ("Illegal direct" error)
4323		.907f																		LAB_1FDB
4324		.907f		4c 3f 81				jmp $813f				      JMP   LAB_XERR          ; go do error #X, then warm start
4328		.9082																		LAB_DEF
4329		.9082		20 b3 90				jsr $90b3				      JSR   LAB_200B          ; check FNx syntax
4330		.9085		85 9c						sta $9c					      STA   func_l            ; save function pointer low byte
4331		.9087		84 9d						sty $9d					      STY   func_h            ; save function pointer high byte
4332		.9089		20 78 90				jsr $9078				      JSR   LAB_CKRN          ; check not Direct (back here if ok)
4333		.908c		20 fa 8b				jsr $8bfa				      JSR   LAB_1BFE          ; scan for "(" , else do syntax error then warm start
4334		.908f		a9 80						lda #$80				      LDA   #$80              ; set flag for FNx
4335		.9091		85 61						sta $61					      STA   Sufnxf            ; save subscript/FNx flag
4336		.9093		20 b8 8d				jsr $8db8				      JSR   LAB_GVAR          ; get (var) address
4337		.9096		20 d0 8a				jsr $8ad0				      JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
4338		.9099		20 ef 8b				jsr $8bef				      JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
4339		.909c		a9 c1						lda #$c1				      LDA   #TK_EQUAL         ; get = token
4340		.909e		20 f1 8b				jsr $8bf1				      JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
4341		.90a1		a5 96						lda $96					      LDA   Cvarah            ; get current var address high byte
4342		.90a3		48							pha							      PHA                     ; push it
4343		.90a4		a5 95						lda $95					      LDA   Cvaral            ; get current var address low byte
4344		.90a6		48							pha							      PHA                     ; push it
4345		.90a7		a5 c4						lda $c4					      LDA   Bpntrh            ; get BASIC execute pointer high byte
4346		.90a9		48							pha							      PHA                     ; push it
4347		.90aa		a5 c3						lda $c3					      LDA   Bpntrl            ; get BASIC execute pointer low byte
4348		.90ac		48							pha							      PHA                     ; push it
4349		.90ad		20 8a 86				jsr $868a				      JSR   LAB_DATA          ; go perform DATA
4350		.90b0		4c 22 91				jmp $9122				      JMP   LAB_207A          ; put execute pointer and variable pointer into function
4355		.90b3																		LAB_200B
4356		.90b3		a9 ae						lda #$ae				      LDA   #TK_FN            ; get FN" token
4357		.90b5		20 f1 8b				jsr $8bf1				      JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
4359		.90b8		09 80						ora #$80				      ORA   #$80              ; set FN flag bit
4360		.90ba		85 61						sta $61					      STA   Sufnxf            ; save FN flag so array variable test fails
4361		.90bc		20 bf 8d				jsr $8dbf				      JSR   LAB_1D12          ; search for FN variable
4362		.90bf		4c d0 8a				jmp $8ad0				      JMP   LAB_CTNM          ; check if source is numeric and return, else do type
4366		.90c2																		LAB_201E
4367		.90c2		20 b3 90				jsr $90b3				      JSR   LAB_200B          ; check FNx syntax
4368		.90c5		48							pha							      PHA                     ; push function pointer low byte
4369		.90c6		98							tya							      TYA                     ; copy function pointer high byte
4370		.90c7		48							pha							      PHA                     ; push function pointer high byte
4371		.90c8		20 fa 8b				jsr $8bfa				      JSR   LAB_1BFE          ; scan for "(", else do syntax error then warm start
4372		.90cb		20 e1 8a				jsr $8ae1				      JSR   LAB_EVEX          ; evaluate expression
4373		.90ce		20 ef 8b				jsr $8bef				      JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
4374		.90d1		20 d0 8a				jsr $8ad0				      JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
4375		.90d4		68							pla							      PLA                     ; pop function pointer high byte
4376		.90d5		85 9d						sta $9d					      STA   func_h            ; restore it
4377		.90d7		68							pla							      PLA                     ; pop function pointer low byte
4378		.90d8		85 9c						sta $9c					      STA   func_l            ; restore it
4379		.90da		a2 20						ldx #$20				      LDX   #$20              ; error code $20 ("Undefined function" error)
4380		.90dc		a0 03						ldy #$03				      LDY   #$03              ; index to variable pointer high byte
4381		.90de		b1 9c						lda ($9c),y			      LDA   (func_l),Y        ; get variable pointer high byte
4382		.90e0		f0 9d						beq $907f				      BEQ   LAB_1FDB          ; if zero go do undefined function error
4384		.90e2		85 96						sta $96					      STA   Cvarah            ; save variable address high byte
4385		.90e4		88							dey							      DEY                     ; index to variable address low byte
4386		.90e5		b1 9c						lda ($9c),y			      LDA   (func_l),Y        ; get variable address low byte
4387		.90e7		85 95						sta $95					      STA   Cvaral            ; save variable address low byte
4388		.90e9		aa							tax							      TAX                     ; copy address low byte
4391		.90ea		c8							iny							      INY                     ; index to mantissa_3
4392		.90eb																		LAB_2043
4393		.90eb		b1 95						lda ($95),y			      LDA   (Cvaral),Y        ; get byte from variable
4394		.90ed		48							pha							      PHA                     ; stack it
4395		.90ee		88							dey							      DEY                     ; decrement index
4396		.90ef		10 fa						bpl $90eb				      BPL   LAB_2043          ; loop until variable stacked
4398		.90f1		a4 96						ldy $96					      LDY   Cvarah            ; get variable address high byte
4399		.90f3		20 b4 98				jsr $98b4				      JSR   LAB_2778          ; pack FAC1 (function expression value) into (XY)
4401		.90f6		a5 c4						lda $c4					      LDA   Bpntrh            ; get BASIC execute pointer high byte
4402		.90f8		48							pha							      PHA                     ; push it
4403		.90f9		a5 c3						lda $c3					      LDA   Bpntrl            ; get BASIC execute pointer low byte
4404		.90fb		48							pha							      PHA                     ; push it
4405		.90fc		b1 9c						lda ($9c),y			      LDA   (func_l),Y        ; get function execute pointer low byte
4406		.90fe		85 c3						sta $c3					      STA   Bpntrl            ; save as BASIC execute pointer low byte
4407		.9100		c8							iny							      INY                     ; index to high byte
4408		.9101		b1 9c						lda ($9c),y			      LDA   (func_l),Y        ; get function execute pointer high byte
4409		.9103		85 c4						sta $c4					      STA   Bpntrh            ; save as BASIC execute pointer high byte
4410		.9105		a5 96						lda $96					      LDA   Cvarah            ; get variable address high byte
4411		.9107		48							pha							      PHA                     ; push it
4412		.9108		a5 95						lda $95					      LDA   Cvaral            ; get variable address low byte
4413		.910a		48							pha							      PHA                     ; push it
4414		.910b		20 cd 8a				jsr $8acd				      JSR   LAB_EVNM          ; evaluate expression and check is numeric,
4416		.910e		68							pla							      PLA                     ; pull variable address low byte
4417		.910f		85 9c						sta $9c					      STA   func_l            ; save variable address low byte
4418		.9111		68							pla							      PLA                     ; pull variable address high byte
4419		.9112		85 9d						sta $9d					      STA   func_h            ; save variable address high byte
4420		.9114		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; scan memory
4421		.9117		f0 03						beq $911c				      BEQ   LAB_2074          ; branch if null (should be [EOL] marker)
4423		.9119		4c 02 8c				jmp $8c02				      JMP   LAB_SNER          ; else syntax error then warm start
4427		.911c																		LAB_2074
4428		.911c		68							pla							      PLA                     ; pull BASIC execute pointer low byte
4429		.911d		85 c3						sta $c3					      STA   Bpntrl            ; restore BASIC execute pointer low byte
4430		.911f		68							pla							      PLA                     ; pull BASIC execute pointer high byte
4431		.9120		85 c4						sta $c4					      STA   Bpntrh            ; restore BASIC execute pointer high byte
4435		.9122																		LAB_207A
4436		.9122		a0 00						ldy #$00				      LDY   #$00              ; clear index
4437		.9124		68							pla							      PLA                     ; pull BASIC execute pointer low byte
4438		.9125		91 9c						sta ($9c),y			      STA   (func_l),Y        ; save to function
4439		.9127		c8							iny							      INY                     ; increment index
4440		.9128		68							pla							      PLA                     ; pull BASIC execute pointer high byte
4441		.9129		91 9c						sta ($9c),y			      STA   (func_l),Y        ; save to function
4442		.912b		c8							iny							      INY                     ; increment index
4443		.912c		68							pla							      PLA                     ; pull current var address low byte
4444		.912d		91 9c						sta ($9c),y			      STA   (func_l),Y        ; save to function
4445		.912f		c8							iny							      INY                     ; increment index
4446		.9130		68							pla							      PLA                     ; pull current var address high byte
4447		.9131		91 9c						sta ($9c),y			      STA   (func_l),Y        ; save to function
4448		.9133		60							rts							      RTS
4452		.9134																		LAB_STRS
4453		.9134		20 d0 8a				jsr $8ad0				      JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
4454		.9137		20 a2 9a				jsr $9aa2				      JSR   LAB_296E          ; convert FAC1 to string
4455		.913a		a9 f0						lda #$f0				      LDA   #<Decssp1         ; set result string low pointer
4456		.913c		a0 00						ldy #$00				      LDY   #>Decssp1         ; set result string high pointer
4457		.913e		f0 12						beq $9152				      BEQ   LAB_20AE          ; print null terminated string to Sutill/Sutilh
4462		.9140																		LAB_209C
4463		.9140		a6 ae						ldx $ae					      LDX   des_pl            ; get descriptor pointer low byte
4464		.9142		a4 af						ldy $af					      LDY   des_ph            ; get descriptor pointer high byte
4465		.9144		86 9e						stx $9e					      STX   des_2l            ; save descriptor pointer low byte
4466		.9146		84 9f						sty $9f					      STY   des_2h            ; save descriptor pointer high byte
4471		.9148																		LAB_MSSP
4472		.9148		20 bd 91				jsr $91bd				      JSR   LAB_2115          ; make space in string memory for string A long
4474		.914b		86 ad						stx $ad					      STX   str_pl            ; save string pointer low byte
4475		.914d		84 ae						sty $ae					      STY   str_ph            ; save string pointer high byte
4476		.914f		85 ac						sta $ac					      STA   str_ln            ; save length
4477		.9151		60							rts							      RTS
4482		.9152																		LAB_20AE
4483		.9152		a2 22						ldx #$22				      LDX   #$22              ; set terminator to "
4484		.9154		86 5b						stx $5b					      STX   Srchc             ; set search character (terminator 1)
4485		.9156		86 5c						stx $5c					      STX   Asrch             ; set terminator 2
4490		.9158																		LAB_20B4
4491		.9158		85 b8						sta $b8					      STA   ssptr_l           ; store string start low byte
4492		.915a		84 b9						sty $b9					      STY   ssptr_h           ; store string start high byte
4493		.915c		85 ad						sta $ad					      STA   str_pl            ; save string pointer low byte
4494		.915e		84 ae						sty $ae					      STY   str_ph            ; save string pointer high byte
4495		.9160		a0 ff						ldy #$ff				      LDY   #$FF              ; set length to -1
4496		.9162																		LAB_20BE
4497		.9162		c8							iny							      INY                     ; increment length
4498		.9163		b1 b8						lda ($b8),y			      LDA   (ssptr_l),Y       ; get byte from string
4499		.9165		f0 0c						beq $9173				      BEQ   LAB_20CF          ; exit loop if null byte [EOS]
4501		.9167		c5 5b						cmp $5b					      CMP   Srchc             ; compare with search character (terminator 1)
4502		.9169		f0 04						beq $916f				      BEQ   LAB_20CB          ; branch if terminator
4504		.916b		c5 5c						cmp $5c					      CMP   Asrch             ; compare with terminator 2
4505		.916d		d0 f3						bne $9162				      BNE   LAB_20BE          ; loop if not terminator 2
4507		.916f																		LAB_20CB
4508		.916f		c9 22						cmp #$22				      CMP   #$22              ; compare with "
4509		.9171		f0 01						beq $9174				      BEQ   LAB_20D0          ; branch if " (carry set if = !)
4511		.9173																		LAB_20CF
4512		.9173		18							clc							      CLC                     ; clear carry for add (only if [EOL] terminated string)
4513		.9174																		LAB_20D0
4514		.9174		84 ac						sty $ac					      STY   str_ln            ; save length in FAC1 exponent
4515		.9176		98							tya							      TYA                     ; copy length to A
4516		.9177		65 b8						adc $b8					      ADC   ssptr_l           ; add string start low byte
4517		.9179		85 ba						sta $ba					      STA   Sendl             ; save string end low byte
4518		.917b		a6 b9						ldx $b9					      LDX   ssptr_h           ; get string start high byte
4519		.917d		90 01						bcc $9180				      BCC   LAB_20DC          ; branch if no low byte overflow
4521		.917f		e8							inx							      INX                     ; else increment high byte
4522		.9180																		LAB_20DC
4523		.9180		86 bb						stx $bb					      STX   Sendh             ; save string end high byte
4524		.9182		a5 b9						lda $b9					      LDA   ssptr_h           ; get string start high byte
4530		.9184		f0 04						beq $918a				      BEQ   LAB_MVST          ; fix STR$() using page zero via LAB_296E
4531		.9186		c9 02						cmp #$02				      CMP   #>Ibuffs          ; compare with location of input buffer page
4532		.9188		d0 0b						bne $9195				      BNE   LAB_RTST          ; branch if not in utility area
4533		.918a																		LAB_MVST
4537		.918a		98							tya							      TYA                     ; copy length to A
4538		.918b		20 40 91				jsr $9140				      JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
4540		.918e		a6 b8						ldx $b8					      LDX   ssptr_l           ; get string start low byte
4541		.9190		a4 b9						ldy $b9					      LDY   ssptr_h           ; get string start high byte
4542		.9192		20 33 93				jsr $9333				      JSR   LAB_2298          ; store string A bytes long from XY to (Sutill)
4547		.9195																		LAB_RTST
4548		.9195		a6 65						ldx $65					      LDX   next_s            ; get string stack pointer
4549		.9197		e0 71						cpx #$71				      CPX   #des_sk+$09       ; compare with max+1
4550		.9199		d0 05						bne $91a0				      BNE   LAB_20F8          ; branch if space on string stack
4553		.919b		a2 1c						ldx #$1c				      LDX   #$1C              ; error code $1C ("String too complex" error)
4554		.919d																		LAB_20F5
4555		.919d		4c 3f 81				jmp $813f				      JMP   LAB_XERR          ; do error #X, then warm start
4559		.91a0																		LAB_20F8
4560		.91a0		a5 ac						lda $ac					      LDA   str_ln            ; get string length
4561		.91a2		95 00						sta $00,x				      STA   PLUS_0,X          ; put on string stack
4562		.91a4		a5 ad						lda $ad					      LDA   str_pl            ; get string pointer low byte
4563		.91a6		95 01						sta $01,x				      STA   PLUS_1,X          ; put on string stack
4564		.91a8		a5 ae						lda $ae					      LDA   str_ph            ; get string pointer high byte
4565		.91aa		95 02						sta $02,x				      STA   PLUS_2,X          ; put on string stack
4566		.91ac		a0 00						ldy #$00				      LDY   #$00              ; clear Y
4567		.91ae		86 ae						stx $ae					      STX   des_pl            ; save string descriptor pointer low byte
4568		.91b0		84 af						sty $af					      STY   des_ph            ; save string descriptor pointer high byte (always $00)
4569		.91b2		88							dey							      DEY                     ; Y = $FF
4570		.91b3		84 5f						sty $5f					      STY   Dtypef            ; save data type flag, $FF=string
4571		.91b5		86 66						stx $66					      STX   last_sl           ; save old stack pointer (current top item)
4572		.91b7		e8							inx							      INX                     ; update stack pointer
4573		.91b8		e8							inx							      INX                     ; update stack pointer
4574		.91b9		e8							inx							      INX                     ; update stack pointer
4575		.91ba		86 65						stx $65					      STX   next_s            ; save new top item value
4576		.91bc		60							rts							      RTS
4582		.91bd																		LAB_2115
4583		.91bd		46 60						lsr $60					      LSR   Gclctd            ; clear garbage collected flag (b7)
4586		.91bf																		LAB_2117
4587		.91bf		48							pha							      PHA                     ; save string length
4588		.91c0		49 ff						eor #$ff				      EOR   #$FF              ; complement it
4589		.91c2		38							sec							      SEC                     ; set carry for subtract (twos comp add)
4590		.91c3		65 81						adc $81					      ADC   Sstorl            ; add bottom of string space low byte (subtract length)
4591		.91c5		a4 82						ldy $82					      LDY   Sstorh            ; get bottom of string space high byte
4592		.91c7		b0 01						bcs $91ca				      BCS   LAB_2122          ; skip decrement if no underflow
4594		.91c9		88							dey							      DEY                     ; decrement bottom of string space high byte
4595		.91ca																		LAB_2122
4596		.91ca		c4 80						cpy $80					      CPY   Earryh            ; compare with array mem end high byte
4597		.91cc		90 11						bcc $91df				      BCC   LAB_2137          ; do out of memory error if less
4599		.91ce		d0 04						bne $91d4				      BNE   LAB_212C          ; if not = skip next test
4601		.91d0		c5 7f						cmp $7f					      CMP   Earryl            ; compare with array mem end low byte
4602		.91d2		90 0b						bcc $91df				      BCC   LAB_2137          ; do out of memory error if less
4604		.91d4																		LAB_212C
4605		.91d4		85 81						sta $81					      STA   Sstorl            ; save bottom of string space low byte
4606		.91d6		84 82						sty $82					      STY   Sstorh            ; save bottom of string space high byte
4607		.91d8		85 83						sta $83					      STA   Sutill            ; save string utility ptr low byte
4608		.91da		84 84						sty $84					      STY   Sutilh            ; save string utility ptr high byte
4609		.91dc		aa							tax							      TAX                     ; copy low byte to X
4610		.91dd		68							pla							      PLA                     ; get string length back
4611		.91de		60							rts							      RTS
4613		.91df																		LAB_2137
4614		.91df		a2 0c						ldx #$0c				      LDX   #$0C              ; error code $0C ("Out of memory" error)
4615		.91e1		a5 60						lda $60					      LDA   Gclctd            ; get garbage collected flag
4616		.91e3		30 b8						bmi $919d				      BMI   LAB_20F5          ; if set then do error code X
4618		.91e5		20 ef 91				jsr $91ef				      JSR   LAB_GARB          ; else go do garbage collection
4619		.91e8		a9 80						lda #$80				      LDA   #$80              ; flag for garbage collected
4620		.91ea		85 60						sta $60					      STA   Gclctd            ; set garbage collected flag
4621		.91ec		68							pla							      PLA                     ; pull length
4622		.91ed		d0 d0						bne $91bf				      BNE   LAB_2117          ; go try again (loop always, length should never be = $00)
4626		.91ef																		LAB_GARB
4627		.91ef		a6 85						ldx $85					      LDX   Ememl             ; get end of mem low byte
4628		.91f1		a5 86						lda $86					      LDA   Ememh             ; get end of mem high byte
4632		.91f3																		LAB_214B
4633		.91f3		86 81						stx $81					      STX   Sstorl            ; set string storage low byte
4634		.91f5		85 82						sta $82					      STA   Sstorh            ; set string storage high byte
4635		.91f7		a0 00						ldy #$00				      LDY   #$00              ; clear index
4636		.91f9		84 9d						sty $9d					      STY   garb_h            ; clear working pointer high byte (flag no strings to move)
4639		.91fb		84 9c						sty $9c					      STY   garb_l            ; clear working pointer low byte (flag no strings to move)
4641		.91fd		a5 7f						lda $7f					      LDA   Earryl            ; get array mem end low byte
4642		.91ff		a6 80						ldx $80					      LDX   Earryh            ; get array mem end high byte
4643		.9201		85 aa						sta $aa					      STA   Histrl            ; save as highest string low byte
4644		.9203		86 ab						stx $ab					      STX   Histrh            ; save as highest string high byte
4645		.9205		a9 68						lda #$68				      LDA   #des_sk           ; set descriptor stack pointer
4646		.9207		85 71						sta $71					      STA   ut1_pl            ; save descriptor stack pointer low byte
4647		.9209		84 72						sty $72					      STY   ut1_ph            ; save descriptor stack pointer high byte ($00)
4648		.920b																		LAB_2161
4649		.920b		c5 65						cmp $65					      CMP   next_s            ; compare with descriptor stack pointer
4650		.920d		f0 05						beq $9214				      BEQ   LAB_216A          ; branch if =
4652		.920f		20 75 92				jsr $9275				      JSR   LAB_21D7          ; go garbage collect descriptor stack
4653		.9212		f0 f7						beq $920b				      BEQ   LAB_2161          ; loop always
4656		.9214																		LAB_216A
4657		.9214		06 a0						asl $a0					      ASL   g_step            ; set step size = $06
4658		.9216		a5 7b						lda $7b					      LDA   Svarl             ; get start of vars low byte
4659		.9218		a6 7c						ldx $7c					      LDX   Svarh             ; get start of vars high byte
4660		.921a		85 71						sta $71					      STA   ut1_pl            ; save as pointer low byte
4661		.921c		86 72						stx $72					      STX   ut1_ph            ; save as pointer high byte
4662		.921e																		LAB_2176
4663		.921e		e4 7e						cpx $7e					      CPX   Sarryh            ; compare start of arrays high byte
4664		.9220		d0 04						bne $9226				      BNE   LAB_217E          ; branch if no high byte match
4666		.9222		c5 7d						cmp $7d					      CMP   Sarryl            ; else compare start of arrays low byte
4667		.9224		f0 05						beq $922b				      BEQ   LAB_2183          ; branch if = var mem end
4669		.9226																		LAB_217E
4670		.9226		20 6f 92				jsr $926f				      JSR   LAB_21D1          ; go garbage collect strings
4671		.9229		f0 f3						beq $921e				      BEQ   LAB_2176          ; loop always
4674		.922b																		LAB_2183
4675		.922b		85 a4						sta $a4					      STA   Nbendl            ; save start of arrays low byte as working pointer
4676		.922d		86 a5						stx $a5					      STX   Nbendh            ; save start of arrays high byte as working pointer
4677		.922f		a9 04						lda #$04				      LDA   #$04              ; set step size
4678		.9231		85 a0						sta $a0					      STA   g_step            ; save step size
4679		.9233																		LAB_218B
4680		.9233		a5 a4						lda $a4					      LDA   Nbendl            ; get pointer low byte
4681		.9235		a6 a5						ldx $a5					      LDX   Nbendh            ; get pointer high byte
4682		.9237																		LAB_218F
4683		.9237		e4 80						cpx $80					      CPX   Earryh            ; compare with array mem end high byte
4684		.9239		d0 04						bne $923f				      BNE   LAB_219A          ; branch if not at end
4686		.923b		c5 7f						cmp $7f					      CMP   Earryl            ; else compare with array mem end low byte
4687		.923d		f0 75						beq $92b4				      BEQ   LAB_2216          ; tidy up and exit if at end
4689		.923f																		LAB_219A
4690		.923f		85 71						sta $71					      STA   ut1_pl            ; save pointer low byte
4691		.9241		86 72						stx $72					      STX   ut1_ph            ; save pointer high byte
4692		.9243		a0 02						ldy #$02				      LDY   #$02              ; set index
4693		.9245		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get array size low byte
4694		.9247		65 a4						adc $a4					      ADC   Nbendl            ; add start of this array low byte
4695		.9249		85 a4						sta $a4					      STA   Nbendl            ; save start of next array low byte
4696		.924b		c8							iny							      INY                     ; increment index
4697		.924c		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get array size high byte
4698		.924e		65 a5						adc $a5					      ADC   Nbendh            ; add start of this array high byte
4699		.9250		85 a5						sta $a5					      STA   Nbendh            ; save start of next array high byte
4700		.9252		a0 01						ldy #$01				      LDY   #$01              ; set index
4701		.9254		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get name second byte
4702		.9256		10 db						bpl $9233				      BPL   LAB_218B          ; skip if not string array
4706		.9258		a0 04						ldy #$04				      LDY   #$04              ; set index
4707		.925a		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get # of dimensions
4708		.925c		0a							asl a						      ASL                     ; *2
4709		.925d		69 05						adc #$05				      ADC   #$05              ; +5 (array header size)
4710		.925f		20 a7 92				jsr $92a7				      JSR   LAB_2208          ; go set up for first element
4711		.9262																		LAB_21C4
4712		.9262		e4 a5						cpx $a5					      CPX   Nbendh            ; compare with start of next array high byte
4713		.9264		d0 04						bne $926a				      BNE   LAB_21CC          ; branch if <> (go do this array)
4715		.9266		c5 a4						cmp $a4					      CMP   Nbendl            ; else compare element pointer low byte with next array
4717		.9268		f0 cd						beq $9237				      BEQ   LAB_218F          ; if equal then go do next array
4719		.926a																		LAB_21CC
4720		.926a		20 75 92				jsr $9275				      JSR   LAB_21D7          ; go defrag array strings
4721		.926d		f0 f3						beq $9262				      BEQ   LAB_21C4          ; go do next array string (loop always)
4727		.926f																		LAB_21D1
4728		.926f		c8							iny							      INY                     ; increment index (Y was $00)
4729		.9270		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get var name byte 2
4730		.9272		10 30						bpl $92a4				      BPL   LAB_2206          ; if not string, step pointer to next var and return
4732		.9274		c8							iny							      INY                     ; else increment index
4733		.9275																		LAB_21D7
4734		.9275		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get string length
4735		.9277		f0 2b						beq $92a4				      BEQ   LAB_2206          ; if null, step pointer to next string and return
4737		.9279		c8							iny							      INY                     ; else increment index
4738		.927a		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get string pointer low byte
4739		.927c		aa							tax							      TAX                     ; copy to X
4740		.927d		c8							iny							      INY                     ; increment index
4741		.927e		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get string pointer high byte
4742		.9280		c5 82						cmp $82					      CMP   Sstorh            ; compare bottom of string space high byte
4743		.9282		90 06						bcc $928a				      BCC   LAB_21EC          ; branch if less
4745		.9284		d0 1e						bne $92a4				      BNE   LAB_2206          ; if greater, step pointer to next string and return
4748		.9286		e4 81						cpx $81					      CPX   Sstorl            ; compare bottom of string space low byte
4749		.9288		b0 1a						bcs $92a4				      BCS   LAB_2206          ; if >=, step pointer to next string and return
4752		.928a																		LAB_21EC
4753		.928a		c5 ab						cmp $ab					      CMP   Histrh            ; compare to highest string high byte
4754		.928c		90 17						bcc $92a5				      BCC   LAB_2207          ; if <, step pointer to next string and return
4756		.928e		d0 04						bne $9294				      BNE   LAB_21F6          ; if > update pointers, step to next and return
4759		.9290		e4 aa						cpx $aa					      CPX   Histrl            ; compare to highest string low byte
4760		.9292		90 11						bcc $92a5				      BCC   LAB_2207          ; if <, step pointer to next string and return
4763		.9294																		LAB_21F6
4764		.9294		86 aa						stx $aa					      STX   Histrl            ; save as new highest string low byte
4765		.9296		85 ab						sta $ab					      STA   Histrh            ; save as new highest string high byte
4766		.9298		a5 71						lda $71					      LDA   ut1_pl            ; get start of vars(descriptors) low byte
4767		.929a		a6 72						ldx $72					      LDX   ut1_ph            ; get start of vars(descriptors) high byte
4768		.929c		85 9c						sta $9c					      STA   garb_l            ; save as working pointer low byte
4769		.929e		86 9d						stx $9d					      STX   garb_h            ; save as working pointer high byte
4770		.92a0		88							dey							      DEY                     ; decrement index DIFFERS
4771		.92a1		88							dey							      DEY                     ; decrement index (should point to descriptor start)
4772		.92a2		84 a2						sty $a2					      STY   g_indx            ; save index pointer
4775		.92a4																		LAB_2206
4776		.92a4		18							clc							      CLC                     ; clear carry for add
4777		.92a5																		LAB_2207
4778		.92a5		a5 a0						lda $a0					      LDA   g_step            ; get step size
4779		.92a7																		LAB_2208
4780		.92a7		65 71						adc $71					      ADC   ut1_pl            ; add pointer low byte
4781		.92a9		85 71						sta $71					      STA   ut1_pl            ; save pointer low byte
4782		.92ab		90 02						bcc $92af				      BCC   LAB_2211          ; branch if no overflow
4784		.92ad		e6 72						inc $72					      INC   ut1_ph            ; else increment high byte
4785		.92af																		LAB_2211
4786		.92af		a6 72						ldx $72					      LDX   ut1_ph            ; get pointer high byte
4787		.92b1		a0 00						ldy #$00				      LDY   #$00              ; clear Y
4788		.92b3		60							rts							      RTS
4792		.92b4																		LAB_2216
4793		.92b4		c6 a0						dec $a0					      DEC   g_step            ; decrement step size (now $03 for descriptor stack)
4798		.92b6		a5 9d						lda $9d					      LDA   garb_h            ; any string to move?
4799		.92b8		05 9c						ora $9c					      ORA   garb_l
4801		.92ba		f0 f3						beq $92af				      BEQ   LAB_2211          ; exit if nothing to move
4803		.92bc		a4 a2						ldy $a2					      LDY   g_indx            ; get index byte back (points to descriptor)
4804		.92be		18							clc							      CLC                     ; clear carry for add
4805		.92bf		b1 9c						lda ($9c),y			      LDA   (garb_l),Y        ; get string length
4806		.92c1		65 aa						adc $aa					      ADC   Histrl            ; add highest string low byte
4807		.92c3		85 a6						sta $a6					      STA   Obendl            ; save old block end low pointer
4808		.92c5		a5 ab						lda $ab					      LDA   Histrh            ; get highest string high byte
4809		.92c7		69 00						adc #$00				      ADC   #$00              ; add any carry
4810		.92c9		85 a7						sta $a7					      STA   Obendh            ; save old block end high byte
4811		.92cb		a5 81						lda $81					      LDA   Sstorl            ; get bottom of string space low byte
4812		.92cd		a6 82						ldx $82					      LDX   Sstorh            ; get bottom of string space high byte
4813		.92cf		85 a4						sta $a4					      STA   Nbendl            ; save new block end low byte
4814		.92d1		86 a5						stx $a5					      STX   Nbendh            ; save new block end high byte
4815		.92d3		20 c8 80				jsr $80c8				      JSR   LAB_11D6          ; open up space in memory, don't set array end
4816		.92d6		a4 a2						ldy $a2					      LDY   g_indx            ; get index byte
4817		.92d8		c8							iny							      INY                     ; point to descriptor low byte
4818		.92d9		a5 a4						lda $a4					      LDA   Nbendl            ; get string pointer low byte
4819		.92db		91 9c						sta ($9c),y			      STA   (garb_l),Y        ; save new string pointer low byte
4820		.92dd		aa							tax							      TAX                     ; copy string pointer low byte
4821		.92de		e6 a5						inc $a5					      INC   Nbendh            ; correct high byte (move sets high byte -1)
4822		.92e0		a5 a5						lda $a5					      LDA   Nbendh            ; get new string pointer high byte
4823		.92e2		c8							iny							      INY                     ; point to descriptor high byte
4824		.92e3		91 9c						sta ($9c),y			      STA   (garb_l),Y        ; save new string pointer high byte
4825		.92e5		4c f3 91				jmp $91f3				      JMP   LAB_214B          ; re-run routine from last ending
4831		.92e8																		LAB_224D
4832		.92e8		a5 af						lda $af					      LDA   des_ph            ; get descriptor pointer high byte
4833		.92ea		48							pha							      PHA                     ; put on stack
4834		.92eb		a5 ae						lda $ae					      LDA   des_pl            ; get descriptor pointer low byte
4835		.92ed		48							pha							      PHA                     ; put on stack
4838		.92ee																		LAB_224Da
4840		.92ee		20 cd 8b				jsr $8bcd				      JSR   LAB_GVAL          ; get value from line
4841		.92f1		20 d2 8a				jsr $8ad2				      JSR   LAB_CTST          ; check if source is string, else do type mismatch
4842		.92f4		68							pla							      PLA                     ; get descriptor pointer low byte back
4843		.92f5		85 b8						sta $b8					      STA   ssptr_l           ; set pointer low byte
4844		.92f7		68							pla							      PLA                     ; get descriptor pointer high byte back
4845		.92f8		85 b9						sta $b9					      STA   ssptr_h           ; set pointer high byte
4846		.92fa		a0 00						ldy #$00				      LDY   #$00              ; clear index
4847		.92fc		b1 b8						lda ($b8),y			      LDA   (ssptr_l),Y       ; get length_1 from descriptor
4848		.92fe		18							clc							      CLC                     ; clear carry for add
4849		.92ff		71 ae						adc ($ae),y			      ADC   (des_pl),Y        ; add length_2
4850		.9301		90 05						bcc $9308				      BCC   LAB_226D          ; branch if no overflow
4852		.9303		a2 1a						ldx #$1a				      LDX   #$1A              ; else set error code $1A ("String too long" error)
4853		.9305		4c 3f 81				jmp $813f				      JMP   LAB_XERR          ; do error #X, then warm start
4855		.9308																		LAB_226D
4856		.9308		20 40 91				jsr $9140				      JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
4858		.930b		20 25 93				jsr $9325				      JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
4859		.930e		a5 9e						lda $9e					      LDA   des_2l            ; get descriptor pointer low byte
4860		.9310		a4 9f						ldy $9f					      LDY   des_2h            ; get descriptor pointer high byte
4861		.9312		20 56 93				jsr $9356				      JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
4864		.9315		20 37 93				jsr $9337				      JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
4865		.9318		a5 b8						lda $b8					      LDA   ssptr_l           ;.set descriptor pointer low byte
4866		.931a		a4 b9						ldy $b9					      LDY   ssptr_h           ;.set descriptor pointer high byte
4867		.931c		20 56 93				jsr $9356				      JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
4870		.931f		20 95 91				jsr $9195				      JSR   LAB_RTST          ; check for space on descriptor stack then put string
4873		.9322		4c f8 8a				jmp $8af8				      JMP   LAB_1ADB          ;.continue evaluation
4877		.9325																		LAB_228A
4878		.9325		a0 00						ldy #$00				      LDY   #$00              ; clear index
4879		.9327		b1 b8						lda ($b8),y			      LDA   (sdescr),Y        ; get string length
4880		.9329		48							pha							      PHA                     ; save on stack
4881		.932a		c8							iny							      INY                     ; increment index
4882		.932b		b1 b8						lda ($b8),y			      LDA   (sdescr),Y        ; get source string pointer low byte
4883		.932d		aa							tax							      TAX                     ; copy to X
4884		.932e		c8							iny							      INY                     ; increment index
4885		.932f		b1 b8						lda ($b8),y			      LDA   (sdescr),Y        ; get source string pointer high byte
4886		.9331		a8							tay							      TAY                     ; copy to Y
4887		.9332		68							pla							      PLA                     ; get length back
4891		.9333																		LAB_2298
4892		.9333		86 71						stx $71					      STX   ut1_pl            ; save source string pointer low byte
4893		.9335		84 72						sty $72					      STY   ut1_ph            ; save source string pointer high byte
4897		.9337																		LAB_229C
4898		.9337		aa							tax							      TAX                     ; copy length to index (don't count with Y)
4899		.9338		f0 14						beq $934e				      BEQ   LAB_22B2          ; branch if = $0 (null string) no need to add zero length
4901		.933a		a0 00						ldy #$00				      LDY   #$00              ; zero pointer (copy forward)
4902		.933c																		LAB_22A0
4903		.933c		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get source byte
4904		.933e		91 83						sta ($83),y			      STA   (Sutill),Y        ; save destination byte
4906		.9340		c8							iny							      INY                     ; increment index
4907		.9341		ca							dex							      DEX                     ; decrement counter
4908		.9342		d0 f8						bne $933c				      BNE   LAB_22A0          ; loop while <> 0
4910		.9344		98							tya							      TYA                     ; restore length from Y
4911		.9345																		LAB_22A9
4912		.9345		18							clc							      CLC                     ; clear carry for add
4913		.9346		65 83						adc $83					      ADC   Sutill            ; add string utility ptr low byte
4914		.9348		85 83						sta $83					      STA   Sutill            ; save string utility ptr low byte
4915		.934a		90 02						bcc $934e				      BCC   LAB_22B2          ; branch if no carry
4917		.934c		e6 84						inc $84					      INC   Sutilh            ; else increment string utility ptr high byte
4918		.934e																		LAB_22B2
4919		.934e		60							rts							      RTS
4923		.934f																		LAB_EVST
4924		.934f		20 d2 8a				jsr $8ad2				      JSR   LAB_CTST          ; check if source is string, else do type mismatch
4929		.9352																		LAB_22B6
4930		.9352		a5 ae						lda $ae					      LDA   des_pl            ; get descriptor pointer low byte
4931		.9354		a4 af						ldy $af					      LDY   des_ph            ; get descriptor pointer high byte
4936		.9356																		LAB_22BA
4937		.9356		85 71						sta $71					      STA   ut1_pl            ; save descriptor pointer low byte
4938		.9358		84 72						sty $72					      STY   ut1_ph            ; save descriptor pointer high byte
4939		.935a		20 87 93				jsr $9387				      JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
4940		.935d		08							php							      PHP                     ; save status flags
4941		.935e		a0 00						ldy #$00				      LDY   #$00              ; clear index
4942		.9360		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get length from string descriptor
4943		.9362		48							pha							      PHA                     ; put on stack
4944		.9363		c8							iny							      INY                     ; increment index
4945		.9364		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get string pointer low byte from descriptor
4946		.9366		aa							tax							      TAX                     ; copy to X
4947		.9367		c8							iny							      INY                     ; increment index
4948		.9368		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get string pointer high byte from descriptor
4949		.936a		a8							tay							      TAY                     ; copy to Y
4950		.936b		68							pla							      PLA                     ; get string length back
4951		.936c		28							plp							      PLP                     ; restore status
4952		.936d		d0 13						bne $9382				      BNE   LAB_22E6          ; branch if pointer <> last_sl,last_sh
4954		.936f		c4 82						cpy $82					      CPY   Sstorh            ; compare bottom of string space high byte
4955		.9371		d0 0f						bne $9382				      BNE   LAB_22E6          ; branch if <>
4957		.9373		e4 81						cpx $81					      CPX   Sstorl            ; else compare bottom of string space low byte
4958		.9375		d0 0b						bne $9382				      BNE   LAB_22E6          ; branch if <>
4960		.9377		48							pha							      PHA                     ; save string length
4961		.9378		18							clc							      CLC                     ; clear carry for add
4962		.9379		65 81						adc $81					      ADC   Sstorl            ; add bottom of string space low byte
4963		.937b		85 81						sta $81					      STA   Sstorl            ; save bottom of string space low byte
4964		.937d		90 02						bcc $9381				      BCC   LAB_22E5          ; skip increment if no overflow
4966		.937f		e6 82						inc $82					      INC   Sstorh            ; increment bottom of string space high byte
4967		.9381																		LAB_22E5
4968		.9381		68							pla							      PLA                     ; restore string length
4969		.9382																		LAB_22E6
4970		.9382		86 71						stx $71					      STX   ut1_pl            ; save string pointer low byte
4971		.9384		84 72						sty $72					      STY   ut1_ph            ; save string pointer high byte
4972		.9386		60							rts							      RTS
4977		.9387																		LAB_22EB
4978		.9387		c4 67						cpy $67					      CPY   last_sh           ; compare pointer high byte
4979		.9389		d0 0c						bne $9397				      BNE   LAB_22FB          ; exit if <>
4981		.938b		c5 66						cmp $66					      CMP   last_sl           ; compare pointer low byte
4982		.938d		d0 08						bne $9397				      BNE   LAB_22FB          ; exit if <>
4984		.938f		85 65						sta $65					      STA   next_s            ; save descriptor stack pointer
4985		.9391		e9 03						sbc #$03				      SBC   #$03              ; -3
4986		.9393		85 66						sta $66					      STA   last_sl           ; save low byte -3
4987		.9395		a0 00						ldy #$00				      LDY   #$00              ; clear high byte
4988		.9397																		LAB_22FB
4989		.9397		60							rts							      RTS
4993		.9398																		LAB_CHRS
4994		.9398		20 a3 94				jsr $94a3				      JSR   LAB_EVBY          ; evaluate byte expression, result in X
4995		.939b		8a							txa							      TXA                     ; copy to A
4996		.939c		48							pha							      PHA                     ; save character
4997		.939d		a9 01						lda #$01				      LDA   #$01              ; string is single byte
4998		.939f		20 48 91				jsr $9148				      JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
5000		.93a2		68							pla							      PLA                     ; get character back
5001		.93a3		a0 00						ldy #$00				      LDY   #$00              ; clear index
5002		.93a5		91 ad						sta ($ad),y			      STA   (str_pl),Y        ; save byte in string (byte IS string!)
5003		.93a7		4c 95 91				jmp $9195				      JMP   LAB_RTST          ; check for space on descriptor stack then put string
5009		.93aa																		LAB_LEFT
5010		.93aa		48							pha							      PHA                     ; push byte parameter
5011		.93ab		20 0b 94				jsr $940b				      JSR   LAB_236F          ; pull string data and byte parameter from stack
5013		.93ae		d1 9e						cmp ($9e),y			      CMP   (des_2l),Y        ; compare byte parameter with string length
5014		.93b0		98							tya							      TYA                     ; clear A
5015		.93b1		f0 09						beq $93bc				      BEQ   LAB_2316          ; go do string copy (branch always)
5019		.93b3																		LAB_RIGHT
5020		.93b3		48							pha							      PHA                     ; push byte parameter
5021		.93b4		20 0b 94				jsr $940b				      JSR   LAB_236F          ; pull string data and byte parameter from stack
5023		.93b7		18							clc							      CLC                     ; clear carry for add-1
5024		.93b8		f1 9e						sbc ($9e),y			      SBC   (des_2l),Y        ; subtract string length
5025		.93ba		49 ff						eor #$ff				      EOR   #$FF              ; invert it (A=LEN(expression$)-l)
5027		.93bc																		LAB_2316
5028		.93bc		90 04						bcc $93c2				      BCC   LAB_231C          ; branch if string length > byte parameter
5030		.93be		b1 9e						lda ($9e),y			      LDA   (des_2l),Y        ; else make parameter = length
5031		.93c0		aa							tax							      TAX                     ; copy to byte parameter copy
5032		.93c1		98							tya							      TYA                     ; clear string start offset
5033		.93c2																		LAB_231C
5034		.93c2		48							pha							      PHA                     ; save string start offset
5035		.93c3																		LAB_231D
5036		.93c3		8a							txa							      TXA                     ; copy byte parameter (or string length if <)
5037		.93c4																		LAB_231E
5038		.93c4		48							pha							      PHA                     ; save string length
5039		.93c5		20 48 91				jsr $9148				      JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
5041		.93c8		a5 9e						lda $9e					      LDA   des_2l            ; get descriptor pointer low byte
5042		.93ca		a4 9f						ldy $9f					      LDY   des_2h            ; get descriptor pointer high byte
5043		.93cc		20 56 93				jsr $9356				      JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
5046		.93cf		68							pla							      PLA                     ; get string length back
5047		.93d0		a8							tay							      TAY                     ; copy length to Y
5048		.93d1		68							pla							      PLA                     ; get string start offset back
5049		.93d2		18							clc							      CLC                     ; clear carry for add
5050		.93d3		65 71						adc $71					      ADC   ut1_pl            ; add start offset to string start pointer low byte
5051		.93d5		85 71						sta $71					      STA   ut1_pl            ; save string start pointer low byte
5052		.93d7		90 02						bcc $93db				      BCC   LAB_2335          ; branch if no overflow
5054		.93d9		e6 72						inc $72					      INC   ut1_ph            ; else increment string start pointer high byte
5055		.93db																		LAB_2335
5056		.93db		98							tya							      TYA                     ; copy length to A
5057		.93dc		20 37 93				jsr $9337				      JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
5058		.93df		4c 95 91				jmp $9195				      JMP   LAB_RTST          ; check for space on descriptor stack then put string
5064		.93e2																		LAB_MIDS
5065		.93e2		48							pha							      PHA                     ; push byte parameter
5066		.93e3		a9 ff						lda #$ff				      LDA   #$FF              ; set default length = 255
5067		.93e5		85 af						sta $af					      STA   mids_l            ; save default length
5068		.93e7		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; scan memory
5069		.93ea		c9 29						cmp #$29				      CMP   #')'              ; compare with ")"
5070		.93ec		f0 06						beq $93f4				      BEQ   LAB_2358          ; branch if = ")" (skip second byte get)
5072		.93ee		20 fe 8b				jsr $8bfe				      JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
5073		.93f1		20 a0 94				jsr $94a0				      JSR   LAB_GTBY          ; get byte parameter (use copy in mids_l)
5074		.93f4																		LAB_2358
5075		.93f4		20 0b 94				jsr $940b				      JSR   LAB_236F          ; pull string data and byte parameter from stack
5077		.93f7		ca							dex							      DEX                     ; decrement start index
5078		.93f8		8a							txa							      TXA                     ; copy to A
5079		.93f9		48							pha							      PHA                     ; save string start offset
5080		.93fa		18							clc							      CLC                     ; clear carry for sub-1
5081		.93fb		a2 00						ldx #$00				      LDX   #$00              ; clear output string length
5082		.93fd		f1 9e						sbc ($9e),y			      SBC   (des_2l),Y        ; subtract string length
5083		.93ff		b0 c2						bcs $93c3				      BCS   LAB_231D          ; if start>string length go do null string
5085		.9401		49 ff						eor #$ff				      EOR   #$FF              ; complement -length
5086		.9403		c5 af						cmp $af					      CMP   mids_l            ; compare byte parameter
5087		.9405		90 bd						bcc $93c4				      BCC   LAB_231E          ; if length>remaining string go do RIGHT$
5089		.9407		a5 af						lda $af					      LDA   mids_l            ; get length byte
5090		.9409		b0 b9						bcs $93c4				      BCS   LAB_231E          ; go do string copy (branch always)
5095		.940b																		LAB_236F
5096		.940b		20 ef 8b				jsr $8bef				      JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
5097		.940e		68							pla							      PLA                     ; pull return address low byte (return address)
5098		.940f		85 a2						sta $a2					      STA   Fnxjpl            ; save functions jump vector low byte
5099		.9411		68							pla							      PLA                     ; pull return address high byte (return address)
5100		.9412		85 a3						sta $a3					      STA   Fnxjph            ; save functions jump vector high byte
5101		.9414		68							pla							      PLA                     ; pull byte parameter
5102		.9415		aa							tax							      TAX                     ; copy byte parameter to X
5103		.9416		68							pla							      PLA                     ; pull string pointer low byte
5104		.9417		85 9e						sta $9e					      STA   des_2l            ; save it
5105		.9419		68							pla							      PLA                     ; pull string pointer high byte
5106		.941a		85 9f						sta $9f					      STA   des_2h            ; save it
5107		.941c		a0 00						ldy #$00				      LDY   #$00              ; clear index
5108		.941e		8a							txa							      TXA                     ; copy byte parameter
5109		.941f		f0 79						beq $949a				      BEQ   LAB_23A8          ; if null do function call error then warm start
5111		.9421		e6 a2						inc $a2					      INC   Fnxjpl            ; increment function jump vector low byte
5115		.9423		6c a2 00				jmp ($00a2)			      JMP   (Fnxjpl)          ; in effect, RTS
5119		.9426																		LAB_LCASE
5120		.9426		20 4f 93				jsr $934f				      JSR   LAB_EVST          ; evaluate string
5121		.9429		85 ac						sta $ac					      STA   str_ln            ; set string length
5122		.942b		a8							tay							      TAY                     ; copy length to Y
5123		.942c		f0 38						beq $9466				      BEQ   NoString          ; branch if null string
5125		.942e		20 48 91				jsr $9148				      JSR   LAB_MSSP          ; make string space A bytes long A=length,
5127		.9431		86 ad						stx $ad					      STX   str_pl            ; save string pointer low byte
5128		.9433		84 ae						sty $ae					      STY   str_ph            ; save string pointer high byte
5129		.9435		a8							tay							      TAY                     ; get string length back
5131		.9436																		LC_loop
5132		.9436		88							dey							      DEY                     ; decrement index
5133		.9437		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get byte from string
5134		.9439		20 30 8e				jsr $8e30				      JSR   LAB_1D82          ; is character "A" to "Z"
5135		.943c		90 02						bcc $9440				      BCC   NoUcase           ; branch if not upper case alpha
5137		.943e		09 20						ora #$20				      ORA   #$20              ; convert upper to lower case
5138		.9440																		NoUcase
5139		.9440		91 83						sta ($83),y			      STA   (Sutill),Y        ; save byte back to string
5140		.9442		98							tya							      TYA                     ; test index
5141		.9443		d0 f1						bne $9436				      BNE   LC_loop           ; loop if not all done
5143		.9445		f0 1f						beq $9466				      BEQ   NoString          ; tidy up and exit, branch always
5147		.9447																		LAB_UCASE
5148		.9447		20 4f 93				jsr $934f				      JSR   LAB_EVST          ; evaluate string
5149		.944a		85 ac						sta $ac					      STA   str_ln            ; set string length
5150		.944c		a8							tay							      TAY                     ; copy length to Y
5151		.944d		f0 17						beq $9466				      BEQ   NoString          ; branch if null string
5153		.944f		20 48 91				jsr $9148				      JSR   LAB_MSSP          ; make string space A bytes long A=length,
5155		.9452		86 ad						stx $ad					      STX   str_pl            ; save string pointer low byte
5156		.9454		84 ae						sty $ae					      STY   str_ph            ; save string pointer high byte
5157		.9456		a8							tay							      TAY                     ; get string length back
5159		.9457																		UC_loop
5160		.9457		88							dey							      DEY                     ; decrement index
5161		.9458		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get byte from string
5162		.945a		20 2c 8e				jsr $8e2c				      JSR   LAB_CASC          ; is character "a" to "z" (or "A" to "Z")
5163		.945d		90 02						bcc $9461				      BCC   NoLcase           ; branch if not alpha
5165		.945f		29 df						and #$df				      AND   #$DF              ; convert lower to upper case
5166		.9461																		NoLcase
5167		.9461		91 83						sta ($83),y			      STA   (Sutill),Y        ; save byte back to string
5168		.9463		98							tya							      TYA                     ; test index
5169		.9464		d0 f1						bne $9457				      BNE   UC_loop           ; loop if not all done
5171		.9466																		NoString
5172		.9466		4c 95 91				jmp $9195				      JMP   LAB_RTST          ; check for space on descriptor stack then put string
5178		.9469																		LAB_SADD
5179		.9469		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment and scan memory
5180		.946c		20 b8 8d				jsr $8db8				      JSR   LAB_GVAR          ; get var address
5182		.946f		20 ef 8b				jsr $8bef				      JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
5183		.9472		20 d2 8a				jsr $8ad2				      JSR   LAB_CTST          ; check if source is string, else do type mismatch
5185		.9475		a0 02						ldy #$02				      LDY   #$02              ; index to string pointer high byte
5186		.9477		b1 95						lda ($95),y			      LDA   (Cvaral),Y        ; get string pointer high byte
5187		.9479		aa							tax							      TAX                     ; copy string pointer high byte to X
5188		.947a		88							dey							      DEY                     ; index to string pointer low byte
5189		.947b		b1 95						lda ($95),y			      LDA   (Cvaral),Y        ; get string pointer low byte
5190		.947d		a8							tay							      TAY                     ; copy string pointer low byte to Y
5191		.947e		8a							txa							      TXA                     ; copy string pointer high byte to A
5192		.947f		4c 67 90				jmp $9067				      JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
5196		.9482																		LAB_LENS
5197		.9482		20 88 94				jsr $9488				      JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
5198		.9485		4c 74 90				jmp $9074				      JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
5202		.9488																		LAB_ESGL
5203		.9488		20 4f 93				jsr $934f				      JSR   LAB_EVST          ; evaluate string
5204		.948b		a8							tay							      TAY                     ; copy length to Y
5205		.948c		60							rts							      RTS
5209		.948d																		LAB_ASC
5210		.948d		20 88 94				jsr $9488				      JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
5211		.9490		f0 08						beq $949a				      BEQ   LAB_23A8          ; if null do function call error then warm start
5213		.9492		a0 00						ldy #$00				      LDY   #$00              ; set index to first character
5214		.9494		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get byte
5215		.9496		a8							tay							      TAY                     ; copy to Y
5216		.9497		4c 74 90				jmp $9074				      JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
5220		.949a																		LAB_23A8
5221		.949a		4c 37 8f				jmp $8f37				      JMP   LAB_FCER          ; do function call error then warm start
5225		.949d																		LAB_SGBY
5226		.949d		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment and scan memory
5230		.94a0																		LAB_GTBY
5231		.94a0		20 cd 8a				jsr $8acd				      JSR   LAB_EVNM          ; evaluate expression and check is numeric,
5236		.94a3																		LAB_EVBY
5237		.94a3		20 b0 8e				jsr $8eb0				      JSR   LAB_EVPI          ; evaluate integer expression (no check)
5239		.94a6		a4 ae						ldy $ae					      LDY   FAC1_2            ; get FAC1 mantissa2
5240		.94a8		d0 f0						bne $949a				      BNE   LAB_23A8          ; if top byte <> 0 do function call error then warm start
5242		.94aa		a6 af						ldx $af					      LDX   FAC1_3            ; get FAC1 mantissa3
5243		.94ac		4c c2 00				jmp $00c2				      JMP   LAB_GBYT          ; scan memory and return
5247		.94af																		LAB_VAL
5248		.94af		20 88 94				jsr $9488				      JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
5249		.94b2		d0 03						bne $94b7				      BNE   LAB_23C5          ; branch if not null string
5252		.94b4		4c 5d 96				jmp $965d				      JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
5254		.94b7																		LAB_23C5
5281		.94b7		48							pha							      PHA                     ; save length
5282		.94b8		c8							iny							      INY                     ; string length +1
5283		.94b9		98							tya							      TYA
5284		.94ba		20 48 91				jsr $9148				      JSR   LAB_MSSP          ; allocate temp string +1 bytes long
5285		.94bd		68							pla							      PLA                     ; get length back
5286		.94be		20 37 93				jsr $9337				      JSR   LAB_229C          ; copy string (ut1_pl) -> (Sutill) for A bytes
5287		.94c1		a9 00						lda #$00				      LDA   #0                ; add delimiter to end of string
5288		.94c3		a8							tay							      TAY
5289		.94c4		91 83						sta ($83),y			      STA   (Sutill),Y
5290		.94c6		a6 c3						ldx $c3					      LDX   Bpntrl            ; save BASIC execute pointer low byte
5291		.94c8		a4 c4						ldy $c4					      LDY   Bpntrh
5292		.94ca		86 ba						stx $ba					      STX   Btmpl
5293		.94cc		84 bb						sty $bb					      STY   Btmph
5294		.94ce		a6 ad						ldx $ad					      LDX   str_pl            ; point to temporary string
5295		.94d0		a4 ae						ldy $ae					      LDY   str_ph
5296		.94d2		86 c3						stx $c3					      STX   Bpntrl
5297		.94d4		84 c4						sty $c4					      STY   Bpntrh
5298		.94d6		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; scan memory
5299		.94d9		20 b3 99				jsr $99b3				      JSR   LAB_2887          ; get FAC1 from string
5304		.94dc																		LAB_23F3
5305		.94dc		a6 ba						ldx $ba					      LDX   Btmpl             ; get BASIC execute pointer low byte back
5306		.94de		a4 bb						ldy $bb					      LDY   Btmph             ; get BASIC execute pointer high byte back
5307		.94e0		86 c3						stx $c3					      STX   Bpntrl            ; save BASIC execute pointer low byte
5308		.94e2		84 c4						sty $c4					      STY   Bpntrh            ; save BASIC execute pointer high byte
5309		.94e4		60							rts							      RTS
5313		.94e5																		LAB_GADB
5314		.94e5		20 cd 8a				jsr $8acd				      JSR   LAB_EVNM          ; evaluate expression and check is numeric,
5316		.94e8		20 fe 94				jsr $94fe				      JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
5320		.94eb																		LAB_SCGB
5321		.94eb		20 fe 8b				jsr $8bfe				      JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
5322		.94ee		a5 12						lda $12					      LDA   Itemph            ; save temporary integer high byte
5323		.94f0		48							pha							      PHA                     ; on stack
5324		.94f1		a5 11						lda $11					      LDA   Itempl            ; save temporary integer low byte
5325		.94f3		48							pha							      PHA                     ; on stack
5326		.94f4		20 a0 94				jsr $94a0				      JSR   LAB_GTBY          ; get byte parameter
5327		.94f7		68							pla							      PLA                     ; pull low byte
5328		.94f8		85 11						sta $11					      STA   Itempl            ; restore temporary integer low byte
5329		.94fa		68							pla							      PLA                     ; pull high byte
5330		.94fb		85 12						sta $12					      STA   Itemph            ; restore temporary integer high byte
5331		.94fd		60							rts							      RTS
5338		.94fe																		LAB_F2FX
5339		.94fe		a5 ac						lda $ac					      LDA   FAC1_e            ; get FAC1 exponent
5340		.9500		c9 98						cmp #$98				      CMP   #$98              ; compare with exponent = 2^24
5341		.9502		b0 96						bcs $949a				      BCS   LAB_23A8          ; if >= do function call error then warm start
5343		.9504																		LAB_F2FU
5344		.9504		20 5d 99				jsr $995d				      JSR   LAB_2831          ; convert FAC1 floating-to-fixed
5345		.9507		a5 ae						lda $ae					      LDA   FAC1_2            ; get FAC1 mantissa2
5346		.9509		a4 af						ldy $af					      LDY   FAC1_3            ; get FAC1 mantissa3
5347		.950b		84 11						sty $11					      STY   Itempl            ; save temporary integer low byte
5348		.950d		85 12						sta $12					      STA   Itemph            ; save temporary integer high byte
5349		.950f		60							rts							      RTS
5353		.9510																		LAB_PEEK
5354		.9510		20 fe 94				jsr $94fe				      JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
5355		.9513		a2 00						ldx #$00				      LDX   #$00              ; clear index
5356		.9515		a1 11						lda ($11,x)			      LDA   (Itempl,X)        ; get byte via temporary integer (addr)
5357		.9517		a8							tay							      TAY                     ; copy byte to Y
5358		.9518		4c 74 90				jmp $9074				      JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
5362		.951b																		LAB_POKE
5363		.951b		20 e5 94				jsr $94e5				      JSR   LAB_GADB          ; get two parameters for POKE or WAIT
5364		.951e		8a							txa							      TXA                     ; copy byte argument to A
5365		.951f		a2 00						ldx #$00				      LDX   #$00              ; clear index
5366		.9521		81 11						sta ($11,x)			      STA   (Itempl,X)        ; save byte via temporary integer (addr)
5367		.9523		60							rts							      RTS
5371		.9524																		LAB_DEEK
5372		.9524		20 fe 94				jsr $94fe				      JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
5373		.9527		a2 00						ldx #$00				      LDX   #$00              ; clear index
5374		.9529		a1 11						lda ($11,x)			      LDA   (Itempl,X)        ; PEEK low byte
5375		.952b		a8							tay							      TAY                     ; copy to Y
5376		.952c		e6 11						inc $11					      INC   Itempl            ; increment pointer low byte
5377		.952e		d0 02						bne $9532				      BNE   Deekh             ; skip high increment if no rollover
5379		.9530		e6 12						inc $12					      INC   Itemph            ; increment pointer high byte
5380		.9532																		Deekh
5381		.9532		a1 11						lda ($11,x)			      LDA   (Itempl,X)        ; PEEK high byte
5382		.9534		4c 67 90				jmp $9067				      JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
5386		.9537																		LAB_DOKE
5387		.9537		20 cd 8a				jsr $8acd				      JSR   LAB_EVNM          ; evaluate expression and check is numeric,
5389		.953a		20 fe 94				jsr $94fe				      JSR   LAB_F2FX          ; convert floating-to-fixed
5391		.953d		84 97						sty $97					      STY   Frnxtl            ; save pointer low byte (float to fixed returns word in AY)
5392		.953f		85 98						sta $98					      STA   Frnxth            ; save pointer high byte
5394		.9541		20 fe 8b				jsr $8bfe				      JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
5395		.9544		20 cd 8a				jsr $8acd				      JSR   LAB_EVNM          ; evaluate expression and check is numeric,
5397		.9547		20 fe 94				jsr $94fe				      JSR   LAB_F2FX          ; convert floating-to-fixed
5399		.954a		98							tya							      TYA                     ; copy value low byte (float to fixed returns word in AY)
5400		.954b		a2 00						ldx #$00				      LDX   #$00              ; clear index
5401		.954d		81 97						sta ($97,x)			      STA   (Frnxtl,X)        ; POKE low byte
5402		.954f		e6 97						inc $97					      INC   Frnxtl            ; increment pointer low byte
5403		.9551		d0 02						bne $9555				      BNE   Dokeh             ; skip high increment if no rollover
5405		.9553		e6 98						inc $98					      INC   Frnxth            ; increment pointer high byte
5406		.9555																		Dokeh
5407		.9555		a5 12						lda $12					      LDA   Itemph            ; get value high byte
5408		.9557		81 97						sta ($97,x)			      STA   (Frnxtl,X)        ; POKE high byte
5409		.9559		4c c2 00				jmp $00c2				      JMP   LAB_GBYT          ; scan memory and return
5413		.955c																		LAB_SWAP
5414		.955c		20 b8 8d				jsr $8db8				      JSR   LAB_GVAR          ; get var1 address
5415		.955f		85 97						sta $97					      STA   Lvarpl            ; save var1 address low byte
5416		.9561		84 98						sty $98					      STY   Lvarph            ; save var1 address high byte
5417		.9563		a5 5f						lda $5f					      LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
5418		.9565		48							pha							      PHA                     ; save data type flag
5420		.9566		20 fe 8b				jsr $8bfe				      JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
5421		.9569		20 b8 8d				jsr $8db8				      JSR   LAB_GVAR          ; get var2 address (pointer in Cvaral/h)
5422		.956c		68							pla							      PLA                     ; pull var1 data type flag
5423		.956d		45 5f						eor $5f					      EOR   Dtypef            ; compare with var2 data type
5424		.956f		10 10						bpl $9581				      BPL   SwapErr           ; exit if not both the same type
5426		.9571		a0 03						ldy #$03				      LDY   #$03              ; four bytes to swap (either value or descriptor+1)
5427		.9573																		SwapLp
5428		.9573		b1 97						lda ($97),y			      LDA   (Lvarpl),Y        ; get byte from var1
5429		.9575		aa							tax							      TAX                     ; save var1 byte
5430		.9576		b1 95						lda ($95),y			      LDA   (Cvaral),Y        ; get byte from var2
5431		.9578		91 97						sta ($97),y			      STA   (Lvarpl),Y        ; save byte to var1
5432		.957a		8a							txa							      TXA                     ; restore var1 byte
5433		.957b		91 95						sta ($95),y			      STA   (Cvaral),Y        ; save byte to var2
5434		.957d		88							dey							      DEY                     ; decrement index
5435		.957e		10 f3						bpl $9573				      BPL   SwapLp            ; loop until done
5437		.9580		60							rts							      RTS
5439		.9581																		SwapErr
5440		.9581		4c dc 8a				jmp $8adc				      JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
5444		.9584																		LAB_CALL
5445		.9584		20 cd 8a				jsr $8acd				      JSR   LAB_EVNM          ; evaluate expression and check is numeric,
5447		.9587		20 fe 94				jsr $94fe				      JSR   LAB_F2FX          ; convert floating-to-fixed
5448		.958a		a9 95						lda #$95				      LDA   #>CallExit        ; set return address high byte
5449		.958c		48							pha							      PHA                     ; put on stack
5450		.958d		a9 92						lda #$92				      LDA   #<CallExit-1      ; set return address low byte
5451		.958f		48							pha							      PHA                     ; put on stack
5452		.9590		6c 11 00				jmp ($0011)			      JMP   (Itempl)          ; do indirect jump to user routine
5457		.9593																		CallExit
5458		.9593		4c c2 00				jmp $00c2				      JMP   LAB_GBYT          ; scan memory and return
5462		.9596																		LAB_WAIT
5463		.9596		20 e5 94				jsr $94e5				      JSR   LAB_GADB          ; get two parameters for POKE or WAIT
5464		.9599		86 97						stx $97					      STX   Frnxtl            ; save byte
5465		.959b		a2 00						ldx #$00				      LDX   #$00              ; clear mask
5466		.959d		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; scan memory
5467		.95a0		f0 03						beq $95a5				      BEQ   LAB_2441          ; skip if no third argument
5469		.95a2		20 eb 94				jsr $94eb				      JSR   LAB_SCGB          ; scan for "," and get byte, else SN error then warm start
5470		.95a5																		LAB_2441
5471		.95a5		86 98						stx $98					      STX   Frnxth            ; save EOR argument
5472		.95a7																		LAB_2445
5473		.95a7		b1 11						lda ($11),y			      LDA   (Itempl),Y        ; get byte via temporary integer (addr)
5474		.95a9		45 98						eor $98					      EOR   Frnxth            ; EOR with second argument (mask)
5475		.95ab		25 97						and $97					      AND   Frnxtl            ; AND with first argument (byte)
5476		.95ad		f0 f8						beq $95a7				      BEQ   LAB_2445          ; loop if result is zero
5478		.95af																		LAB_244D
5479		.95af		60							rts							      RTS
5483		.95b0																		LAB_2455
5484		.95b0		20 98 97				jsr $9798				      JSR   LAB_264D          ; unpack memory (AY) into FAC2
5488		.95b3																		LAB_SUBTRACT
5489		.95b3		a5 b0						lda $b0					      LDA   FAC1_s            ; get FAC1 sign (b7)
5490		.95b5		49 ff						eor #$ff				      EOR   #$FF              ; complement it
5491		.95b7		85 b0						sta $b0					      STA   FAC1_s            ; save FAC1 sign (b7)
5492		.95b9		45 b7						eor $b7					      EOR   FAC2_s            ; EOR with FAC2 sign (b7)
5493		.95bb		85 b8						sta $b8					      STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
5494		.95bd		a5 ac						lda $ac					      LDA   FAC1_e            ; get FAC1 exponent
5495		.95bf		4c ce 95				jmp $95ce				      JMP   LAB_ADD           ; go add FAC2 to FAC1
5499		.95c2																		LAB_2467
5500		.95c2		20 e7 96				jsr $96e7				      JSR   LAB_257B          ; shift FACX A times right (>8 shifts)
5501		.95c5		90 4d						bcc $9614				      BCC   LAB_24A8          ;.go subtract mantissas
5505		.95c7																		LAB_244E
5506		.95c7		a9 fa						lda #$fa				      LDA   #<LAB_2A96        ; set 0.5 pointer low byte
5507		.95c9		a0 a1						ldy #$a1				      LDY   #>LAB_2A96        ; set 0.5 pointer high byte
5511		.95cb																		LAB_246C
5512		.95cb		20 98 97				jsr $9798				      JSR   LAB_264D          ; unpack memory (AY) into FAC2
5516		.95ce																		LAB_ADD
5517		.95ce		d0 10						bne $95e0				      BNE   LAB_2474          ; branch if FAC1 was not zero
5521		.95d0																		LAB_279B
5522		.95d0		a5 b7						lda $b7					      LDA   FAC2_s            ; get FAC2 sign (b7)
5526		.95d2																		LAB_279D
5527		.95d2		85 b0						sta $b0					      STA   FAC1_s            ; save FAC1 sign (b7)
5528		.95d4		a2 04						ldx #$04				      LDX   #$04              ; 4 bytes to copy
5529		.95d6																		LAB_27A1
5530		.95d6		b5 b2						lda $b2,x				      LDA   FAC1_o,X          ; get byte from FAC2,X
5531		.95d8		95 ab						sta $ab,x				      STA   FAC1_e-1,X        ; save byte at FAC1,X
5532		.95da		ca							dex							      DEX                     ; decrement count
5533		.95db		d0 f9						bne $95d6				      BNE   LAB_27A1          ; loop if not all done
5535		.95dd		86 b9						stx $b9					      STX   FAC1_r            ; clear FAC1 rounding byte
5536		.95df		60							rts							      RTS
5539		.95e0																		LAB_2474
5540		.95e0		a6 b9						ldx $b9					      LDX   FAC1_r            ; get FAC1 rounding byte
5541		.95e2		86 a3						stx $a3					      STX   FAC2_r            ; save as FAC2 rounding byte
5542		.95e4		a2 b3						ldx #$b3				      LDX   #FAC2_e           ; set index to FAC2 exponent addr
5543		.95e6		a5 b3						lda $b3					      LDA   FAC2_e            ; get FAC2 exponent
5544		.95e8																		LAB_247C
5545		.95e8		a8							tay							      TAY                     ; copy exponent
5546		.95e9		f0 c4						beq $95af				      BEQ   LAB_244D          ; exit if zero
5548		.95eb		38							sec							      SEC                     ; set carry for subtract
5549		.95ec		e5 ac						sbc $ac					      SBC   FAC1_e            ; subtract FAC1 exponent
5550		.95ee		f0 24						beq $9614				      BEQ   LAB_24A8          ; branch if = (go add mantissa)
5552		.95f0		90 12						bcc $9604				      BCC   LAB_2498          ; branch if <
5555		.95f2		84 ac						sty $ac					      STY   FAC1_e            ; save FAC1 exponent
5556		.95f4		a4 b7						ldy $b7					      LDY   FAC2_s            ; get FAC2 sign (b7)
5557		.95f6		84 b0						sty $b0					      STY   FAC1_s            ; save FAC1 sign (b7)
5558		.95f8		49 ff						eor #$ff				      EOR   #$FF              ; complement A
5559		.95fa		69 00						adc #$00				      ADC   #$00              ; +1 (twos complement, carry is set)
5560		.95fc		a0 00						ldy #$00				      LDY   #$00              ; clear Y
5561		.95fe		84 a3						sty $a3					      STY   FAC2_r            ; clear FAC2 rounding byte
5562		.9600		a2 ac						ldx #$ac				      LDX   #FAC1_e           ; set index to FAC1 exponent addr
5563		.9602		d0 04						bne $9608				      BNE   LAB_249C          ; branch always
5565		.9604																		LAB_2498
5566		.9604		a0 00						ldy #$00				      LDY   #$00              ; clear Y
5567		.9606		84 b9						sty $b9					      STY   FAC1_r            ; clear FAC1 rounding byte
5568		.9608																		LAB_249C
5569		.9608		c9 f9						cmp #$f9				      CMP   #$F9              ; compare exponent diff with $F9
5570		.960a		30 b6						bmi $95c2				      BMI   LAB_2467          ; branch if range $79-$F8
5572		.960c		a8							tay							      TAY                     ; copy exponent difference to Y
5573		.960d		a5 b9						lda $b9					      LDA   FAC1_r            ; get FAC1 rounding byte
5574		.960f		56 01						lsr $01,x				      LSR   PLUS_1,X          ; shift FAC? mantissa1
5575		.9611		20 fe 96				jsr $96fe				      JSR   LAB_2592          ; shift FACX Y times right
5578		.9614																		LAB_24A8
5579		.9614		24 b8						bit $b8					      BIT   FAC_sc            ; test sign compare (FAC1 EOR FAC2)
5580		.9616		10 4c						bpl $9664				      BPL   LAB_24F8          ; if = add FAC2 mantissa to FAC1 mantissa and return
5582		.9618		a0 ac						ldy #$ac				      LDY   #FAC1_e           ; set index to FAC1 exponent addr
5583		.961a		e0 b3						cpx #$b3				      CPX   #FAC2_e           ; compare X to FAC2 exponent addr
5584		.961c		f0 02						beq $9620				      BEQ   LAB_24B4          ; branch if =
5586		.961e		a0 b3						ldy #$b3				      LDY   #FAC2_e           ; else set index to FAC2 exponent addr
5589		.9620																		LAB_24B4
5590		.9620		38							sec							      SEC                     ; set carry for subtract
5591		.9621		49 ff						eor #$ff				      EOR   #$FF              ; ones complement A
5592		.9623		65 a3						adc $a3					      ADC   FAC2_r            ; add FAC2 rounding byte
5593		.9625		85 b9						sta $b9					      STA   FAC1_r            ; save FAC1 rounding byte
5594		.9627		b9 03 00				lda $0003,y			      LDA   PLUS_3,Y          ; get FACY mantissa3
5595		.962a		f5 03						sbc $03,x				      SBC   PLUS_3,X          ; subtract FACX mantissa3
5596		.962c		85 af						sta $af					      STA   FAC1_3            ; save FAC1 mantissa3
5597		.962e		b9 02 00				lda $0002,y			      LDA   PLUS_2,Y          ; get FACY mantissa2
5598		.9631		f5 02						sbc $02,x				      SBC   PLUS_2,X          ; subtract FACX mantissa2
5599		.9633		85 ae						sta $ae					      STA   FAC1_2            ; save FAC1 mantissa2
5600		.9635		b9 01 00				lda $0001,y			      LDA   PLUS_1,Y          ; get FACY mantissa1
5601		.9638		f5 01						sbc $01,x				      SBC   PLUS_1,X          ; subtract FACX mantissa1
5602		.963a		85 ad						sta $ad					      STA   FAC1_1            ; save FAC1 mantissa1
5606		.963c																		LAB_24D0
5607		.963c		b0 03						bcs $9641				      BCS   LAB_24D5          ; branch if number is +ve
5609		.963e		20 a3 96				jsr $96a3				      JSR   LAB_2537          ; negate FAC1
5613		.9641																		LAB_24D5
5614		.9641		a0 00						ldy #$00				      LDY   #$00              ; clear Y
5615		.9643		98							tya							      TYA                     ; clear A
5616		.9644		18							clc							      CLC                     ; clear carry for add
5617		.9645																		LAB_24D9
5618		.9645		a6 ad						ldx $ad					      LDX   FAC1_1            ; get FAC1 mantissa1
5619		.9647		d0 3e						bne $9687				      BNE   LAB_251B          ; if not zero normalise FAC1
5621		.9649		a6 ae						ldx $ae					      LDX   FAC1_2            ; get FAC1 mantissa2
5622		.964b		86 ad						stx $ad					      STX   FAC1_1            ; save FAC1 mantissa1
5623		.964d		a6 af						ldx $af					      LDX   FAC1_3            ; get FAC1 mantissa3
5624		.964f		86 ae						stx $ae					      STX   FAC1_2            ; save FAC1 mantissa2
5625		.9651		a6 b9						ldx $b9					      LDX   FAC1_r            ; get FAC1 rounding byte
5626		.9653		86 af						stx $af					      STX   FAC1_3            ; save FAC1 mantissa3
5627		.9655		84 b9						sty $b9					      STY   FAC1_r            ; clear FAC1 rounding byte
5628		.9657		69 08						adc #$08				      ADC   #$08              ; add x to exponent offset
5629		.9659		c9 18						cmp #$18				      CMP   #$18              ; compare with $18 (max offset, all bits would be =0)
5630		.965b		d0 e8						bne $9645				      BNE   LAB_24D9          ; loop if not max
5634		.965d																		LAB_24F1
5635		.965d		a9 00						lda #$00				      LDA   #$00              ; clear A
5636		.965f																		LAB_24F3
5637		.965f		85 ac						sta $ac					      STA   FAC1_e            ; set FAC1 exponent
5641		.9661																		LAB_24F5
5642		.9661		85 b0						sta $b0					      STA   FAC1_s            ; save FAC1 sign (b7)
5643		.9663		60							rts							      RTS
5647		.9664																		LAB_24F8
5648		.9664		65 a3						adc $a3					      ADC   FAC2_r            ; add FAC2 rounding byte
5649		.9666		85 b9						sta $b9					      STA   FAC1_r            ; save FAC1 rounding byte
5650		.9668		a5 af						lda $af					      LDA   FAC1_3            ; get FAC1 mantissa3
5651		.966a		65 b6						adc $b6					      ADC   FAC2_3            ; add FAC2 mantissa3
5652		.966c		85 af						sta $af					      STA   FAC1_3            ; save FAC1 mantissa3
5653		.966e		a5 ae						lda $ae					      LDA   FAC1_2            ; get FAC1 mantissa2
5654		.9670		65 b5						adc $b5					      ADC   FAC2_2            ; add FAC2 mantissa2
5655		.9672		85 ae						sta $ae					      STA   FAC1_2            ; save FAC1 mantissa2
5656		.9674		a5 ad						lda $ad					      LDA   FAC1_1            ; get FAC1 mantissa1
5657		.9676		65 b4						adc $b4					      ADC   FAC2_1            ; add FAC2 mantissa1
5658		.9678		85 ad						sta $ad					      STA   FAC1_1            ; save FAC1 mantissa1
5659		.967a		b0 1a						bcs $9696				      BCS   LAB_252A          ; if carry then normalise FAC1 for C=1
5661		.967c		60							rts							      RTS                     ; else just exit
5663		.967d																		LAB_2511
5664		.967d		69 01						adc #$01				      ADC   #$01              ; add 1 to exponent offset
5665		.967f		06 b9						asl $b9					      ASL   FAC1_r            ; shift FAC1 rounding byte
5666		.9681		26 af						rol $af					      ROL   FAC1_3            ; shift FAC1 mantissa3
5667		.9683		26 ae						rol $ae					      ROL   FAC1_2            ; shift FAC1 mantissa2
5668		.9685		26 ad						rol $ad					      ROL   FAC1_1            ; shift FAC1 mantissa1
5672		.9687																		LAB_251B
5673		.9687		10 f4						bpl $967d				      BPL   LAB_2511          ; loop if not normalised
5675		.9689		38							sec							      SEC                     ; set carry for subtract
5676		.968a		e5 ac						sbc $ac					      SBC   FAC1_e            ; subtract FAC1 exponent
5677		.968c		b0 cf						bcs $965d				      BCS   LAB_24F1          ; branch if underflow (set result = $0)
5679		.968e		49 ff						eor #$ff				      EOR   #$FF              ; complement exponent
5680		.9690		69 01						adc #$01				      ADC   #$01              ; +1 (twos complement)
5681		.9692		85 ac						sta $ac					      STA   FAC1_e            ; save FAC1 exponent
5685		.9694																		LAB_2528
5686		.9694		90 0c						bcc $96a2				      BCC   LAB_2536          ; exit if no overflow
5690		.9696																		LAB_252A
5691		.9696		e6 ac						inc $ac					      INC   FAC1_e            ; increment FAC1 exponent
5692		.9698		f0 36						beq $96d0				      BEQ   LAB_2564          ; if zero do overflow error and warm start
5694		.969a		66 ad						ror $ad					      ROR   FAC1_1            ; shift FAC1 mantissa1
5695		.969c		66 ae						ror $ae					      ROR   FAC1_2            ; shift FAC1 mantissa2
5696		.969e		66 af						ror $af					      ROR   FAC1_3            ; shift FAC1 mantissa3
5697		.96a0		66 b9						ror $b9					      ROR   FAC1_r            ; shift FAC1 rounding byte
5698		.96a2																		LAB_2536
5699		.96a2		60							rts							      RTS
5703		.96a3																		LAB_2537
5704		.96a3		a5 b0						lda $b0					      LDA   FAC1_s            ; get FAC1 sign (b7)
5705		.96a5		49 ff						eor #$ff				      EOR   #$FF              ; complement it
5706		.96a7		85 b0						sta $b0					      STA   FAC1_s            ; save FAC1 sign (b7)
5710		.96a9																		LAB_253D
5711		.96a9		a5 ad						lda $ad					      LDA   FAC1_1            ; get FAC1 mantissa1
5712		.96ab		49 ff						eor #$ff				      EOR   #$FF              ; complement it
5713		.96ad		85 ad						sta $ad					      STA   FAC1_1            ; save FAC1 mantissa1
5714		.96af		a5 ae						lda $ae					      LDA   FAC1_2            ; get FAC1 mantissa2
5715		.96b1		49 ff						eor #$ff				      EOR   #$FF              ; complement it
5716		.96b3		85 ae						sta $ae					      STA   FAC1_2            ; save FAC1 mantissa2
5717		.96b5		a5 af						lda $af					      LDA   FAC1_3            ; get FAC1 mantissa3
5718		.96b7		49 ff						eor #$ff				      EOR   #$FF              ; complement it
5719		.96b9		85 af						sta $af					      STA   FAC1_3            ; save FAC1 mantissa3
5720		.96bb		a5 b9						lda $b9					      LDA   FAC1_r            ; get FAC1 rounding byte
5721		.96bd		49 ff						eor #$ff				      EOR   #$FF              ; complement it
5722		.96bf		85 b9						sta $b9					      STA   FAC1_r            ; save FAC1 rounding byte
5723		.96c1		e6 b9						inc $b9					      INC   FAC1_r            ; increment FAC1 rounding byte
5724		.96c3		d0 0a						bne $96cf				      BNE   LAB_2563          ; exit if no overflow
5728		.96c5																		LAB_2559
5729		.96c5		e6 af						inc $af					      INC   FAC1_3            ; increment FAC1 mantissa3
5730		.96c7		d0 06						bne $96cf				      BNE   LAB_2563          ; finished if no rollover
5732		.96c9		e6 ae						inc $ae					      INC   FAC1_2            ; increment FAC1 mantissa2
5733		.96cb		d0 02						bne $96cf				      BNE   LAB_2563          ; finished if no rollover
5735		.96cd		e6 ad						inc $ad					      INC   FAC1_1            ; increment FAC1 mantissa1
5736		.96cf																		LAB_2563
5737		.96cf		60							rts							      RTS
5741		.96d0																		LAB_2564
5742		.96d0		a2 0a						ldx #$0a				      LDX   #$0A              ; error code $0A ("Overflow" error)
5743		.96d2		4c 3f 81				jmp $813f				      JMP   LAB_XERR          ; do error #X, then warm start
5747		.96d5																		LAB_2569
5748		.96d5		a2 74						ldx #$74				      LDX   #FACt_1-1         ; set offset to FACtemp
5749		.96d7																		LAB_256B
5750		.96d7		b4 03						ldy $03,x				      LDY   PLUS_3,X          ; get FACX mantissa3
5751		.96d9		84 b9						sty $b9					      STY   FAC1_r            ; save as FAC1 rounding byte
5752		.96db		b4 02						ldy $02,x				      LDY   PLUS_2,X          ; get FACX mantissa2
5753		.96dd		94 03						sty $03,x				      STY   PLUS_3,X          ; save FACX mantissa3
5754		.96df		b4 01						ldy $01,x				      LDY   PLUS_1,X          ; get FACX mantissa1
5755		.96e1		94 02						sty $02,x				      STY   PLUS_2,X          ; save FACX mantissa2
5756		.96e3		a4 b2						ldy $b2					      LDY   FAC1_o            ; get FAC1 overflow byte
5757		.96e5		94 01						sty $01,x				      STY   PLUS_1,X          ; save FACX mantissa1
5761		.96e7																		LAB_257B
5762		.96e7		69 08						adc #$08				      ADC   #$08              ; add 8 to shift count
5763		.96e9		30 ec						bmi $96d7				      BMI   LAB_256B          ; go do 8 shift if still -ve
5765		.96eb		f0 ea						beq $96d7				      BEQ   LAB_256B          ; go do 8 shift if zero
5767		.96ed		e9 08						sbc #$08				      SBC   #$08              ; else subtract 8 again
5768		.96ef		a8							tay							      TAY                     ; save count to Y
5769		.96f0		a5 b9						lda $b9					      LDA   FAC1_r            ; get FAC1 rounding byte
5770		.96f2		b0 12						bcs $9706				      BCS   LAB_259A          ;.
5772		.96f4																		LAB_2588
5773		.96f4		16 01						asl $01,x				      ASL   PLUS_1,X          ; shift FACX mantissa1
5774		.96f6		90 02						bcc $96fa				      BCC   LAB_258E          ; branch if +ve
5776		.96f8		f6 01						inc $01,x				      INC   PLUS_1,X          ; this sets b7 eventually
5777		.96fa																		LAB_258E
5778		.96fa		76 01						ror $01,x				      ROR   PLUS_1,X          ; shift FACX mantissa1 (correct for ASL)
5779		.96fc		76 01						ror $01,x				      ROR   PLUS_1,X          ; shift FACX mantissa1 (put carry in b7)
5783		.96fe																		LAB_2592
5784		.96fe		76 02						ror $02,x				      ROR   PLUS_2,X          ; shift FACX mantissa2
5785		.9700		76 03						ror $03,x				      ROR   PLUS_3,X          ; shift FACX mantissa3
5786		.9702		6a							ror a						      ROR                     ; shift FACX rounding byte
5787		.9703		c8							iny							      INY                     ; increment exponent diff
5788		.9704		d0 ee						bne $96f4				      BNE   LAB_2588          ; branch if range adjust not complete
5790		.9706																		LAB_259A
5791		.9706		18							clc							      CLC                     ; just clear it
5792		.9707		60							rts							      RTS
5796		.9708																		LAB_LOG
5797		.9708		20 f6 98				jsr $98f6				      JSR   LAB_27CA          ; test sign and zero
5798		.970b		f0 02						beq $970f				      BEQ   LAB_25C4          ; if zero do function call error then warm start
5800		.970d		10 03						bpl $9712				      BPL   LAB_25C7          ; skip error if +ve
5802		.970f																		LAB_25C4
5803		.970f		4c 37 8f				jmp $8f37				      JMP   LAB_FCER          ; do function call error then warm start (-ve)
5805		.9712																		LAB_25C7
5806		.9712		a5 ac						lda $ac					      LDA   FAC1_e            ; get FAC1 exponent
5807		.9714		e9 7f						sbc #$7f				      SBC   #$7F              ; normalise it
5808		.9716		48							pha							      PHA                     ; save it
5809		.9717		a9 80						lda #$80				      LDA   #$80              ; set exponent to zero
5810		.9719		85 ac						sta $ac					      STA   FAC1_e            ; save FAC1 exponent
5811		.971b		a9 7a						lda #$7a				      LDA   #<LAB_25AD        ; set 1/root2 pointer low byte
5812		.971d		a0 a1						ldy #$a1				      LDY   #>LAB_25AD        ; set 1/root2 pointer high byte
5813		.971f		20 cb 95				jsr $95cb				      JSR   LAB_246C          ; add (AY) to FAC1 (1/root2)
5814		.9722		a9 7e						lda #$7e				      LDA   #<LAB_25B1        ; set root2 pointer low byte
5815		.9724		a0 a1						ldy #$a1				      LDY   #>LAB_25B1        ; set root2 pointer high byte
5816		.9726		20 0e 98				jsr $980e				      JSR   LAB_26CA          ; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
5817		.9729		a9 f1						lda #$f1				      LDA   #<LAB_259C        ; set 1 pointer low byte
5818		.972b		a0 a1						ldy #$a1				      LDY   #>LAB_259C        ; set 1 pointer high byte
5819		.972d		20 b0 95				jsr $95b0				      JSR   LAB_2455          ; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
5820		.9730		a9 6d						lda #$6d				      LDA   #<LAB_25A0        ; set pointer low byte to counter
5821		.9732		a0 a1						ldy #$a1				      LDY   #>LAB_25A0        ; set pointer high byte to counter
5822		.9734		20 5e 9c				jsr $9c5e				      JSR   LAB_2B6E          ; ^2 then series evaluation
5823		.9737		a9 82						lda #$82				      LDA   #<LAB_25B5        ; set -0.5 pointer low byte
5824		.9739		a0 a1						ldy #$a1				      LDY   #>LAB_25B5        ; set -0.5 pointer high byte
5825		.973b		20 cb 95				jsr $95cb				      JSR   LAB_246C          ; add (AY) to FAC1
5826		.973e		68							pla							      PLA                     ; restore FAC1 exponent
5827		.973f		20 52 9a				jsr $9a52				      JSR   LAB_2912          ; evaluate new ASCII digit
5828		.9742		a9 86						lda #$86				      LDA   #<LAB_25B9        ; set LOG(2) pointer low byte
5829		.9744		a0 a1						ldy #$a1				      LDY   #>LAB_25B9        ; set LOG(2) pointer high byte
5833		.9746																		LAB_25FB
5834		.9746		20 98 97				jsr $9798				      JSR   LAB_264D          ; unpack memory (AY) into FAC2
5835		.9749																		LAB_MULTIPLY
5836		.9749		f0 4c						beq $9797				      BEQ   LAB_264C          ; exit if zero
5838		.974b		20 be 97				jsr $97be				      JSR   LAB_2673          ; test and adjust accumulators
5839		.974e		a9 00						lda #$00				      LDA   #$00              ; clear A
5840		.9750		85 75						sta $75					      STA   FACt_1            ; clear temp mantissa1
5841		.9752		85 76						sta $76					      STA   FACt_2            ; clear temp mantissa2
5842		.9754		85 77						sta $77					      STA   FACt_3            ; clear temp mantissa3
5843		.9756		a5 b9						lda $b9					      LDA   FAC1_r            ; get FAC1 rounding byte
5844		.9758		20 6d 97				jsr $976d				      JSR   LAB_2622          ; go do shift/add FAC2
5845		.975b		a5 af						lda $af					      LDA   FAC1_3            ; get FAC1 mantissa3
5846		.975d		20 6d 97				jsr $976d				      JSR   LAB_2622          ; go do shift/add FAC2
5847		.9760		a5 ae						lda $ae					      LDA   FAC1_2            ; get FAC1 mantissa2
5848		.9762		20 6d 97				jsr $976d				      JSR   LAB_2622          ; go do shift/add FAC2
5849		.9765		a5 ad						lda $ad					      LDA   FAC1_1            ; get FAC1 mantissa1
5850		.9767		20 73 97				jsr $9773				      JSR   LAB_2627          ; go do shift/add FAC2
5851		.976a		4c 7b 98				jmp $987b				      JMP   LAB_273C          ; copy temp to FAC1, normalise and return
5853		.976d																		LAB_2622
5854		.976d		d0 04						bne $9773				      BNE   LAB_2627          ; branch if byte <> zero
5864		.976f		38							sec							      SEC
5865		.9770		4c d5 96				jmp $96d5				      JMP   LAB_2569          ; shift FACtemp << A+8 times
5868		.9773																		LAB_2627
5869		.9773		38							sec							      SEC                     ; set top bit (mark for 8 times)
5870		.9774		6a							ror a						      ROR
5872		.9775																		LAB_262A
5873		.9775		a8							tay							      TAY                     ; copy result
5874		.9776		90 13						bcc $978b				      BCC   LAB_2640          ; skip next if bit was zero
5876		.9778		18							clc							      CLC                     ; clear carry for add
5877		.9779		a5 77						lda $77					      LDA   FACt_3            ; get temp mantissa3
5878		.977b		65 b6						adc $b6					      ADC   FAC2_3            ; add FAC2 mantissa3
5879		.977d		85 77						sta $77					      STA   FACt_3            ; save temp mantissa3
5880		.977f		a5 76						lda $76					      LDA   FACt_2            ; get temp mantissa2
5881		.9781		65 b5						adc $b5					      ADC   FAC2_2            ; add FAC2 mantissa2
5882		.9783		85 76						sta $76					      STA   FACt_2            ; save temp mantissa2
5883		.9785		a5 75						lda $75					      LDA   FACt_1            ; get temp mantissa1
5884		.9787		65 b4						adc $b4					      ADC   FAC2_1            ; add FAC2 mantissa1
5885		.9789		85 75						sta $75					      STA   FACt_1            ; save temp mantissa1
5886		.978b																		LAB_2640
5887		.978b		66 75						ror $75					      ROR   FACt_1            ; shift temp mantissa1
5888		.978d		66 76						ror $76					      ROR   FACt_2            ; shift temp mantissa2
5889		.978f		66 77						ror $77					      ROR   FACt_3            ; shift temp mantissa3
5890		.9791		66 b9						ror $b9					      ROR   FAC1_r            ; shift temp rounding byte
5891		.9793		98							tya							      TYA                     ; get byte back
5892		.9794		4a							lsr a						      LSR                     ; shift byte
5893		.9795		d0 de						bne $9775				      BNE   LAB_262A          ; loop if all bits not done
5895		.9797																		LAB_264C
5896		.9797		60							rts							      RTS
5900		.9798																		LAB_264D
5901		.9798		85 71						sta $71					      STA   ut1_pl            ; save pointer low byte
5902		.979a		84 72						sty $72					      STY   ut1_ph            ; save pointer high byte
5903		.979c		a0 03						ldy #$03				      LDY   #$03              ; 4 bytes to get (0-3)
5904		.979e		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get mantissa3
5905		.97a0		85 b6						sta $b6					      STA   FAC2_3            ; save FAC2 mantissa3
5906		.97a2		88							dey							      DEY                     ; decrement index
5907		.97a3		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get mantissa2
5908		.97a5		85 b5						sta $b5					      STA   FAC2_2            ; save FAC2 mantissa2
5909		.97a7		88							dey							      DEY                     ; decrement index
5910		.97a8		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get mantissa1+sign
5911		.97aa		85 b7						sta $b7					      STA   FAC2_s            ; save FAC2 sign (b7)
5912		.97ac		45 b0						eor $b0					      EOR   FAC1_s            ; EOR with FAC1 sign (b7)
5913		.97ae		85 b8						sta $b8					      STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
5914		.97b0		a5 b7						lda $b7					      LDA   FAC2_s            ; recover FAC2 sign (b7)
5915		.97b2		09 80						ora #$80				      ORA   #$80              ; set 1xxx xxx (set normal bit)
5916		.97b4		85 b4						sta $b4					      STA   FAC2_1            ; save FAC2 mantissa1
5917		.97b6		88							dey							      DEY                     ; decrement index
5918		.97b7		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get exponent byte
5919		.97b9		85 b3						sta $b3					      STA   FAC2_e            ; save FAC2 exponent
5920		.97bb		a5 ac						lda $ac					      LDA   FAC1_e            ; get FAC1 exponent
5921		.97bd		60							rts							      RTS
5925		.97be																		LAB_2673
5926		.97be		a5 b3						lda $b3					      LDA   FAC2_e            ; get FAC2 exponent
5927		.97c0																		LAB_2675
5928		.97c0		f0 1d						beq $97df				      BEQ   LAB_2696          ; branch if FAC2 = $00 (handle underflow)
5930		.97c2		18							clc							      CLC                     ; clear carry for add
5931		.97c3		65 ac						adc $ac					      ADC   FAC1_e            ; add FAC1 exponent
5932		.97c5		90 04						bcc $97cb				      BCC   LAB_2680          ; branch if sum of exponents <$0100
5934		.97c7		30 31						bmi $97fa				      BMI   LAB_269B          ; do overflow error
5936		.97c9		18							clc							      CLC                     ; clear carry for the add
5937		>97ca		2c															      .byte $2C               ; makes next line BIT $1410
5938		.97cb																		LAB_2680
5939		.97cb		10 12						bpl $97df				      BPL   LAB_2696          ; if +ve go handle underflow
5941		.97cd		69 80						adc #$80				      ADC   #$80              ; adjust exponent
5942		.97cf		85 ac						sta $ac					      STA   FAC1_e            ; save FAC1 exponent
5943		.97d1		d0 03						bne $97d6				      BNE   LAB_268B          ; branch if not zero
5945		.97d3		4c 61 96				jmp $9661				      JMP   LAB_24F5          ; save FAC1 sign and return
5947		.97d6																		LAB_268B
5948		.97d6		a5 b8						lda $b8					      LDA   FAC_sc            ; get sign compare (FAC1 EOR FAC2)
5949		.97d8		85 b0						sta $b0					      STA   FAC1_s            ; save FAC1 sign (b7)
5950		.97da																		LAB_268F
5951		.97da		60							rts							      RTS
5955		.97db																		LAB_2690
5956		.97db		a5 b0						lda $b0					      LDA   FAC1_s            ; get FAC1 sign (b7)
5957		.97dd		10 1b						bpl $97fa				      BPL   LAB_269B          ; do overflow error
5960		.97df																		LAB_2696
5961		.97df		68							pla							      PLA                     ; pop return address low byte
5962		.97e0		68							pla							      PLA                     ; pop return address high byte
5963		.97e1		4c 5d 96				jmp $965d				      JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
5967		.97e4																		LAB_269E
5968		.97e4		20 d7 98				jsr $98d7				      JSR   LAB_27AB          ; round and copy FAC1 to FAC2
5969		.97e7		aa							tax							      TAX                     ; copy exponent (set the flags)
5970		.97e8		f0 f0						beq $97da				      BEQ   LAB_268F          ; exit if zero
5972		.97ea		18							clc							      CLC                     ; clear carry for add
5973		.97eb		69 02						adc #$02				      ADC   #$02              ; add two to exponent (*4)
5974		.97ed		b0 0b						bcs $97fa				      BCS   LAB_269B          ; do overflow error if > $FF
5976		.97ef		a2 00						ldx #$00				      LDX   #$00              ; clear byte
5977		.97f1		86 b8						stx $b8					      STX   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
5978		.97f3		20 e8 95				jsr $95e8				      JSR   LAB_247C          ; add FAC2 to FAC1 (*5)
5979		.97f6		e6 ac						inc $ac					      INC   FAC1_e            ; increment FAC1 exponent (*10)
5980		.97f8		d0 e0						bne $97da				      BNE   LAB_268F          ; if non zero just do RTS
5982		.97fa																		LAB_269B
5983		.97fa		4c d0 96				jmp $96d0				      JMP   LAB_2564          ; do overflow error and warm start
5987		.97fd																		LAB_26B9
5988		.97fd		20 d7 98				jsr $98d7				      JSR   LAB_27AB          ; round and copy FAC1 to FAC2
5989		.9800		a9 02						lda #$02				      LDA   #<LAB_26B5        ; set pointer to 10d low addr
5990		.9802		a0 a2						ldy #$a2				      LDY   #>LAB_26B5        ; set pointer to 10d high addr
5991		.9804		a2 00						ldx #$00				      LDX   #$00              ; clear sign
5995		.9806																		LAB_26C2
5996		.9806		86 b8						stx $b8					      STX   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
5997		.9808		20 8a 98				jsr $988a				      JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
5998		.980b		4c 11 98				jmp $9811				      JMP   LAB_DIVIDE        ; do FAC2/FAC1
6003		.980e																		LAB_26CA
6004		.980e		20 98 97				jsr $9798				      JSR   LAB_264D          ; unpack memory (AY) into FAC2
6007		.9811																		LAB_DIVIDE
6008		.9811		f0 63						beq $9876				      BEQ   LAB_2737          ; if zero go do /0 error
6010		.9813		20 e6 98				jsr $98e6				      JSR   LAB_27BA          ; round FAC1
6011		.9816		a9 00						lda #$00				      LDA   #$00              ; clear A
6012		.9818		38							sec							      SEC                     ; set carry for subtract
6013		.9819		e5 ac						sbc $ac					      SBC   FAC1_e            ; subtract FAC1 exponent (2s complement)
6014		.981b		85 ac						sta $ac					      STA   FAC1_e            ; save FAC1 exponent
6015		.981d		20 be 97				jsr $97be				      JSR   LAB_2673          ; test and adjust accumulators
6016		.9820		e6 ac						inc $ac					      INC   FAC1_e            ; increment FAC1 exponent
6017		.9822		f0 d6						beq $97fa				      BEQ   LAB_269B          ; if zero do overflow error
6019		.9824		a2 ff						ldx #$ff				      LDX   #$FF              ; set index for pre increment
6020		.9826		a9 01						lda #$01				      LDA   #$01              ; set bit to flag byte save
6021		.9828																		LAB_26E4
6022		.9828		a4 b4						ldy $b4					      LDY   FAC2_1            ; get FAC2 mantissa1
6023		.982a		c4 ad						cpy $ad					      CPY   FAC1_1            ; compare FAC1 mantissa1
6024		.982c		d0 0a						bne $9838				      BNE   LAB_26F4          ; branch if <>
6026		.982e		a4 b5						ldy $b5					      LDY   FAC2_2            ; get FAC2 mantissa2
6027		.9830		c4 ae						cpy $ae					      CPY   FAC1_2            ; compare FAC1 mantissa2
6028		.9832		d0 04						bne $9838				      BNE   LAB_26F4          ; branch if <>
6030		.9834		a4 b6						ldy $b6					      LDY   FAC2_3            ; get FAC2 mantissa3
6031		.9836		c4 af						cpy $af					      CPY   FAC1_3            ; compare FAC1 mantissa3
6032		.9838																		LAB_26F4
6033		.9838		08							php							      PHP                     ; save FAC2-FAC1 compare status
6034		.9839		2a							rol a						      ROL                     ; shift the result byte
6035		.983a		90 0e						bcc $984a				      BCC   LAB_2702          ; if no carry skip the byte save
6037		.983c		a0 01						ldy #$01				      LDY   #$01              ; set bit to flag byte save
6038		.983e		e8							inx							      INX                     ; else increment the index to FACt
6039		.983f		e0 02						cpx #$02				      CPX   #$02              ; compare with the index to FACt_3
6040		.9841		30 04						bmi $9847				      BMI   LAB_2701          ; if not last byte just go save it
6042		.9843		d0 28						bne $986d				      BNE   LAB_272B          ; if all done go save FAC1 rounding byte, normalise and
6045		.9845		a0 40						ldy #$40				      LDY   #$40              ; set bit to flag byte save for the rounding byte
6046		.9847																		LAB_2701
6047		.9847		95 75						sta $75,x				      STA   FACt_1,X          ; write result byte to FACt_1 + index
6048		.9849		98							tya							      TYA                     ; copy the next save byte flag
6049		.984a																		LAB_2702
6050		.984a		28							plp							      PLP                     ; restore FAC2-FAC1 compare status
6051		.984b		90 14						bcc $9861				      BCC   LAB_2704          ; if FAC2 < FAC1 then skip the subtract
6053		.984d		a8							tay							      TAY                     ; save FAC2-FAC1 compare status
6054		.984e		a5 b6						lda $b6					      LDA   FAC2_3            ; get FAC2 mantissa3
6055		.9850		e5 af						sbc $af					      SBC   FAC1_3            ; subtract FAC1 mantissa3
6056		.9852		85 b6						sta $b6					      STA   FAC2_3            ; save FAC2 mantissa3
6057		.9854		a5 b5						lda $b5					      LDA   FAC2_2            ; get FAC2 mantissa2
6058		.9856		e5 ae						sbc $ae					      SBC   FAC1_2            ; subtract FAC1 mantissa2
6059		.9858		85 b5						sta $b5					      STA   FAC2_2            ; save FAC2 mantissa2
6060		.985a		a5 b4						lda $b4					      LDA   FAC2_1            ; get FAC2 mantissa1
6061		.985c		e5 ad						sbc $ad					      SBC   FAC1_1            ; subtract FAC1 mantissa1
6062		.985e		85 b4						sta $b4					      STA   FAC2_1            ; save FAC2 mantissa1
6063		.9860		98							tya							      TYA                     ; restore FAC2-FAC1 compare status
6066		.9861																		LAB_2704
6067		.9861		06 b6						asl $b6					      ASL   FAC2_3            ; shift FAC2 mantissa3
6068		.9863		26 b5						rol $b5					      ROL   FAC2_2            ; shift FAC2 mantissa2
6069		.9865		26 b4						rol $b4					      ROL   FAC2_1            ; shift FAC2 mantissa1
6070		.9867		b0 cf						bcs $9838				      BCS   LAB_26F4          ; loop with no compare
6072		.9869		30 bd						bmi $9828				      BMI   LAB_26E4          ; loop with compare
6074		.986b		10 cb						bpl $9838				      BPL   LAB_26F4          ; loop always with no compare
6078		.986d																		LAB_272B
6079		.986d		4a							lsr a						      LSR                     ; shift b1 - b0 ..
6080		.986e		6a							ror a						      ROR                     ; ..
6081		.986f		6a							ror a						      ROR                     ; .. to b7 - b6
6082		.9870		85 b9						sta $b9					      STA   FAC1_r            ; save FAC1 rounding byte
6083		.9872		28							plp							      PLP                     ; dump FAC2-FAC1 compare status
6084		.9873		4c 7b 98				jmp $987b				      JMP   LAB_273C          ; copy temp to FAC1, normalise and return
6088		.9876																		LAB_2737
6089		.9876		a2 14						ldx #$14				      LDX   #$14              ; error code $14 ("Divide by zero" error)
6090		.9878		4c 3f 81				jmp $813f				      JMP   LAB_XERR          ; do error #X, then warm start
6094		.987b																		LAB_273C
6095		.987b		a5 75						lda $75					      LDA   FACt_1            ; get temp mantissa1
6096		.987d		85 ad						sta $ad					      STA   FAC1_1            ; save FAC1 mantissa1
6097		.987f		a5 76						lda $76					      LDA   FACt_2            ; get temp mantissa2
6098		.9881		85 ae						sta $ae					      STA   FAC1_2            ; save FAC1 mantissa2
6099		.9883		a5 77						lda $77					      LDA   FACt_3            ; get temp mantissa3
6100		.9885		85 af						sta $af					      STA   FAC1_3            ; save FAC1 mantissa3
6101		.9887		4c 41 96				jmp $9641				      JMP   LAB_24D5          ; normalise FAC1 and return
6105		.988a																		LAB_UFAC
6106		.988a		85 71						sta $71					      STA   ut1_pl            ; save pointer low byte
6107		.988c		84 72						sty $72					      STY   ut1_ph            ; save pointer high byte
6108		.988e		a0 03						ldy #$03				      LDY   #$03              ; 4 bytes to do
6109		.9890		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get last byte
6110		.9892		85 af						sta $af					      STA   FAC1_3            ; save FAC1 mantissa3
6111		.9894		88							dey							      DEY                     ; decrement index
6112		.9895		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get last-1 byte
6113		.9897		85 ae						sta $ae					      STA   FAC1_2            ; save FAC1 mantissa2
6114		.9899		88							dey							      DEY                     ; decrement index
6115		.989a		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get second byte
6116		.989c		85 b0						sta $b0					      STA   FAC1_s            ; save FAC1 sign (b7)
6117		.989e		09 80						ora #$80				      ORA   #$80              ; set 1xxx xxxx (add normal bit)
6118		.98a0		85 ad						sta $ad					      STA   FAC1_1            ; save FAC1 mantissa1
6119		.98a2		88							dey							      DEY                     ; decrement index
6120		.98a3		b1 71						lda ($71),y			      LDA   (ut1_pl),Y        ; get first byte (exponent)
6121		.98a5		85 ac						sta $ac					      STA   FAC1_e            ; save FAC1 exponent
6122		.98a7		84 b9						sty $b9					      STY   FAC1_r            ; clear FAC1 rounding byte
6123		.98a9		60							rts							      RTS
6127		.98aa																		LAB_276E
6128		.98aa		a2 a4						ldx #$a4				      LDX   #<Adatal          ; set pointer low byte
6129		.98ac																		LAB_2770
6130		.98ac		a0 00						ldy #$00				      LDY   #>Adatal          ; set pointer high byte
6131		.98ae		f0 04						beq $98b4				      BEQ   LAB_2778          ; pack FAC1 into (XY) and return
6135		.98b0																		LAB_PFAC
6136		.98b0		a6 97						ldx $97					      LDX   Lvarpl            ; get destination pointer low byte
6137		.98b2		a4 98						ldy $98					      LDY   Lvarph            ; get destination pointer high byte
6141		.98b4																		LAB_2778
6142		.98b4		20 e6 98				jsr $98e6				      JSR   LAB_27BA          ; round FAC1
6143		.98b7		86 71						stx $71					      STX   ut1_pl            ; save pointer low byte
6144		.98b9		84 72						sty $72					      STY   ut1_ph            ; save pointer high byte
6145		.98bb		a0 03						ldy #$03				      LDY   #$03              ; set index
6146		.98bd		a5 af						lda $af					      LDA   FAC1_3            ; get FAC1 mantissa3
6147		.98bf		91 71						sta ($71),y			      STA   (ut1_pl),Y        ; store in destination
6148		.98c1		88							dey							      DEY                     ; decrement index
6149		.98c2		a5 ae						lda $ae					      LDA   FAC1_2            ; get FAC1 mantissa2
6150		.98c4		91 71						sta ($71),y			      STA   (ut1_pl),Y        ; store in destination
6151		.98c6		88							dey							      DEY                     ; decrement index
6152		.98c7		a5 b0						lda $b0					      LDA   FAC1_s            ; get FAC1 sign (b7)
6153		.98c9		09 7f						ora #$7f				      ORA   #$7F              ; set bits x111 1111
6154		.98cb		25 ad						and $ad					      AND   FAC1_1            ; AND in FAC1 mantissa1
6155		.98cd		91 71						sta ($71),y			      STA   (ut1_pl),Y        ; store in destination
6156		.98cf		88							dey							      DEY                     ; decrement index
6157		.98d0		a5 ac						lda $ac					      LDA   FAC1_e            ; get FAC1 exponent
6158		.98d2		91 71						sta ($71),y			      STA   (ut1_pl),Y        ; store in destination
6159		.98d4		84 b9						sty $b9					      STY   FAC1_r            ; clear FAC1 rounding byte
6160		.98d6		60							rts							      RTS
6164		.98d7																		LAB_27AB
6165		.98d7		20 e6 98				jsr $98e6				      JSR   LAB_27BA          ; round FAC1
6169		.98da																		LAB_27AE
6170		.98da		a2 05						ldx #$05				      LDX   #$05              ; 5 bytes to copy
6171		.98dc																		LAB_27B0
6172		.98dc		b5 ab						lda $ab,x				      LDA   FAC1_e-1,X        ; get byte from FAC1,X
6173		.98de		95 b2						sta $b2,x				      STA   FAC1_o,X          ; save byte at FAC2,X
6174		.98e0		ca							dex							      DEX                     ; decrement count
6175		.98e1		d0 f9						bne $98dc				      BNE   LAB_27B0          ; loop if not all done
6177		.98e3		86 b9						stx $b9					      STX   FAC1_r            ; clear FAC1 rounding byte
6178		.98e5																		LAB_27B9
6179		.98e5		60							rts							      RTS
6183		.98e6																		LAB_27BA
6184		.98e6		a5 ac						lda $ac					      LDA   FAC1_e            ; get FAC1 exponent
6185		.98e8		f0 fb						beq $98e5				      BEQ   LAB_27B9          ; exit if zero
6187		.98ea		06 b9						asl $b9					      ASL   FAC1_r            ; shift FAC1 rounding byte
6188		.98ec		90 f7						bcc $98e5				      BCC   LAB_27B9          ; exit if no overflow
6192		.98ee																		LAB_27C2
6193		.98ee		20 c5 96				jsr $96c5				      JSR   LAB_2559          ; increment FAC1 mantissa
6194		.98f1		d0 f2						bne $98e5				      BNE   LAB_27B9          ; branch if no overflow
6196		.98f3		4c 96 96				jmp $9696				      JMP   LAB_252A          ; normalise FAC1 for C=1 and return
6201		.98f6																		LAB_27CA
6202		.98f6		a5 ac						lda $ac					      LDA   FAC1_e            ; get FAC1 exponent
6203		.98f8		f0 09						beq $9903				      BEQ   LAB_27D7          ; exit if zero (already correct SGN(0)=0)
6208		.98fa																		LAB_27CE
6209		.98fa		a5 b0						lda $b0					      LDA   FAC1_s            ; else get FAC1 sign (b7)
6214		.98fc																		LAB_27D0
6215		.98fc		2a							rol a						      ROL                     ; move sign bit to carry
6216		.98fd		a9 ff						lda #$ff				      LDA   #$FF              ; set byte for -ve result
6217		.98ff		b0 02						bcs $9903				      BCS   LAB_27D7          ; return if sign was set (-ve)
6219		.9901		a9 01						lda #$01				      LDA   #$01              ; else set byte for +ve result
6220		.9903																		LAB_27D7
6221		.9903		60							rts							      RTS
6225		.9904																		LAB_SGN
6226		.9904		20 f6 98				jsr $98f6				      JSR   LAB_27CA          ; get FAC1 sign
6230		.9907																		LAB_27DB
6231		.9907		85 ad						sta $ad					      STA   FAC1_1            ; save FAC1 mantissa1
6232		.9909		a9 00						lda #$00				      LDA   #$00              ; clear A
6233		.990b		85 ae						sta $ae					      STA   FAC1_2            ; clear FAC1 mantissa2
6234		.990d		a2 88						ldx #$88				      LDX   #$88              ; set exponent
6238		.990f																		LAB_27E3
6239		.990f		a5 ad						lda $ad					      LDA   FAC1_1            ; get FAC1 mantissa1
6240		.9911		49 ff						eor #$ff				      EOR   #$FF              ; complement it
6241		.9913		2a							rol a						      ROL                     ; sign bit into carry
6245		.9914																		LAB_STFA
6246		.9914		a9 00						lda #$00				      LDA   #$00              ; clear A
6247		.9916		85 af						sta $af					      STA   FAC1_3            ; clear FAC1 mantissa3
6248		.9918		86 ac						stx $ac					      STX   FAC1_e            ; set FAC1 exponent
6249		.991a		85 b9						sta $b9					      STA   FAC1_r            ; clear FAC1 rounding byte
6250		.991c		85 b0						sta $b0					      STA   FAC1_s            ; clear FAC1 sign (b7)
6251		.991e		4c 3c 96				jmp $963c				      JMP   LAB_24D0          ; do ABS and normalise FAC1
6255		.9921																		LAB_ABS
6256		.9921		46 b0						lsr $b0					      LSR   FAC1_s            ; clear FAC1 sign (put zero in b7)
6257		.9923		60							rts							      RTS
6264		.9924																		LAB_27F8
6265		.9924		85 73						sta $73					      STA   ut2_pl            ; save pointer low byte
6266		.9926																		LAB_27FA
6267		.9926		84 74						sty $74					      STY   ut2_ph            ; save pointer high byte
6268		.9928		a0 00						ldy #$00				      LDY   #$00              ; clear index
6269		.992a		b1 73						lda ($73),y			      LDA   (ut2_pl),Y        ; get exponent
6270		.992c		c8							iny							      INY                     ; increment index
6271		.992d		aa							tax							      TAX                     ; copy (AY) exponent to X
6272		.992e		f0 c6						beq $98f6				      BEQ   LAB_27CA          ; branch if (AY) exponent=0 and get FAC1 sign
6275		.9930		b1 73						lda ($73),y			      LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
6276		.9932		45 b0						eor $b0					      EOR   FAC1_s            ; EOR FAC1 sign (b7)
6277		.9934		30 c4						bmi $98fa				      BMI   LAB_27CE          ; if signs <> do return A=FF,C=1/-ve
6280		.9936		e4 ac						cpx $ac					      CPX   FAC1_e            ; compare (AY) exponent with FAC1 exponent
6281		.9938		d0 1a						bne $9954				      BNE   LAB_2828          ; branch if different
6283		.993a		b1 73						lda ($73),y			      LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
6284		.993c		09 80						ora #$80				      ORA   #$80              ; normalise top bit
6285		.993e		c5 ad						cmp $ad					      CMP   FAC1_1            ; compare with FAC1 mantissa1
6286		.9940		d0 12						bne $9954				      BNE   LAB_2828          ; branch if different
6288		.9942		c8							iny							      INY                     ; increment index
6289		.9943		b1 73						lda ($73),y			      LDA   (ut2_pl),Y        ; get mantissa2
6290		.9945		c5 ae						cmp $ae					      CMP   FAC1_2            ; compare with FAC1 mantissa2
6291		.9947		d0 0b						bne $9954				      BNE   LAB_2828          ; branch if different
6293		.9949		c8							iny							      INY                     ; increment index
6294		.994a		a9 7f						lda #$7f				      LDA   #$7F              ; set for 1/2 value rounding byte
6295		.994c		c5 b9						cmp $b9					      CMP   FAC1_r            ; compare with FAC1 rounding byte (set carry)
6296		.994e		b1 73						lda ($73),y			      LDA   (ut2_pl),Y        ; get mantissa3
6297		.9950		e5 af						sbc $af					      SBC   FAC1_3            ; subtract FAC1 mantissa3
6298		.9952		f0 28						beq $997c				      BEQ   LAB_2850          ; exit if mantissa3 equal
6302		.9954																		LAB_2828
6303		.9954		a5 b0						lda $b0					      LDA   FAC1_s            ; get FAC1 sign (b7)
6304		.9956		90 02						bcc $995a				      BCC   LAB_282E          ; branch if FAC1 > (AY)
6306		.9958		49 ff						eor #$ff				      EOR   #$FF              ; else toggle FAC1 sign
6307		.995a																		LAB_282E
6308		.995a		4c fc 98				jmp $98fc				      JMP   LAB_27D0          ; return A=FF,C=1/-ve A=01,C=0/+ve
6312		.995d																		LAB_2831
6313		.995d		a5 ac						lda $ac					      LDA   FAC1_e            ; get FAC1 exponent
6314		.995f		f0 4a						beq $99ab				      BEQ   LAB_287F          ; if zero go clear FAC1 and return
6316		.9961		38							sec							      SEC                     ; set carry for subtract
6317		.9962		e9 98						sbc #$98				      SBC   #$98              ; subtract maximum integer range exponent
6318		.9964		24 b0						bit $b0					      BIT   FAC1_s            ; test FAC1 sign (b7)
6319		.9966		10 09						bpl $9971				      BPL   LAB_2845          ; branch if FAC1 +ve
6322		.9968		aa							tax							      TAX                     ; copy subtracted exponent
6323		.9969		a9 ff						lda #$ff				      LDA   #$FF              ; overflow for -ve number
6324		.996b		85 b2						sta $b2					      STA   FAC1_o            ; set FAC1 overflow byte
6325		.996d		20 a9 96				jsr $96a9				      JSR   LAB_253D          ; twos complement FAC1 mantissa
6326		.9970		8a							txa							      TXA                     ; restore subtracted exponent
6327		.9971																		LAB_2845
6328		.9971		a2 ac						ldx #$ac				      LDX   #FAC1_e           ; set index to FAC1
6329		.9973		c9 f9						cmp #$f9				      CMP   #$F9              ; compare exponent result
6330		.9975		10 06						bpl $997d				      BPL   LAB_2851          ; if < 8 shifts shift FAC1 A times right and return
6332		.9977		20 e7 96				jsr $96e7				      JSR   LAB_257B          ; shift FAC1 A times right (> 8 shifts)
6333		.997a		84 b2						sty $b2					      STY   FAC1_o            ; clear FAC1 overflow byte
6334		.997c																		LAB_2850
6335		.997c		60							rts							      RTS
6339		.997d																		LAB_2851
6340		.997d		a8							tay							      TAY                     ; copy shift count
6341		.997e		a5 b0						lda $b0					      LDA   FAC1_s            ; get FAC1 sign (b7)
6342		.9980		29 80						and #$80				      AND   #$80              ; mask sign bit only (x000 0000)
6343		.9982		46 ad						lsr $ad					      LSR   FAC1_1            ; shift FAC1 mantissa1
6344		.9984		05 ad						ora $ad					      ORA   FAC1_1            ; OR sign in b7 FAC1 mantissa1
6345		.9986		85 ad						sta $ad					      STA   FAC1_1            ; save FAC1 mantissa1
6346		.9988		20 fe 96				jsr $96fe				      JSR   LAB_2592          ; shift FAC1 Y times right
6347		.998b		84 b2						sty $b2					      STY   FAC1_o            ; clear FAC1 overflow byte
6348		.998d		60							rts							      RTS
6352		.998e																		LAB_INT
6353		.998e		a5 ac						lda $ac					      LDA   FAC1_e            ; get FAC1 exponent
6354		.9990		c9 98						cmp #$98				      CMP   #$98              ; compare with max int
6355		.9992		b0 1e						bcs $99b2				      BCS   LAB_2886          ; exit if >= (already int, too big for fractional part!)
6357		.9994		20 5d 99				jsr $995d				      JSR   LAB_2831          ; convert FAC1 floating-to-fixed
6358		.9997		84 b9						sty $b9					      STY   FAC1_r            ; save FAC1 rounding byte
6359		.9999		a5 b0						lda $b0					      LDA   FAC1_s            ; get FAC1 sign (b7)
6360		.999b		84 b0						sty $b0					      STY   FAC1_s            ; save FAC1 sign (b7)
6361		.999d		49 80						eor #$80				      EOR   #$80              ; toggle FAC1 sign
6362		.999f		2a							rol a						      ROL                     ; shift into carry
6363		.99a0		a9 98						lda #$98				      LDA   #$98              ; set new exponent
6364		.99a2		85 ac						sta $ac					      STA   FAC1_e            ; save FAC1 exponent
6365		.99a4		a5 af						lda $af					      LDA   FAC1_3            ; get FAC1 mantissa3
6366		.99a6		85 5b						sta $5b					      STA   Temp3             ; save for EXP() function
6367		.99a8		4c 3c 96				jmp $963c				      JMP   LAB_24D0          ; do ABS and normalise FAC1
6371		.99ab																		LAB_287F
6372		.99ab		85 ad						sta $ad					      STA   FAC1_1            ; clear FAC1 mantissa1
6373		.99ad		85 ae						sta $ae					      STA   FAC1_2            ; clear FAC1 mantissa2
6374		.99af		85 af						sta $af					      STA   FAC1_3            ; clear FAC1 mantissa3
6375		.99b1		a8							tay							      TAY                     ; clear Y
6376		.99b2																		LAB_2886
6377		.99b2		60							rts							      RTS
6383		.99b3																		LAB_2887
6384		.99b3		a0 00						ldy #$00				      LDY   #$00              ; clear Y
6385		.99b5		84 5f						sty $5f					      STY   Dtypef            ; clear data type flag, $FF=string, $00=numeric
6386		.99b7		a2 09						ldx #$09				      LDX   #$09              ; set index
6387		.99b9																		LAB_288B
6388		.99b9		94 a8						sty $a8,x				      STY   numexp,X          ; clear byte
6389		.99bb		ca							dex							      DEX                     ; decrement index
6390		.99bc		10 fb						bpl $99b9				      BPL   LAB_288B          ; loop until numexp to negnum (and FAC1) = $00
6392		.99be		90 7f						bcc $9a3f				      BCC   LAB_28FE          ; branch if 1st character numeric
6396		.99c0		c9 2d						cmp #$2d				      CMP   #'-'              ; else compare with "-"
6397		.99c2		d0 04						bne $99c8				      BNE   LAB_289A          ; branch if not "-"
6399		.99c4		86 b1						stx $b1					      STX   negnum            ; set flag for -ve number (X = $FF)
6400		.99c6		f0 04						beq $99cc				      BEQ   LAB_289C          ; branch always (go scan and check for hex/bin)
6404		.99c8																		LAB_289A
6405		.99c8		c9 2b						cmp #$2b				      CMP   #'+'              ; else compare with "+"
6406		.99ca		d0 05						bne $99d1				      BNE   LAB_289D          ; branch if not "+" (go check for hex/bin)
6410		.99cc																		LAB_289C
6411		.99cc		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment and scan memory
6412		.99cf		90 6e						bcc $9a3f				      BCC   LAB_28FE          ; branch if numeric character
6416		.99d1																		LAB_289D
6417		.99d1		c9 24						cmp #$24				      CMP   #'$'              ; else compare with "$"
6418		.99d3		d0 03						bne $99d8				      BNE   LAB_NHEX          ; branch if not "$"
6420		.99d5		4c 7d 9e				jmp $9e7d				      JMP   LAB_CHEX          ; branch if "$"
6422		.99d8																		LAB_NHEX
6423		.99d8		c9 25						cmp #$25				      CMP   #'%'              ; else compare with "%"
6424		.99da		d0 08						bne $99e4				      BNE   LAB_28A3          ; branch if not "%" (continue original code)
6426		.99dc		4c ab 9e				jmp $9eab				      JMP   LAB_CBIN          ; branch if "%"
6428		.99df																		LAB_289E
6429		.99df		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment and scan memory (ignore + or get next number)
6430		.99e2																		LAB_28A1
6431		.99e2		90 5b						bcc $9a3f				      BCC   LAB_28FE          ; branch if numeric character
6435		.99e4																		LAB_28A3
6436		.99e4		c9 2e						cmp #$2e				      CMP   #'.'              ; else compare with "."
6437		.99e6		f0 2e						beq $9a16				      BEQ   LAB_28D5          ; branch if "."
6441		.99e8		c9 45						cmp #$45				      CMP   #'E'              ; else compare with "E"
6442		.99ea		d0 30						bne $9a1c				      BNE   LAB_28DB          ; branch if not "E"
6445		.99ec		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment and scan memory
6446		.99ef		90 17						bcc $9a08				      BCC   LAB_28C7          ; branch if numeric character
6448		.99f1		c9 b7						cmp #$b7				      CMP   #TK_MINUS         ; else compare with token for -
6449		.99f3		f0 0e						beq $9a03				      BEQ   LAB_28C2          ; branch if token for -
6451		.99f5		c9 2d						cmp #$2d				      CMP   #'-'              ; else compare with "-"
6452		.99f7		f0 0a						beq $9a03				      BEQ   LAB_28C2          ; branch if "-"
6454		.99f9		c9 b6						cmp #$b6				      CMP   #TK_PLUS          ; else compare with token for +
6455		.99fb		f0 08						beq $9a05				      BEQ   LAB_28C4          ; branch if token for +
6457		.99fd		c9 2b						cmp #$2b				      CMP   #'+'              ; else compare with "+"
6458		.99ff		f0 04						beq $9a05				      BEQ   LAB_28C4          ; branch if "+"
6460		.9a01		d0 07						bne $9a0a				      BNE   LAB_28C9          ; branch always
6462		.9a03																		LAB_28C2
6463		.9a03		66 ab						ror $ab					      ROR   expneg            ; set exponent -ve flag (C, which=1, into b7)
6464		.9a05																		LAB_28C4
6465		.9a05		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment and scan memory
6466		.9a08																		LAB_28C7
6467		.9a08		90 5b						bcc $9a65				      BCC   LAB_2925          ; branch if numeric character
6469		.9a0a																		LAB_28C9
6470		.9a0a		24 ab						bit $ab					      BIT   expneg            ; test exponent -ve flag
6471		.9a0c		10 0e						bpl $9a1c				      BPL   LAB_28DB          ; if +ve go evaluate exponent
6474		.9a0e		a9 00						lda #$00				      LDA   #$00              ; clear result
6475		.9a10		38							sec							      SEC                     ; set carry for subtract
6476		.9a11		e5 a9						sbc $a9					      SBC   expcnt            ; subtract exponent byte
6477		.9a13		4c 1e 9a				jmp $9a1e				      JMP   LAB_28DD          ; go evaluate exponent
6479		.9a16																		LAB_28D5
6480		.9a16		66 aa						ror $aa					      ROR   numdpf            ; set decimal point flag
6481		.9a18		24 aa						bit $aa					      BIT   numdpf            ; test decimal point flag
6482		.9a1a		50 c3						bvc $99df				      BVC   LAB_289E          ; branch if only one decimal point so far
6485		.9a1c																		LAB_28DB
6486		.9a1c		a5 a9						lda $a9					      LDA   expcnt            ; get exponent count byte
6487		.9a1e																		LAB_28DD
6488		.9a1e		38							sec							      SEC                     ; set carry for subtract
6489		.9a1f		e5 a8						sbc $a8					      SBC   numexp            ; subtract numerator exponent
6490		.9a21		85 a9						sta $a9					      STA   expcnt            ; save exponent count byte
6491		.9a23		f0 12						beq $9a37				      BEQ   LAB_28F6          ; branch if no adjustment
6493		.9a25		10 09						bpl $9a30				      BPL   LAB_28EF          ; else if +ve go do FAC1*10^expcnt
6496		.9a27																		LAB_28E6
6497		.9a27		20 fd 97				jsr $97fd				      JSR   LAB_26B9          ; divide by 10
6498		.9a2a		e6 a9						inc $a9					      INC   expcnt            ; increment exponent count byte
6499		.9a2c		d0 f9						bne $9a27				      BNE   LAB_28E6          ; loop until all done
6501		.9a2e		f0 07						beq $9a37				      BEQ   LAB_28F6          ; branch always
6503		.9a30																		LAB_28EF
6504		.9a30		20 e4 97				jsr $97e4				      JSR   LAB_269E          ; multiply by 10
6505		.9a33		c6 a9						dec $a9					      DEC   expcnt            ; decrement exponent count byte
6506		.9a35		d0 f9						bne $9a30				      BNE   LAB_28EF          ; loop until all done
6508		.9a37																		LAB_28F6
6509		.9a37		a5 b1						lda $b1					      LDA   negnum            ; get -ve flag
6510		.9a39		30 01						bmi $9a3c				      BMI   LAB_28FB          ; if -ve do - FAC1 and return
6512		.9a3b		60							rts							      RTS
6516		.9a3c																		LAB_28FB
6517		.9a3c		4c 01 9c				jmp $9c01				      JMP   LAB_GTHAN         ; do - FAC1 and return
6521		.9a3f																		LAB_28FE
6522		.9a3f		48							pha							      PHA                     ; save character
6523		.9a40		24 aa						bit $aa					      BIT   numdpf            ; test decimal point flag
6524		.9a42		10 02						bpl $9a46				      BPL   LAB_2905          ; skip exponent increment if not set
6526		.9a44		e6 a8						inc $a8					      INC   numexp            ; else increment number exponent
6527		.9a46																		LAB_2905
6528		.9a46		20 e4 97				jsr $97e4				      JSR   LAB_269E          ; multiply FAC1 by 10
6529		.9a49		68							pla							      PLA                     ; restore character
6530		.9a4a		29 0f						and #$0f				      AND   #$0F              ; convert to binary
6531		.9a4c		20 52 9a				jsr $9a52				      JSR   LAB_2912          ; evaluate new ASCII digit
6532		.9a4f		4c df 99				jmp $99df				      JMP   LAB_289E          ; go do next character
6536		.9a52																		LAB_2912
6537		.9a52		48							pha							      PHA                     ; save digit
6538		.9a53		20 d7 98				jsr $98d7				      JSR   LAB_27AB          ; round and copy FAC1 to FAC2
6539		.9a56		68							pla							      PLA                     ; restore digit
6540		.9a57		20 07 99				jsr $9907				      JSR   LAB_27DB          ; save A as integer byte
6541		.9a5a		a5 b7						lda $b7					      LDA   FAC2_s            ; get FAC2 sign (b7)
6542		.9a5c		45 b0						eor $b0					      EOR   FAC1_s            ; toggle with FAC1 sign (b7)
6543		.9a5e		85 b8						sta $b8					      STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
6544		.9a60		a6 ac						ldx $ac					      LDX   FAC1_e            ; get FAC1 exponent
6545		.9a62		4c ce 95				jmp $95ce				      JMP   LAB_ADD           ; add FAC2 to FAC1 and return
6549		.9a65																		LAB_2925
6550		.9a65		a5 a9						lda $a9					      LDA   expcnt            ; get exponent count byte
6551		.9a67		c9 0a						cmp #$0a				      CMP   #$0A              ; compare with 10 decimal
6552		.9a69		90 09						bcc $9a74				      BCC   LAB_2934          ; branch if less
6554		.9a6b		a9 64						lda #$64				      LDA   #$64              ; make all -ve exponents = -100 decimal (causes underflow)
6555		.9a6d		24 ab						bit $ab					      BIT   expneg            ; test exponent -ve flag
6556		.9a6f		30 0e						bmi $9a7f				      BMI   LAB_2942          ; branch if -ve
6558		.9a71		4c d0 96				jmp $96d0				      JMP   LAB_2564          ; else do overflow error
6560		.9a74																		LAB_2934
6561		.9a74		0a							asl a						      ASL                     ; * 2
6562		.9a75		0a							asl a						      ASL                     ; * 4
6563		.9a76		65 a9						adc $a9					      ADC   expcnt            ; * 5
6564		.9a78		0a							asl a						      ASL                     ; * 10
6565		.9a79		a0 00						ldy #$00				      LDY   #$00              ; set index
6566		.9a7b		71 c3						adc ($c3),y			      ADC   (Bpntrl),Y        ; add character (will be $30 too much!)
6567		.9a7d		e9 2f						sbc #$2f				      SBC   #'0'-1            ; convert character to binary
6568		.9a7f																		LAB_2942
6569		.9a7f		85 a9						sta $a9					      STA   expcnt            ; save exponent count byte
6570		.9a81		4c 05 9a				jmp $9a05				      JMP   LAB_28C4          ; go get next character
6574		.9a84																		LAB_2953
6575		.9a84		a9 fe						lda #$fe				      LDA   #<LAB_LMSG        ; point to " in line " message low byte
6576		.9a86		a0 a7						ldy #$a7				      LDY   #>LAB_LMSG        ; point to " in line " message high byte
6577		.9a88		20 d4 88				jsr $88d4				      JSR   LAB_18C3          ; print null terminated string from memory
6580		.9a8b		a5 88						lda $88					      LDA   Clineh            ; get current line high byte
6581		.9a8d		a6 87						ldx $87					      LDX   Clinel            ; get current line low byte
6585		.9a8f																		LAB_295E
6586		.9a8f		85 ad						sta $ad					      STA   FAC1_1            ; save low byte as FAC1 mantissa1
6587		.9a91		86 ae						stx $ae					      STX   FAC1_2            ; save high byte as FAC1 mantissa2
6588		.9a93		a2 90						ldx #$90				      LDX   #$90              ; set exponent to 16d bits
6589		.9a95		38							sec							      SEC                     ; set integer is +ve flag
6590		.9a96		20 14 99				jsr $9914				      JSR   LAB_STFA          ; set exp=X, clearFAC1 mantissa3 and normalise
6591		.9a99		a0 00						ldy #$00				      LDY   #$00              ; clear index
6592		.9a9b		98							tya							      TYA                     ; clear A
6593		.9a9c		20 af 9a				jsr $9aaf				      JSR   LAB_297B          ; convert FAC1 to string, skip sign character save
6594		.9a9f		4c d4 88				jmp $88d4				      JMP   LAB_18C3          ; print null terminated string from memory and return
6599		.9aa2																		LAB_296E
6600		.9aa2		a0 01						ldy #$01				      LDY   #$01              ; set index = 1
6601		.9aa4		a9 20						lda #$20				      LDA   #$20              ; character = " " (assume +ve)
6602		.9aa6		24 b0						bit $b0					      BIT   FAC1_s            ; test FAC1 sign (b7)
6603		.9aa8		10 02						bpl $9aac				      BPL   LAB_2978          ; branch if +ve
6605		.9aaa		a9 2d						lda #$2d				      LDA   #$2D              ; else character = "-"
6606		.9aac																		LAB_2978
6607		.9aac		99 ef 00				sta $00ef,y			      STA   Decss,Y           ; save leading character (" " or "-")
6608		.9aaf																		LAB_297B
6609		.9aaf		85 b0						sta $b0					      STA   FAC1_s            ; clear FAC1 sign (b7)
6610		.9ab1		84 ba						sty $ba					      STY   Sendl             ; save index
6611		.9ab3		c8							iny							      INY                     ; increment index
6612		.9ab4		a6 ac						ldx $ac					      LDX   FAC1_e            ; get FAC1 exponent
6613		.9ab6		d0 05						bne $9abd				      BNE   LAB_2989          ; branch if FAC1<>0
6616		.9ab8		a9 30						lda #$30				      LDA   #'0'              ; set character = "0"
6617		.9aba		4c bb 9b				jmp $9bbb				      JMP   LAB_2A89          ; save last character, [EOT] and exit
6620		.9abd																		LAB_2989
6621		.9abd		a9 00						lda #$00				      LDA   #$00              ; clear (number exponent count)
6622		.9abf		e0 81						cpx #$81				      CPX   #$81              ; compare FAC1 exponent with $81 (>1.00000)
6624		.9ac1		b0 09						bcs $9acc				      BCS   LAB_299A          ; branch if FAC1=>1
6627		.9ac3		a9 92						lda #$92				      LDA   #<LAB_294F        ; set pointer low byte to 1,000,000
6628		.9ac5		a0 a1						ldy #$a1				      LDY   #>LAB_294F        ; set pointer high byte to 1,000,000
6629		.9ac7		20 46 97				jsr $9746				      JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
6630		.9aca		a9 fa						lda #$fa				      LDA   #$FA              ; set number exponent count (-6)
6631		.9acc																		LAB_299A
6632		.9acc		85 a8						sta $a8					      STA   numexp            ; save number exponent count
6633		.9ace																		LAB_299C
6634		.9ace		a9 8e						lda #$8e				      LDA   #<LAB_294B        ; set pointer low byte to 999999.4375 (max before sci note)
6635		.9ad0		a0 a1						ldy #$a1				      LDY   #>LAB_294B        ; set pointer high byte to 999999.4375
6636		.9ad2		20 24 99				jsr $9924				      JSR   LAB_27F8          ; compare FAC1 with (AY)
6637		.9ad5		f0 1e						beq $9af5				      BEQ   LAB_29C3          ; exit if FAC1 = (AY)
6639		.9ad7		10 12						bpl $9aeb				      BPL   LAB_29B9          ; go do /10 if FAC1 > (AY)
6642		.9ad9																		LAB_29A7
6643		.9ad9		a9 8a						lda #$8a				      LDA   #<LAB_2947        ; set pointer low byte to 99999.9375
6644		.9adb		a0 a1						ldy #$a1				      LDY   #>LAB_2947        ; set pointer high byte to 99999.9375
6645		.9add		20 24 99				jsr $9924				      JSR   LAB_27F8          ; compare FAC1 with (AY)
6646		.9ae0		f0 02						beq $9ae4				      BEQ   LAB_29B2          ; branch if FAC1 = (AY) (allow decimal places)
6648		.9ae2		10 0e						bpl $9af2				      BPL   LAB_29C0          ; branch if FAC1 > (AY) (no decimal places)
6651		.9ae4																		LAB_29B2
6652		.9ae4		20 e4 97				jsr $97e4				      JSR   LAB_269E          ; multiply by 10
6653		.9ae7		c6 a8						dec $a8					      DEC   numexp            ; decrement number exponent count
6654		.9ae9		d0 ee						bne $9ad9				      BNE   LAB_29A7          ; go test again (branch always)
6656		.9aeb																		LAB_29B9
6657		.9aeb		20 fd 97				jsr $97fd				      JSR   LAB_26B9          ; divide by 10
6658		.9aee		e6 a8						inc $a8					      INC   numexp            ; increment number exponent count
6659		.9af0		d0 dc						bne $9ace				      BNE   LAB_299C          ; go test again (branch always)
6663		.9af2																		LAB_29C0
6664		.9af2		20 c7 95				jsr $95c7				      JSR   LAB_244E          ; add 0.5 to FAC1 (round FAC1)
6665		.9af5																		LAB_29C3
6666		.9af5		20 5d 99				jsr $995d				      JSR   LAB_2831          ; convert FAC1 floating-to-fixed
6667		.9af8		a2 01						ldx #$01				      LDX   #$01              ; set default digits before dp = 1
6668		.9afa		a5 a8						lda $a8					      LDA   numexp            ; get number exponent count
6669		.9afc		18							clc							      CLC                     ; clear carry for add
6670		.9afd		69 07						adc #$07				      ADC   #$07              ; up to 6 digits before point
6671		.9aff		30 09						bmi $9b0a				      BMI   LAB_29D8          ; if -ve then 1 digit before dp
6673		.9b01		c9 08						cmp #$08				      CMP   #$08              ; A>=8 if n>=1E6
6674		.9b03		b0 06						bcs $9b0b				      BCS   LAB_29D9          ; branch if >= $08
6677		.9b05		69 ff						adc #$ff				      ADC   #$FF              ; take 1 from digit count
6678		.9b07		aa							tax							      TAX                     ; copy to A
6679		.9b08		a9 02						lda #$02				      LDA   #$02              ;.set exponent adjust
6680		.9b0a																		LAB_29D8
6681		.9b0a		38							sec							      SEC                     ; set carry for subtract
6682		.9b0b																		LAB_29D9
6683		.9b0b		e9 02						sbc #$02				      SBC   #$02              ; -2
6684		.9b0d		85 a9						sta $a9					      STA   expcnt            ;.save exponent adjust
6685		.9b0f		86 a8						stx $a8					      STX   numexp            ; save digits before dp count
6686		.9b11		8a							txa							      TXA                     ; copy to A
6687		.9b12		f0 02						beq $9b16				      BEQ   LAB_29E4          ; branch if no digits before dp
6689		.9b14		10 13						bpl $9b29				      BPL   LAB_29F7          ; branch if digits before dp
6691		.9b16																		LAB_29E4
6692		.9b16		a4 ba						ldy $ba					      LDY   Sendl             ; get output string index
6693		.9b18		a9 2e						lda #$2e				      LDA   #$2E              ; character "."
6694		.9b1a		c8							iny							      INY                     ; increment index
6695		.9b1b		99 ef 00				sta $00ef,y			      STA   Decss,Y           ; save to output string
6696		.9b1e		8a							txa							      TXA                     ;.
6697		.9b1f		f0 06						beq $9b27				      BEQ   LAB_29F5          ;.
6699		.9b21		a9 30						lda #$30				      LDA   #'0'              ; character "0"
6700		.9b23		c8							iny							      INY                     ; increment index
6701		.9b24		99 ef 00				sta $00ef,y			      STA   Decss,Y           ; save to output string
6702		.9b27																		LAB_29F5
6703		.9b27		84 ba						sty $ba					      STY   Sendl             ; save output string index
6704		.9b29																		LAB_29F7
6705		.9b29		a0 00						ldy #$00				      LDY   #$00              ; clear index (point to 100,000)
6706		.9b2b		a2 80						ldx #$80				      LDX   #$80              ;
6707		.9b2d																		LAB_29FB
6708		.9b2d		a5 af						lda $af					      LDA   FAC1_3            ; get FAC1 mantissa3
6709		.9b2f		18							clc							      CLC                     ; clear carry for add
6710		.9b30		79 08 a2				adc $a208,y			      ADC   LAB_2A9C,Y        ; add -ve LSB
6711		.9b33		85 af						sta $af					      STA   FAC1_3            ; save FAC1 mantissa3
6712		.9b35		a5 ae						lda $ae					      LDA   FAC1_2            ; get FAC1 mantissa2
6713		.9b37		79 07 a2				adc $a207,y			      ADC   LAB_2A9B,Y        ; add -ve NMSB
6714		.9b3a		85 ae						sta $ae					      STA   FAC1_2            ; save FAC1 mantissa2
6715		.9b3c		a5 ad						lda $ad					      LDA   FAC1_1            ; get FAC1 mantissa1
6716		.9b3e		79 06 a2				adc $a206,y			      ADC   LAB_2A9A,Y        ; add -ve MSB
6717		.9b41		85 ad						sta $ad					      STA   FAC1_1            ; save FAC1 mantissa1
6718		.9b43		e8							inx							      INX                     ;
6719		.9b44		b0 04						bcs $9b4a				      BCS   LAB_2A18          ;
6721		.9b46		10 e5						bpl $9b2d				      BPL   LAB_29FB          ; not -ve so try again
6723		.9b48		30 02						bmi $9b4c				      BMI   LAB_2A1A          ;
6725		.9b4a																		LAB_2A18
6726		.9b4a		30 e1						bmi $9b2d				      BMI   LAB_29FB          ;
6728		.9b4c																		LAB_2A1A
6729		.9b4c		8a							txa							      TXA                     ;
6730		.9b4d		90 04						bcc $9b53				      BCC   LAB_2A21          ;
6732		.9b4f		49 ff						eor #$ff				      EOR   #$FF              ;
6733		.9b51		69 0a						adc #$0a				      ADC   #$0A              ;
6734		.9b53																		LAB_2A21
6735		.9b53		69 2f						adc #$2f				      ADC   #'0'-1            ; add "0"-1 to result
6736		.9b55		c8							iny							      INY                     ; increment index ..
6737		.9b56		c8							iny							      INY                     ; .. to next less ..
6738		.9b57		c8							iny							      INY                     ; .. power of ten
6739		.9b58		84 95						sty $95					      STY   Cvaral            ; save as current var address low byte
6740		.9b5a		a4 ba						ldy $ba					      LDY   Sendl             ; get output string index
6741		.9b5c		c8							iny							      INY                     ; increment output string index
6742		.9b5d		aa							tax							      TAX                     ; copy character to X
6743		.9b5e		29 7f						and #$7f				      AND   #$7F              ; mask out top bit
6744		.9b60		99 ef 00				sta $00ef,y			      STA   Decss,Y           ; save to output string
6745		.9b63		c6 a8						dec $a8					      DEC   numexp            ; decrement # of characters before the dp
6746		.9b65		d0 06						bne $9b6d				      BNE   LAB_2A3B          ; branch if still characters to do
6749		.9b67		a9 2e						lda #$2e				      LDA   #$2E              ; character "."
6750		.9b69		c8							iny							      INY                     ; increment output string index
6751		.9b6a		99 ef 00				sta $00ef,y			      STA   Decss,Y           ; save to output string
6752		.9b6d																		LAB_2A3B
6753		.9b6d		84 ba						sty $ba					      STY   Sendl             ; save output string index
6754		.9b6f		a4 95						ldy $95					      LDY   Cvaral            ; get current var address low byte
6755		.9b71		8a							txa							      TXA                     ; get character back
6756		.9b72		49 ff						eor #$ff				      EOR   #$FF              ;
6757		.9b74		29 80						and #$80				      AND   #$80              ;
6758		.9b76		aa							tax							      TAX                     ;
6759		.9b77		c0 12						cpy #$12				      CPY   #$12              ; compare index with max
6760		.9b79		d0 b2						bne $9b2d				      BNE   LAB_29FB          ; loop if not max
6763		.9b7b		a4 ba						ldy $ba					      LDY   Sendl             ; get output string index
6764		.9b7d																		LAB_2A4B
6765		.9b7d		b9 ef 00				lda $00ef,y			      LDA   Decss,Y           ; get character from output string
6766		.9b80		88							dey							      DEY                     ; decrement output string index
6767		.9b81		c9 30						cmp #$30				      CMP   #'0'              ; compare with "0"
6768		.9b83		f0 f8						beq $9b7d				      BEQ   LAB_2A4B          ; loop until non "0" character found
6770		.9b85		c9 2e						cmp #$2e				      CMP   #'.'              ; compare with "."
6771		.9b87		f0 01						beq $9b8a				      BEQ   LAB_2A58          ; branch if was dp
6774		.9b89		c8							iny							      INY                     ; increment output string index
6775		.9b8a																		LAB_2A58
6776		.9b8a		a9 2b						lda #$2b				      LDA   #$2B              ; character "+"
6777		.9b8c		a6 a9						ldx $a9					      LDX   expcnt            ; get exponent count
6778		.9b8e		f0 2e						beq $9bbe				      BEQ   LAB_2A8C          ; if zero go set null terminator and exit
6781		.9b90		10 08						bpl $9b9a				      BPL   LAB_2A68          ; branch if exponent count +ve
6783		.9b92		a9 00						lda #$00				      LDA   #$00              ; clear A
6784		.9b94		38							sec							      SEC                     ; set carry for subtract
6785		.9b95		e5 a9						sbc $a9					      SBC   expcnt            ; subtract exponent count adjust (convert -ve to +ve)
6786		.9b97		aa							tax							      TAX                     ; copy exponent count to X
6787		.9b98		a9 2d						lda #$2d				      LDA   #'-'              ; character "-"
6788		.9b9a																		LAB_2A68
6789		.9b9a		99 f1 00				sta $00f1,y			      STA   Decss+2,Y         ; save to output string
6790		.9b9d		a9 45						lda #$45				      LDA   #$45              ; character "E"
6791		.9b9f		99 f0 00				sta $00f0,y			      STA   Decss+1,Y         ; save exponent sign to output string
6792		.9ba2		8a							txa							      TXA                     ; get exponent count back
6793		.9ba3		a2 2f						ldx #$2f				      LDX   #'0'-1            ; one less than "0" character
6794		.9ba5		38							sec							      SEC                     ; set carry for subtract
6795		.9ba6																		LAB_2A74
6796		.9ba6		e8							inx							      INX                     ; increment 10's character
6797		.9ba7		e9 0a						sbc #$0a				      SBC   #$0A              ;.subtract 10 from exponent count
6798		.9ba9		b0 fb						bcs $9ba6				      BCS   LAB_2A74          ; loop while still >= 0
6800		.9bab		69 3a						adc #$3a				      ADC   #':'              ; add character ":" ($30+$0A, result is 10 less that value)
6801		.9bad		99 f3 00				sta $00f3,y			      STA   Decss+4,Y         ; save to output string
6802		.9bb0		8a							txa							      TXA                     ; copy 10's character
6803		.9bb1		99 f2 00				sta $00f2,y			      STA   Decss+3,Y         ; save to output string
6804		.9bb4		a9 00						lda #$00				      LDA   #$00              ; set null terminator
6805		.9bb6		99 f4 00				sta $00f4,y			      STA   Decss+5,Y         ; save to output string
6806		.9bb9		f0 08						beq $9bc3				      BEQ   LAB_2A91          ; go set string pointer (AY) and exit (branch always)
6809		.9bbb																		LAB_2A89
6810		.9bbb		99 ef 00				sta $00ef,y			      STA   Decss,Y           ; save last character to output string
6813		.9bbe																		LAB_2A8C
6814		.9bbe		a9 00						lda #$00				      LDA   #$00              ; set null terminator
6815		.9bc0		99 f0 00				sta $00f0,y			      STA   Decss+1,Y         ; save after last character
6818		.9bc3																		LAB_2A91
6819		.9bc3		a9 f0						lda #$f0				      LDA   #<Decssp1         ; set result string low pointer
6820		.9bc5		a0 00						ldy #$00				      LDY   #>Decssp1         ; set result string high pointer
6821		.9bc7		60							rts							      RTS
6825		.9bc8																		LAB_POWER
6826		.9bc8		f0 42						beq $9c0c				      BEQ   LAB_EXP           ; go do  EXP()
6828		.9bca		a5 b3						lda $b3					      LDA   FAC2_e            ; get FAC2 exponent
6829		.9bcc		d0 03						bne $9bd1				      BNE   LAB_2ABF          ; branch if FAC2<>0
6831		.9bce		4c 5f 96				jmp $965f				      JMP   LAB_24F3          ; clear FAC1 exponent and sign and return
6833		.9bd1																		LAB_2ABF
6834		.9bd1		a2 9c						ldx #$9c				      LDX   #<func_l          ; set destination pointer low byte
6835		.9bd3		a0 00						ldy #$00				      LDY   #>func_l          ; set destination pointer high byte
6836		.9bd5		20 b4 98				jsr $98b4				      JSR   LAB_2778          ; pack FAC1 into (XY)
6837		.9bd8		a5 b7						lda $b7					      LDA   FAC2_s            ; get FAC2 sign (b7)
6838		.9bda		10 0f						bpl $9beb				      BPL   LAB_2AD9          ; branch if FAC2>0
6842		.9bdc		20 8e 99				jsr $998e				      JSR   LAB_INT           ; perform INT
6843		.9bdf		a9 9c						lda #$9c				      LDA   #<func_l          ; set source pointer low byte
6844		.9be1		a0 00						ldy #$00				      LDY   #>func_l          ; set source pointer high byte
6845		.9be3		20 24 99				jsr $9924				      JSR   LAB_27F8          ; compare FAC1 with (AY)
6846		.9be6		d0 03						bne $9beb				      BNE   LAB_2AD9          ; branch if FAC1 <> (AY) to allow Function Call error
6850		.9be8		98							tya							      TYA                     ; clear sign b7
6851		.9be9		a4 5b						ldy $5b					      LDY   Temp3             ; save mantissa 3 from INT() function as sign in Y
6853		.9beb																		LAB_2AD9
6854		.9beb		20 d2 95				jsr $95d2				      JSR   LAB_279D          ; save FAC1 sign and copy ABS(FAC2) to FAC1
6855		.9bee		98							tya							      TYA                     ; copy sign back ..
6856		.9bef		48							pha							      PHA                     ; .. and save it
6857		.9bf0		20 08 97				jsr $9708				      JSR   LAB_LOG           ; do LOG(n)
6858		.9bf3		a9 9c						lda #$9c				      LDA   #<garb_l          ; set pointer low byte
6859		.9bf5		a0 00						ldy #$00				      LDY   #>garb_l          ; set pointer high byte
6860		.9bf7		20 46 97				jsr $9746				      JSR   LAB_25FB          ; do convert AY, FCA1*(AY) (square the value)
6861		.9bfa		20 0c 9c				jsr $9c0c				      JSR   LAB_EXP           ; go do EXP(n)
6862		.9bfd		68							pla							      PLA                     ; pull sign from stack
6863		.9bfe		4a							lsr a						      LSR                     ; b0 is to be tested, shift to Cb
6864		.9bff		90 0a						bcc $9c0b				      BCC   LAB_2AF9          ; if no bit then exit
6869		.9c01																		LAB_GTHAN
6870		.9c01		a5 ac						lda $ac					      LDA   FAC1_e            ; get FAC1 exponent
6871		.9c03		f0 06						beq $9c0b				      BEQ   LAB_2AF9          ; exit if FAC1_e = $00
6873		.9c05		a5 b0						lda $b0					      LDA   FAC1_s            ; get FAC1 sign (b7)
6874		.9c07		49 ff						eor #$ff				      EOR   #$FF              ; complement it
6875		.9c09		85 b0						sta $b0					      STA   FAC1_s            ; save FAC1 sign (b7)
6876		.9c0b																		LAB_2AF9
6877		.9c0b		60							rts							      RTS
6881		.9c0c																		LAB_EXP
6882		.9c0c		a9 96						lda #$96				      LDA   #<LAB_2AFA        ; set 1.443 pointer low byte
6883		.9c0e		a0 a1						ldy #$a1				      LDY   #>LAB_2AFA        ; set 1.443 pointer high byte
6884		.9c10		20 46 97				jsr $9746				      JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
6885		.9c13		a5 b9						lda $b9					      LDA   FAC1_r            ; get FAC1 rounding byte
6886		.9c15		69 50						adc #$50				      ADC   #$50              ; +$50/$100
6887		.9c17		90 03						bcc $9c1c				      BCC   LAB_2B2B          ; skip rounding if no carry
6889		.9c19		20 ee 98				jsr $98ee				      JSR   LAB_27C2          ; round FAC1 (no check)
6890		.9c1c																		LAB_2B2B
6891		.9c1c		85 a3						sta $a3					      STA   FAC2_r            ; save FAC2 rounding byte
6892		.9c1e		20 da 98				jsr $98da				      JSR   LAB_27AE          ; copy FAC1 to FAC2
6893		.9c21		a5 ac						lda $ac					      LDA   FAC1_e            ; get FAC1 exponent
6894		.9c23		c9 88						cmp #$88				      CMP   #$88              ; compare with EXP limit (256d)
6895		.9c25		90 03						bcc $9c2a				      BCC   LAB_2B39          ; branch if less
6897		.9c27																		LAB_2B36
6898		.9c27		20 db 97				jsr $97db				      JSR   LAB_2690          ; handle overflow and underflow
6899		.9c2a																		LAB_2B39
6900		.9c2a		20 8e 99				jsr $998e				      JSR   LAB_INT           ; perform INT
6901		.9c2d		a5 5b						lda $5b					      LDA   Temp3             ; get mantissa 3 from INT() function
6902		.9c2f		18							clc							      CLC                     ; clear carry for add
6903		.9c30		69 81						adc #$81				      ADC   #$81              ; normalise +1
6904		.9c32		f0 f3						beq $9c27				      BEQ   LAB_2B36          ; if $00 go handle overflow
6906		.9c34		38							sec							      SEC                     ; set carry for subtract
6907		.9c35		e9 01						sbc #$01				      SBC   #$01              ; now correct for exponent
6908		.9c37		48							pha							      PHA                     ; save FAC2 exponent
6911		.9c38		a2 04						ldx #$04				      LDX   #$04              ; 4 bytes to do
6912		.9c3a																		LAB_2B49
6913		.9c3a		b5 b3						lda $b3,x				      LDA   FAC2_e,X          ; get FAC2,X
6914		.9c3c		b4 ac						ldy $ac,x				      LDY   FAC1_e,X          ; get FAC1,X
6915		.9c3e		95 ac						sta $ac,x				      STA   FAC1_e,X          ; save FAC1,X
6916		.9c40		94 b3						sty $b3,x				      STY   FAC2_e,X          ; save FAC2,X
6917		.9c42		ca							dex							      DEX                     ; decrement count/index
6918		.9c43		10 f5						bpl $9c3a				      BPL   LAB_2B49          ; loop if not all done
6920		.9c45		a5 a3						lda $a3					      LDA   FAC2_r            ; get FAC2 rounding byte
6921		.9c47		85 b9						sta $b9					      STA   FAC1_r            ; save as FAC1 rounding byte
6922		.9c49		20 b3 95				jsr $95b3				      JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
6923		.9c4c		20 01 9c				jsr $9c01				      JSR   LAB_GTHAN         ; do - FAC1
6924		.9c4f		a9 9a						lda #$9a				      LDA   #<LAB_2AFE        ; set counter pointer low byte
6925		.9c51		a0 a1						ldy #$a1				      LDY   #>LAB_2AFE        ; set counter pointer high byte
6926		.9c53		20 74 9c				jsr $9c74				      JSR   LAB_2B84          ; go do series evaluation
6927		.9c56		a9 00						lda #$00				      LDA   #$00              ; clear A
6928		.9c58		85 b8						sta $b8					      STA   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
6929		.9c5a		68							pla							      PLA                     ;.get saved FAC2 exponent
6930		.9c5b		4c c0 97				jmp $97c0				      JMP   LAB_2675          ; test and adjust accumulators and return
6934		.9c5e																		LAB_2B6E
6935		.9c5e		85 ba						sta $ba					      STA   Cptrl             ; save count pointer low byte
6936		.9c60		84 bb						sty $bb					      STY   Cptrh             ; save count pointer high byte
6937		.9c62		20 aa 98				jsr $98aa				      JSR   LAB_276E          ; pack FAC1 into Adatal
6938		.9c65		a9 a4						lda #$a4				      LDA   #<Adatal          ; set pointer low byte (Y already $00)
6939		.9c67		20 46 97				jsr $9746				      JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
6940		.9c6a		20 78 9c				jsr $9c78				      JSR   LAB_2B88          ; go do series evaluation
6941		.9c6d		a9 a4						lda #$a4				      LDA   #<Adatal          ; pointer to original # low byte
6942		.9c6f		a0 00						ldy #$00				      LDY   #>Adatal          ; pointer to original # high byte
6943		.9c71		4c 46 97				jmp $9746				      JMP   LAB_25FB          ; do convert AY, FCA1*(AY) and return
6947		.9c74																		LAB_2B84
6948		.9c74		85 ba						sta $ba					      STA   Cptrl             ; save count pointer low byte
6949		.9c76		84 bb						sty $bb					      STY   Cptrh             ; save count pointer high byte
6950		.9c78																		LAB_2B88
6951		.9c78		a2 a8						ldx #$a8				      LDX   #<numexp          ; set pointer low byte
6952		.9c7a		20 ac 98				jsr $98ac				      JSR   LAB_2770          ; set pointer high byte and pack FAC1 into numexp
6953		.9c7d		b1 ba						lda ($ba),y			      LDA   (Cptrl),Y         ; get constants count
6954		.9c7f		85 b1						sta $b1					      STA   numcon            ; save constants count
6955		.9c81		a4 ba						ldy $ba					      LDY   Cptrl             ; get count pointer low byte
6956		.9c83		c8							iny							      INY                     ; increment it (now constants pointer)
6957		.9c84		98							tya							      TYA                     ; copy it
6958		.9c85		d0 02						bne $9c89				      BNE   LAB_2B97          ; skip next if no overflow
6960		.9c87		e6 bb						inc $bb					      INC   Cptrh             ; else increment high byte
6961		.9c89																		LAB_2B97
6962		.9c89		85 ba						sta $ba					      STA   Cptrl             ; save low byte
6963		.9c8b		a4 bb						ldy $bb					      LDY   Cptrh             ; get high byte
6964		.9c8d																		LAB_2B9B
6965		.9c8d		20 46 97				jsr $9746				      JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
6966		.9c90		a5 ba						lda $ba					      LDA   Cptrl             ; get constants pointer low byte
6967		.9c92		a4 bb						ldy $bb					      LDY   Cptrh             ; get constants pointer high byte
6968		.9c94		18							clc							      CLC                     ; clear carry for add
6969		.9c95		69 04						adc #$04				      ADC   #$04              ; +4 to  low pointer (4 bytes per constant)
6970		.9c97		90 01						bcc $9c9a				      BCC   LAB_2BA8          ; skip next if no overflow
6972		.9c99		c8							iny							      INY                     ; increment high byte
6973		.9c9a																		LAB_2BA8
6974		.9c9a		85 ba						sta $ba					      STA   Cptrl             ; save pointer low byte
6975		.9c9c		84 bb						sty $bb					      STY   Cptrh             ; save pointer high byte
6976		.9c9e		20 cb 95				jsr $95cb				      JSR   LAB_246C          ; add (AY) to FAC1
6977		.9ca1		a9 a8						lda #$a8				      LDA   #<numexp          ; set pointer low byte to partial @ numexp
6978		.9ca3		a0 00						ldy #$00				      LDY   #>numexp          ; set pointer high byte to partial @ numexp
6979		.9ca5		c6 b1						dec $b1					      DEC   numcon            ; decrement constants count
6980		.9ca7		d0 e4						bne $9c8d				      BNE   LAB_2B9B          ; loop until all done
6982		.9ca9		60							rts							      RTS
6998		.9caa																		LAB_RND
6999		.9caa		a5 ac						lda $ac					      LDA   FAC1_e            ; get FAC1 exponent
7000		.9cac		f0 07						beq $9cb5				      BEQ   NextPRN           ; do next random # if zero
7003		.9cae		a2 d8						ldx #$d8				      LDX   #Rbyte4           ; set PRNG pointer low byte
7004		.9cb0		a0 00						ldy #$00				      LDY   #$00              ; set PRNG pointer high byte
7005		.9cb2		20 b4 98				jsr $98b4				      JSR   LAB_2778          ; pack FAC1 into (XY)
7006		.9cb5																		NextPRN
7007		.9cb5		a2 af						ldx #$af				      LDX   #$AF              ; set EOR byte
7008		.9cb7		a0 13						ldy #$13				      LDY   #$13              ; do this nineteen times
7009		.9cb9																		LoopPRN
7010		.9cb9		06 d9						asl $d9					      ASL   Rbyte1            ; shift PRNG most significant byte
7011		.9cbb		26 da						rol $da					      ROL   Rbyte2            ; shift PRNG middle byte
7012		.9cbd		26 db						rol $db					      ROL   Rbyte3            ; shift PRNG least significant byte
7013		.9cbf		26 d8						rol $d8					      ROL   Rbyte4            ; shift PRNG extra byte
7014		.9cc1		90 05						bcc $9cc8				      BCC   Ninc1             ; branch if bit 32 clear
7016		.9cc3		8a							txa							      TXA                     ; set EOR byte
7017		.9cc4		45 d9						eor $d9					      EOR   Rbyte1            ; EOR PRNG extra byte
7018		.9cc6		85 d9						sta $d9					      STA   Rbyte1            ; save new PRNG extra byte
7019		.9cc8																		Ninc1
7020		.9cc8		88							dey							      DEY                     ; decrement loop count
7021		.9cc9		d0 ee						bne $9cb9				      BNE   LoopPRN           ; loop if not all done
7023		.9ccb		a2 02						ldx #$02				      LDX   #$02              ; three bytes to copy
7024		.9ccd																		CopyPRNG
7025		.9ccd		b5 d9						lda $d9,x				      LDA   Rbyte1,X          ; get PRNG byte
7026		.9ccf		95 ad						sta $ad,x				      STA   FAC1_1,X          ; save FAC1 byte
7027		.9cd1		ca							dex							      DEX
7028		.9cd2		10 f9						bpl $9ccd				      BPL   CopyPRNG          ; loop if not complete
7030		.9cd4		a9 80						lda #$80				      LDA   #$80              ; set the exponent
7031		.9cd6		85 ac						sta $ac					      STA   FAC1_e            ; save FAC1 exponent
7033		.9cd8		0a							asl a						      ASL                     ; clear A
7034		.9cd9		85 b0						sta $b0					      STA   FAC1_s            ; save FAC1 sign
7036		.9cdb		4c 41 96				jmp $9641				      JMP   LAB_24D5          ; normalise FAC1 and return
7040		.9cde																		LAB_COS
7041		.9cde		a9 b7						lda #$b7				      LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
7042		.9ce0		a0 a1						ldy #$a1				      LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
7043		.9ce2		20 cb 95				jsr $95cb				      JSR   LAB_246C          ; add (AY) to FAC1
7047		.9ce5																		LAB_SIN
7048		.9ce5		20 d7 98				jsr $98d7				      JSR   LAB_27AB          ; round and copy FAC1 to FAC2
7049		.9ce8		a9 cc						lda #$cc				      LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
7050		.9cea		a0 a1						ldy #$a1				      LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
7051		.9cec		a6 b7						ldx $b7					      LDX   FAC2_s            ; get FAC2 sign (b7)
7052		.9cee		20 06 98				jsr $9806				      JSR   LAB_26C2          ; divide by (AY) (X=sign)
7053		.9cf1		20 d7 98				jsr $98d7				      JSR   LAB_27AB          ; round and copy FAC1 to FAC2
7054		.9cf4		20 8e 99				jsr $998e				      JSR   LAB_INT           ; perform INT
7055		.9cf7		a9 00						lda #$00				      LDA   #$00              ; clear byte
7056		.9cf9		85 b8						sta $b8					      STA   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
7057		.9cfb		20 b3 95				jsr $95b3				      JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
7058		.9cfe		a9 fe						lda #$fe				      LDA   #<LAB_2C80        ; set 0.25 pointer low byte
7059		.9d00		a0 a1						ldy #$a1				      LDY   #>LAB_2C80        ; set 0.25 pointer high byte
7060		.9d02		20 b0 95				jsr $95b0				      JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
7061		.9d05		a5 b0						lda $b0					      LDA   FAC1_s            ; get FAC1 sign (b7)
7062		.9d07		48							pha							      PHA                     ; save FAC1 sign
7063		.9d08		10 0d						bpl $9d17				      BPL   LAB_2C35          ; branch if +ve
7066		.9d0a		20 c7 95				jsr $95c7				      JSR   LAB_244E          ; add 0.5 to FAC1
7067		.9d0d		a5 b0						lda $b0					      LDA   FAC1_s            ; get FAC1 sign (b7)
7068		.9d0f		30 09						bmi $9d1a				      BMI   LAB_2C38          ; branch if -ve
7070		.9d11		a5 63						lda $63					      LDA   Cflag             ; get comparison evaluation flag
7071		.9d13		49 ff						eor #$ff				      EOR   #$FF              ; toggle flag
7072		.9d15		85 63						sta $63					      STA   Cflag             ; save comparison evaluation flag
7073		.9d17																		LAB_2C35
7074		.9d17		20 01 9c				jsr $9c01				      JSR   LAB_GTHAN         ; do - FAC1
7075		.9d1a																		LAB_2C38
7076		.9d1a		a9 fe						lda #$fe				      LDA   #<LAB_2C80        ; set 0.25 pointer low byte
7077		.9d1c		a0 a1						ldy #$a1				      LDY   #>LAB_2C80        ; set 0.25 pointer high byte
7078		.9d1e		20 cb 95				jsr $95cb				      JSR   LAB_246C          ; add (AY) to FAC1
7079		.9d21		68							pla							      PLA                     ; restore FAC1 sign
7080		.9d22		10 03						bpl $9d27				      BPL   LAB_2C45          ; branch if was +ve
7083		.9d24		20 01 9c				jsr $9c01				      JSR   LAB_GTHAN         ; do - FAC1
7084		.9d27																		LAB_2C45
7085		.9d27		a9 bb						lda #$bb				      LDA   #<LAB_2C84        ; set pointer low byte to counter
7086		.9d29		a0 a1						ldy #$a1				      LDY   #>LAB_2C84        ; set pointer high byte to counter
7087		.9d2b		4c 5e 9c				jmp $9c5e				      JMP   LAB_2B6E          ; ^2 then series evaluation and return
7091		.9d2e																		LAB_TAN
7092		.9d2e		20 aa 98				jsr $98aa				      JSR   LAB_276E          ; pack FAC1 into Adatal
7093		.9d31		a9 00						lda #$00				      LDA   #$00              ; clear byte
7094		.9d33		85 63						sta $63					      STA   Cflag             ; clear comparison evaluation flag
7095		.9d35		20 e5 9c				jsr $9ce5				      JSR   LAB_SIN           ; go do SIN(n)
7096		.9d38		a2 9c						ldx #$9c				      LDX   #<func_l          ; set sin(n) pointer low byte
7097		.9d3a		a0 00						ldy #$00				      LDY   #>func_l          ; set sin(n) pointer high byte
7098		.9d3c		20 b4 98				jsr $98b4				      JSR   LAB_2778          ; pack FAC1 into (XY)
7099		.9d3f		a9 a4						lda #$a4				      LDA   #<Adatal          ; set n pointer low addr
7100		.9d41		a0 00						ldy #$00				      LDY   #>Adatal          ; set n pointer high addr
7101		.9d43		20 8a 98				jsr $988a				      JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
7102		.9d46		a9 00						lda #$00				      LDA   #$00              ; clear byte
7103		.9d48		85 b0						sta $b0					      STA   FAC1_s            ; clear FAC1 sign (b7)
7104		.9d4a		a5 63						lda $63					      LDA   Cflag             ; get comparison evaluation flag
7105		.9d4c		20 56 9d				jsr $9d56				      JSR   LAB_2C74          ; save flag and go do series evaluation
7107		.9d4f		a9 9c						lda #$9c				      LDA   #<func_l          ; set sin(n) pointer low byte
7108		.9d51		a0 00						ldy #$00				      LDY   #>func_l          ; set sin(n) pointer high byte
7109		.9d53		4c 0e 98				jmp $980e				      JMP   LAB_26CA          ; convert AY and do (AY)/FAC1
7111		.9d56																		LAB_2C74
7112		.9d56		48							pha							      PHA                     ; save comparison evaluation flag
7113		.9d57		4c 17 9d				jmp $9d17				      JMP   LAB_2C35          ; go do series evaluation
7117		.9d5a																		LAB_USR
7118		.9d5a		20 0a 00				jsr $000a				      JSR   Usrjmp            ; call user code
7119		.9d5d		4c ef 8b				jmp $8bef				      JMP   LAB_1BFB          ; scan for ")", else do syntax error then warm start
7123		.9d60																		LAB_ATN
7124		.9d60		a5 b0						lda $b0					      LDA   FAC1_s            ; get FAC1 sign (b7)
7125		.9d62		48							pha							      PHA                     ; save sign
7126		.9d63		10 03						bpl $9d68				      BPL   LAB_2CA1          ; branch if +ve
7128		.9d65		20 01 9c				jsr $9c01				      JSR   LAB_GTHAN         ; else do - FAC1
7129		.9d68																		LAB_2CA1
7130		.9d68		a5 ac						lda $ac					      LDA   FAC1_e            ; get FAC1 exponent
7131		.9d6a		48							pha							      PHA                     ; push exponent
7132		.9d6b		c9 81						cmp #$81				      CMP   #$81              ; compare with 1
7133		.9d6d		90 07						bcc $9d76				      BCC   LAB_2CAF          ; branch if FAC1<1
7135		.9d6f		a9 f1						lda #$f1				      LDA   #<LAB_259C        ; set 1 pointer low byte
7136		.9d71		a0 a1						ldy #$a1				      LDY   #>LAB_259C        ; set 1 pointer high byte
7137		.9d73		20 0e 98				jsr $980e				      JSR   LAB_26CA          ; convert AY and do (AY)/FAC1
7138		.9d76																		LAB_2CAF
7139		.9d76		a9 d0						lda #$d0				      LDA   #<LAB_2CC9        ; set pointer low byte to counter
7140		.9d78		a0 a1						ldy #$a1				      LDY   #>LAB_2CC9        ; set pointer high byte to counter
7141		.9d7a		20 5e 9c				jsr $9c5e				      JSR   LAB_2B6E          ; ^2 then series evaluation
7142		.9d7d		68							pla							      PLA                     ; restore old FAC1 exponent
7143		.9d7e		c9 81						cmp #$81				      CMP   #$81              ; compare with 1
7144		.9d80		90 07						bcc $9d89				      BCC   LAB_2CC2          ; branch if FAC1<1
7146		.9d82		a9 b7						lda #$b7				      LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
7147		.9d84		a0 a1						ldy #$a1				      LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
7148		.9d86		20 b0 95				jsr $95b0				      JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
7149		.9d89																		LAB_2CC2
7150		.9d89		68							pla							      PLA                     ; restore FAC1 sign
7151		.9d8a		10 16						bpl $9da2				      BPL   LAB_2D04          ; exit if was +ve
7153		.9d8c		4c 01 9c				jmp $9c01				      JMP   LAB_GTHAN         ; else do - FAC1 and return
7157		.9d8f																		LAB_BITSET
7158		.9d8f		20 e5 94				jsr $94e5				      JSR   LAB_GADB          ; get two parameters for POKE or WAIT
7159		.9d92		e0 08						cpx #$08				      CPX   #$08              ; only 0 to 7 are allowed
7160		.9d94		b0 20						bcs $9db6				      BCS   FCError           ; branch if > 7
7162		.9d96		a9 00						lda #$00				      LDA   #$00              ; clear A
7163		.9d98		38							sec							      SEC                     ; set the carry
7164		.9d99																		S_Bits
7165		.9d99		2a							rol a						      ROL                     ; shift bit
7166		.9d9a		ca							dex							      DEX                     ; decrement bit number
7167		.9d9b		10 fc						bpl $9d99				      BPL   S_Bits            ; loop if still +ve
7169		.9d9d		e8							inx							      INX                     ; make X = $00
7170		.9d9e		01 11						ora ($11,x)			      ORA   (Itempl,X)        ; or with byte via temporary integer (addr)
7171		.9da0		81 11						sta ($11,x)			      STA   (Itempl,X)        ; save byte via temporary integer (addr)
7172		.9da2																		LAB_2D04
7173		.9da2		60							rts							      RTS
7177		.9da3																		LAB_BITCLR
7178		.9da3		20 e5 94				jsr $94e5				      JSR   LAB_GADB          ; get two parameters for POKE or WAIT
7179		.9da6		e0 08						cpx #$08				      CPX   #$08              ; only 0 to 7 are allowed
7180		.9da8		b0 0c						bcs $9db6				      BCS   FCError           ; branch if > 7
7182		.9daa		a9 ff						lda #$ff				      LDA   #$FF              ; set A
7183		.9dac																		S_Bitc
7184		.9dac		2a							rol a						      ROL                     ; shift bit
7185		.9dad		ca							dex							      DEX                     ; decrement bit number
7186		.9dae		10 fc						bpl $9dac				      BPL   S_Bitc            ; loop if still +ve
7188		.9db0		e8							inx							      INX                     ; make X = $00
7189		.9db1		21 11						and ($11,x)			      AND   (Itempl,X)        ; and with byte via temporary integer (addr)
7190		.9db3		81 11						sta ($11,x)			      STA   (Itempl,X)        ; save byte via temporary integer (addr)
7191		.9db5		60							rts							      RTS
7193		.9db6																		FCError
7194		.9db6		4c 37 8f				jmp $8f37				      JMP   LAB_FCER          ; do function call error then warm start
7198		.9db9																		LAB_BTST
7199		.9db9		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment BASIC pointer
7200		.9dbc		20 e5 94				jsr $94e5				      JSR   LAB_GADB          ; get two parameters for POKE or WAIT
7201		.9dbf		e0 08						cpx #$08				      CPX   #$08              ; only 0 to 7 are allowed
7202		.9dc1		b0 f3						bcs $9db6				      BCS   FCError           ; branch if > 7
7204		.9dc3		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; get next BASIC byte
7205		.9dc6		c9 29						cmp #$29				      CMP   #')'              ; is next character ")"
7206		.9dc8		f0 03						beq $9dcd				      BEQ   TST_OK            ; if ")" go do rest of function
7208		.9dca		4c 02 8c				jmp $8c02				      JMP   LAB_SNER          ; do syntax error then warm start
7210		.9dcd																		TST_OK
7211		.9dcd		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
7212		.9dd0		a9 00						lda #$00				      LDA   #$00              ; clear A
7213		.9dd2		38							sec							      SEC                     ; set the carry
7214		.9dd3																		T_Bits
7215		.9dd3		2a							rol a						      ROL                     ; shift bit
7216		.9dd4		ca							dex							      DEX                     ; decrement bit number
7217		.9dd5		10 fc						bpl $9dd3				      BPL   T_Bits            ; loop if still +ve
7219		.9dd7		e8							inx							      INX                     ; make X = $00
7220		.9dd8		21 11						and ($11,x)			      AND   (Itempl,X)        ; AND with byte via temporary integer (addr)
7221		.9dda		f0 02						beq $9dde				      BEQ   LAB_NOTT          ; branch if zero (already correct)
7223		.9ddc		a9 ff						lda #$ff				      LDA   #$FF              ; set for -1 result
7224		.9dde																		LAB_NOTT
7225		.9dde		4c 07 99				jmp $9907				      JMP   LAB_27DB          ; go do SGN tail
7229		.9de1																		LAB_BINS
7230		.9de1		e0 19						cpx #$19				      CPX   #$19              ; max + 1
7231		.9de3		b0 48						bcs $9e2d				      BCS   BinFErr           ; exit if too big ( > or = )
7233		.9de5		86 78						stx $78					      STX   TempB             ; save # of characters ($00 = leading zero remove)
7234		.9de7		a9 18						lda #$18				      LDA   #$18              ; need A byte long space
7235		.9de9		20 48 91				jsr $9148				      JSR   LAB_MSSP          ; make string space A bytes long
7236		.9dec		a0 17						ldy #$17				      LDY   #$17              ; set index
7237		.9dee		a2 18						ldx #$18				      LDX   #$18              ; character count
7238		.9df0																		NextB1
7239		.9df0		46 11						lsr $11					      LSR   nums_1            ; shift highest byte
7240		.9df2		66 12						ror $12					      ROR   nums_2            ; shift middle byte
7241		.9df4		66 13						ror $13					      ROR   nums_3            ; shift lowest byte bit 0 to carry
7242		.9df6		8a							txa							      TXA                     ; load with "0"/2
7243		.9df7		2a							rol a						      ROL                     ; shift in carry
7244		.9df8		91 ad						sta ($ad),y			      STA   (str_pl),Y        ; save to temp string + index
7245		.9dfa		88							dey							      DEY                     ; decrement index
7246		.9dfb		10 f3						bpl $9df0				      BPL   NextB1            ; loop if not done
7248		.9dfd		a5 78						lda $78					      LDA   TempB             ; get # of characters
7249		.9dff		f0 0a						beq $9e0b				      BEQ   EndBHS            ; branch if truncate
7251		.9e01		aa							tax							      TAX                     ; copy length to X
7252		.9e02		38							sec							      SEC                     ; set carry for add !
7253		.9e03		49 ff						eor #$ff				      EOR   #$FF              ; 1's complement
7254		.9e05		69 18						adc #$18				      ADC   #$18              ; add 24d
7255		.9e07		f0 1c						beq $9e25				      BEQ   GoPr2             ; if zero print whole string
7257		.9e09		d0 0f						bne $9e1a				      BNE   GoPr1             ; else go make output string
7262		.9e0b																		EndBHS
7263		.9e0b		a8							tay							      TAY                     ; clear index (A=0, X=length here)
7264		.9e0c																		NextB2
7265		.9e0c		b1 ad						lda ($ad),y			      LDA   (str_pl),Y        ; get character from string
7266		.9e0e		c9 30						cmp #$30				      CMP   #'0'              ; compare with "0"
7267		.9e10		d0 07						bne $9e19				      BNE   GoPr              ; if not "0" then go print string from here
7269		.9e12		ca							dex							      DEX                     ; decrement character count
7270		.9e13		f0 03						beq $9e18				      BEQ   GoPr3             ; if zero then end of string so go print it
7272		.9e15		c8							iny							      INY                     ; else increment index
7273		.9e16		10 f4						bpl $9e0c				      BPL   NextB2            ; loop always
7277		.9e18																		GoPr3
7278		.9e18		e8							inx							      INX                     ; need at least 1 character
7279		.9e19																		GoPr
7280		.9e19		98							tya							      TYA                     ; copy result
7281		.9e1a																		GoPr1
7282		.9e1a		18							clc							      CLC                     ; clear carry for add
7283		.9e1b		65 ad						adc $ad					      ADC   str_pl            ; add low address
7284		.9e1d		85 ad						sta $ad					      STA   str_pl            ; save low address
7285		.9e1f		a9 00						lda #$00				      LDA   #$00              ; do high byte
7286		.9e21		65 ae						adc $ae					      ADC   str_ph            ; add high address
7287		.9e23		85 ae						sta $ae					      STA   str_ph            ; save high address
7288		.9e25																		GoPr2
7289		.9e25		86 ac						stx $ac					      STX   str_ln            ; X holds string length
7290		.9e27		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
7291		.9e2a		4c 95 91				jmp $9195				      JMP   LAB_RTST          ; check for space on descriptor stack then put address
7294		.9e2d																		BinFErr
7295		.9e2d		4c 37 8f				jmp $8f37				      JMP   LAB_FCER          ; do function call error then warm start
7299		.9e30																		LAB_HEXS
7300		.9e30		e0 07						cpx #$07				      CPX   #$07              ; max + 1
7301		.9e32		b0 f9						bcs $9e2d				      BCS   BinFErr           ; exit if too big ( > or = )
7303		.9e34		86 78						stx $78					      STX   TempB             ; save # of characters
7305		.9e36		a9 06						lda #$06				      LDA   #$06              ; need 6 bytes for string
7306		.9e38		20 48 91				jsr $9148				      JSR   LAB_MSSP          ; make string space A bytes long
7307		.9e3b		a0 05						ldy #$05				      LDY   #$05              ; set string index
7311		.9e3d		a5 13						lda $13					      LDA   nums_3            ; get lowest byte
7312		.9e3f		20 5c 9e				jsr $9e5c				      JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
7313		.9e42		a5 12						lda $12					      LDA   nums_2            ; get middle byte
7314		.9e44		20 5c 9e				jsr $9e5c				      JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
7315		.9e47		a5 11						lda $11					      LDA   nums_1            ; get highest byte
7316		.9e49		20 5c 9e				jsr $9e5c				      JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
7320		.9e4c		a2 06						ldx #$06				      LDX   #$06              ; character count
7321		.9e4e		a5 78						lda $78					      LDA   TempB             ; get # of characters
7322		.9e50		f0 b9						beq $9e0b				      BEQ   EndBHS            ; branch if truncate
7324		.9e52		aa							tax							      TAX                     ; copy length to X
7325		.9e53		38							sec							      SEC                     ; set carry for add !
7326		.9e54		49 ff						eor #$ff				      EOR   #$FF              ; 1's complement
7327		.9e56		69 06						adc #$06				      ADC   #$06              ; add 6d
7328		.9e58		f0 cb						beq $9e25				      BEQ   GoPr2             ; if zero print whole string
7330		.9e5a		d0 be						bne $9e1a				      BNE   GoPr1             ; else go make output string (branch always)
7334		.9e5c																		LAB_A2HX
7335		.9e5c		aa							tax							      TAX                     ; save byte
7336		.9e5d		29 0f						and #$0f				      AND   #$0F              ; mask off top bits
7337		.9e5f		20 67 9e				jsr $9e67				      JSR   LAB_AL2X          ; convert low nibble to ASCII and output
7338		.9e62		8a							txa							      TXA                     ; get byte back
7339		.9e63		4a							lsr a						      LSR                     ; /2  shift high nibble to low nibble
7340		.9e64		4a							lsr a						      LSR                     ; /4
7341		.9e65		4a							lsr a						      LSR                     ; /8
7342		.9e66		4a							lsr a						      LSR                     ; /16
7343		.9e67																		LAB_AL2X
7344		.9e67		c9 0a						cmp #$0a				      CMP   #$0A              ; set carry for +1 if >9
7347		.9e69		90 02						bcc $9e6d				      BCC   LAB_AL20          ; skip adjust if <= 9
7348		.9e6b		69 06						adc #$06				      ADC   #$06              ; adjust for A to F
7349		.9e6d																		LAB_AL20
7351		.9e6d		69 30						adc #$30				      ADC   #'0'              ; add ASCII "0"
7352		.9e6f		91 ad						sta ($ad),y			      STA   (str_pl),Y        ; save to temp string
7353		.9e71		88							dey							      DEY                     ; decrement counter
7354		.9e72		60							rts							      RTS
7356		.9e73																		LAB_NLTO
7357		.9e73		85 ac						sta $ac					      STA   FAC1_e            ; save FAC1 exponent
7358		.9e75		a9 00						lda #$00				      LDA   #$00              ; clear sign compare
7359		.9e77																		LAB_MLTE
7360		.9e77		85 b8						sta $b8					      STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
7361		.9e79		8a							txa							      TXA                     ; restore character
7362		.9e7a		20 52 9a				jsr $9a52				      JSR   LAB_2912          ; evaluate new ASCII digit
7367		.9e7d																		LAB_CHEX
7368		.9e7d		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment and scan memory
7369		.9e80		90 0a						bcc $9e8c				      BCC   LAB_ISHN          ; branch if numeric character
7371		.9e82		09 20						ora #$20				      ORA   #$20              ; case convert, allow "A" to "F" and "a" to "f"
7372		.9e84		e9 61						sbc #$61				      SBC   #'a'              ; subtract "a" (carry set here)
7373		.9e86		c9 06						cmp #$06				      CMP   #$06              ; compare normalised with $06 (max+1)
7374		.9e88		b0 2a						bcs $9eb4				      BCS   LAB_EXCH          ; exit if >"f" or <"0"
7376		.9e8a		69 0a						adc #$0a				      ADC   #$0A              ; convert to nibble
7377		.9e8c																		LAB_ISHN
7378		.9e8c		29 0f						and #$0f				      AND   #$0F              ; convert to binary
7379		.9e8e		aa							tax							      TAX                     ; save nibble
7380		.9e8f		a5 ac						lda $ac					      LDA   FAC1_e            ; get FAC1 exponent
7381		.9e91		f0 e4						beq $9e77				      BEQ   LAB_MLTE          ; skip multiply if zero
7383		.9e93		69 04						adc #$04				      ADC   #$04              ; add four to exponent (*16 - carry clear here)
7384		.9e95		90 dc						bcc $9e73				      BCC   LAB_NLTO          ; if no overflow do evaluate digit
7386		.9e97																		LAB_MLTO
7387		.9e97		4c d0 96				jmp $96d0				      JMP   LAB_2564          ; do overflow error and warm start
7389		.9e9a																		LAB_NXCH
7390		.9e9a		aa							tax							      TAX                     ; save bit
7391		.9e9b		a5 ac						lda $ac					      LDA   FAC1_e            ; get FAC1 exponent
7392		.9e9d		f0 06						beq $9ea5				      BEQ   LAB_MLBT          ; skip multiply if zero
7394		.9e9f		e6 ac						inc $ac					      INC   FAC1_e            ; increment FAC1 exponent (*2)
7395		.9ea1		f0 f4						beq $9e97				      BEQ   LAB_MLTO          ; do overflow error if = $00
7397		.9ea3		a9 00						lda #$00				      LDA   #$00              ; clear sign compare
7398		.9ea5																		LAB_MLBT
7399		.9ea5		85 b8						sta $b8					      STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
7400		.9ea7		8a							txa							      TXA                     ; restore bit
7401		.9ea8		20 52 9a				jsr $9a52				      JSR   LAB_2912          ; evaluate new ASCII digit
7406		.9eab																		LAB_CBIN
7407		.9eab		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment and scan memory
7408		.9eae		49 30						eor #$30				      EOR   #'0'              ; convert "0" to 0 etc.
7409		.9eb0		c9 02						cmp #$02				      CMP   #$02              ; compare with max+1
7410		.9eb2		90 e6						bcc $9e9a				      BCC   LAB_NXCH          ; branch exit if < 2
7412		.9eb4																		LAB_EXCH
7413		.9eb4		4c 37 9a				jmp $9a37				      JMP   LAB_28F6          ; evaluate -ve flag and return
7418		.9eb7																		CTRLC
7419		.9eb7		ad 00 02				lda $0200				      LDA   ccflag            ; get [CTRL-C] check flag
7420		.9eba		d0 18						bne $9ed4				      BNE   LAB_FBA2          ; exit if inhibited
7422		.9ebc		20 f9 a0				jsr $a0f9				      JSR   V_INPT            ; scan input device
7423		.9ebf		90 0b						bcc $9ecc				      BCC   LAB_FBA0          ; exit if buffer empty
7425		.9ec1		8d 01 02				sta $0201				      STA   ccbyte            ; save received byte
7426		.9ec4		a2 20						ldx #$20				      LDX   #$20              ; "life" timer for bytes
7427		.9ec6		8e 02 02				stx $0202				      STX   ccnull            ; set countdown
7428		.9ec9		4c 19 85				jmp $8519				      JMP   LAB_1636          ; return to BASIC
7430		.9ecc																		LAB_FBA0
7431		.9ecc		ae 02 02				ldx $0202				      LDX   ccnull            ; get countdown byte
7432		.9ecf		f0 03						beq $9ed4				      BEQ   LAB_FBA2          ; exit if finished
7434		.9ed1		ce 02 02				dec $0202				      DEC   ccnull            ; else decrement countdown
7435		.9ed4																		LAB_FBA2
7436		.9ed4		a2 dc						ldx #$dc				      LDX   #NmiBase          ; set pointer to NMI values
7437		.9ed6		20 df 9e				jsr $9edf				      JSR   LAB_CKIN          ; go check interrupt
7438		.9ed9		a2 df						ldx #$df				      LDX   #IrqBase          ; set pointer to IRQ values
7439		.9edb		20 df 9e				jsr $9edf				      JSR   LAB_CKIN          ; go check interrupt
7440		.9ede																		LAB_CRTS
7441		.9ede		60							rts							      RTS
7445		.9edf																		LAB_CKIN
7446		.9edf		b5 00						lda $00,x				      LDA   PLUS_0,X          ; get interrupt flag byte
7447		.9ee1		10 fb						bpl $9ede				      BPL   LAB_CRTS          ; branch if interrupt not enabled
7452		.9ee3		0a							asl a						      ASL                     ; move happened bit to setup bit
7453		.9ee4		29 40						and #$40				      AND   #$40              ; mask happened bits
7454		.9ee6		f0 f6						beq $9ede				      BEQ   LAB_CRTS          ; if no interrupt then exit
7456		.9ee8		95 00						sta $00,x				      STA   PLUS_0,X          ; save interrupt flag byte
7458		.9eea		8a							txa							      TXA                     ; copy index ..
7459		.9eeb		a8							tay							      TAY                     ; .. to Y
7461		.9eec		68							pla							      PLA                     ; dump return address low byte, call from CTRL-C
7462		.9eed		68							pla							      PLA                     ; dump return address high byte
7464		.9eee		a9 05						lda #$05				      LDA   #$05              ; need 5 bytes for GOSUB
7465		.9ef0		20 03 81				jsr $8103				      JSR   LAB_1212          ; check room on stack for A bytes
7466		.9ef3		a5 c4						lda $c4					      LDA   Bpntrh            ; get BASIC execute pointer high byte
7467		.9ef5		48							pha							      PHA                     ; push on stack
7468		.9ef6		a5 c3						lda $c3					      LDA   Bpntrl            ; get BASIC execute pointer low byte
7469		.9ef8		48							pha							      PHA                     ; push on stack
7470		.9ef9		a5 88						lda $88					      LDA   Clineh            ; get current line high byte
7471		.9efb		48							pha							      PHA                     ; push on stack
7472		.9efc		a5 87						lda $87					      LDA   Clinel            ; get current line low byte
7473		.9efe		48							pha							      PHA                     ; push on stack
7474		.9eff		a9 8d						lda #$8d				      LDA   #TK_GOSUB         ; token for GOSUB
7475		.9f01		48							pha							      PHA                     ; push on stack
7477		.9f02		b9 01 00				lda $0001,y			      LDA   PLUS_1,Y          ; get interrupt code pointer low byte
7478		.9f05		85 c3						sta $c3					      STA   Bpntrl            ; save as BASIC execute pointer low byte
7479		.9f07		b9 02 00				lda $0002,y			      LDA   PLUS_2,Y          ; get interrupt code pointer high byte
7480		.9f0a		85 c4						sta $c4					      STA   Bpntrh            ; save as BASIC execute pointer high byte
7482		.9f0c		4c c0 84				jmp $84c0				      JMP   LAB_15C2          ; go do interpreter inner loop
7490		.9f0f																		INGET
7491		.9f0f		20 f9 a0				jsr $a0f9				      JSR   V_INPT            ; call scan input device
7492		.9f12		b0 09						bcs $9f1d				      BCS   LAB_FB95          ; if byte go reset timer
7494		.9f14		ad 02 02				lda $0202				      LDA   ccnull            ; get countdown
7495		.9f17		f0 09						beq $9f22				      BEQ   LAB_FB96          ; exit if empty
7497		.9f19		ad 01 02				lda $0201				      LDA   ccbyte            ; get last received byte
7498		.9f1c		38							sec							      SEC                     ; flag we got a byte
7499		.9f1d																		LAB_FB95
7500		.9f1d		a2 00						ldx #$00				      LDX   #$00              ; clear X
7501		.9f1f		8e 02 02				stx $0202				      STX   ccnull            ; clear timer because we got a byte
7502		.9f22																		LAB_FB96
7503		.9f22		60							rts							      RTS
7510		.9f23																		LAB_IRQ
7511		.9f23		a2 df						ldx #$df				      LDX   #IrqBase          ; set pointer to IRQ values
7512		>9f25		2c															      .byte $2C               ; make next line BIT abs.
7516		.9f26																		LAB_NMI
7517		.9f26		a2 dc						ldx #$dc				      LDX   #NmiBase          ; set pointer to NMI values
7518		.9f28		c9 93						cmp #$93				      CMP   #TK_ON            ; compare with token for ON
7519		.9f2a		f0 11						beq $9f3d				      BEQ   LAB_INON          ; go turn on interrupt
7521		.9f2c		c9 b5						cmp #$b5				      CMP   #TK_OFF           ; compare with token for OFF
7522		.9f2e		f0 07						beq $9f37				      BEQ   LAB_IOFF          ; go turn off interrupt
7524		.9f30		49 a2						eor #$a2				      EOR   #TK_CLEAR         ; compare with token for CLEAR, A = $00 if = TK_CLEAR
7525		.9f32		f0 0e						beq $9f42				      BEQ   LAB_INEX          ; go clear interrupt flags and return
7527		.9f34		4c 02 8c				jmp $8c02				      JMP   LAB_SNER          ; do syntax error then warm start
7529		.9f37																		LAB_IOFF
7530		.9f37		a9 7f						lda #$7f				      LDA   #$7F              ; clear A
7531		.9f39		35 00						and $00,x				      AND   PLUS_0,X          ; AND with interrupt setup flag
7532		.9f3b		10 05						bpl $9f42				      BPL   LAB_INEX          ; go clear interrupt enabled flag and return
7534		.9f3d																		LAB_INON
7535		.9f3d		b5 00						lda $00,x				      LDA   PLUS_0,X          ; get interrupt setup flag
7536		.9f3f		0a							asl a						      ASL                     ; Shift bit to enabled flag
7537		.9f40		15 00						ora $00,x				      ORA   PLUS_0,X          ; OR with flag byte
7538		.9f42																		LAB_INEX
7539		.9f42		95 00						sta $00,x				      STA   PLUS_0,X          ; save interrupt flag byte
7540		.9f44		4c bc 00				jmp $00bc				      JMP   LAB_IGBY          ; update BASIC execute pointer and return
7547		.9f47																		LAB_SIRQ
7548		.9f47		58							cli							      CLI                     ; enable interrupts
7549		.9f48		a2 df						ldx #$df				      LDX   #IrqBase          ; set pointer to IRQ values
7550		>9f4a		2c															      .byte $2C               ; make next line BIT abs.
7554		.9f4b																		LAB_SNMI
7555		.9f4b		a2 dc						ldx #$dc				      LDX   #NmiBase          ; set pointer to NMI values
7557		.9f4d		86 78						stx $78					      STX   TempB             ; save interrupt pointer
7558		.9f4f		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment and scan memory (past token)
7559		.9f52		20 56 87				jsr $8756				      JSR   LAB_GFPN          ; get fixed-point number into temp integer
7560		.9f55		a5 79						lda $79					      LDA   Smeml             ; get start of mem low byte
7561		.9f57		a6 7a						ldx $7a					      LDX   Smemh             ; get start of mem high byte
7562		.9f59		20 2b 83				jsr $832b				      JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
7563		.9f5c		b0 03						bcs $9f61				      BCS   LAB_LFND          ; if carry set go set-up interrupt
7565		.9f5e		4c 70 86				jmp $8670				      JMP   LAB_16F7          ; else go do "Undefined statement" error and warm start
7567		.9f61																		LAB_LFND
7568		.9f61		a6 78						ldx $78					      LDX   TempB             ; get interrupt pointer
7569		.9f63		a5 aa						lda $aa					      LDA   Baslnl            ; get pointer low byte
7570		.9f65		e9 01						sbc #$01				      SBC   #$01              ; -1 (carry already set for subtract)
7571		.9f67		95 01						sta $01,x				      STA   PLUS_1,X          ; save as interrupt pointer low byte
7572		.9f69		a5 ab						lda $ab					      LDA   Baslnh            ; get pointer high byte
7573		.9f6b		e9 00						sbc #$00				      SBC   #$00              ; subtract carry
7574		.9f6d		95 02						sta $02,x				      STA   PLUS_2,X          ; save as interrupt pointer high byte
7576		.9f6f		a9 c0						lda #$c0				      LDA   #$C0              ; set interrupt enabled/setup bits
7577		.9f71		95 00						sta $00,x				      STA   PLUS_0,X          ; set interrupt flags
7578		.9f73																		LAB_IRTS
7579		.9f73		60							rts							      RTS
7585		.9f74																		LAB_RETIRQ
7586		.9f74		d0 fd						bne $9f73				      BNE   LAB_IRTS          ; exit if following token (to allow syntax error)
7588		.9f76		a5 df						lda $df					      LDA   IrqBase           ; get interrupt flags
7589		.9f78		0a							asl a						      ASL                     ; copy setup to enabled (b7)
7590		.9f79		05 df						ora $df					      ORA   IrqBase           ; OR in setup flag
7591		.9f7b		85 df						sta $df					      STA   IrqBase           ; save enabled flag
7592		.9f7d		4c 77 86				jmp $8677				      JMP   LAB_16E8          ; go do rest of RETURN
7598		.9f80																		LAB_RETNMI
7599		.9f80		d0 f1						bne $9f73				      BNE   LAB_IRTS          ; exit if following token (to allow syntax error)
7601		.9f82		a5 dc						lda $dc					      LDA   NmiBase           ; get set-up flag
7602		.9f84		0a							asl a						      ASL                     ; copy setup to enabled (b7)
7603		.9f85		05 dc						ora $dc					      ORA   NmiBase           ; OR in setup flag
7604		.9f87		85 dc						sta $dc					      STA   NmiBase           ; save enabled flag
7605		.9f89		4c 77 86				jmp $8677				      JMP   LAB_16E8          ; go do rest of RETURN
7609		.9f8c																		LAB_MMPP
7610		.9f8c		20 e9 8a				jsr $8ae9				      JSR   LAB_EVEZ          ; process expression
7611		.9f8f		4c d0 8a				jmp $8ad0				      JMP   LAB_CTNM          ; check if source is numeric, else do type mismatch
7615		.9f92																		LAB_MAX
7616		.9f92		20 c0 9f				jsr $9fc0				      JSR   LAB_PHFA          ; push FAC1, evaluate expression,
7618		.9f95		10 fb						bpl $9f92				      BPL   LAB_MAX           ; branch if no swap to do
7620		.9f97		a5 b4						lda $b4					      LDA   FAC2_1            ; get FAC2 mantissa1
7621		.9f99		09 80						ora #$80				      ORA   #$80              ; set top bit (clear sign from compare)
7622		.9f9b		85 b4						sta $b4					      STA   FAC2_1            ; save FAC2 mantissa1
7623		.9f9d		20 d0 95				jsr $95d0				      JSR   LAB_279B          ; copy FAC2 to FAC1
7624		.9fa0		f0 f0						beq $9f92				      BEQ   LAB_MAX           ; go do next (branch always)
7628		.9fa2																		LAB_MIN
7629		.9fa2		20 c0 9f				jsr $9fc0				      JSR   LAB_PHFA          ; push FAC1, evaluate expression,
7631		.9fa5		30 fb						bmi $9fa2				      BMI   LAB_MIN           ; branch if no swap to do
7633		.9fa7		f0 f9						beq $9fa2				      BEQ   LAB_MIN           ; branch if no swap to do
7635		.9fa9		a5 b4						lda $b4					      LDA   FAC2_1            ; get FAC2 mantissa1
7636		.9fab		09 80						ora #$80				      ORA   #$80              ; set top bit (clear sign from compare)
7637		.9fad		85 b4						sta $b4					      STA   FAC2_1            ; save FAC2 mantissa1
7638		.9faf		20 d0 95				jsr $95d0				      JSR   LAB_279B          ; copy FAC2 to FAC1
7639		.9fb2		f0 ee						beq $9fa2				      BEQ   LAB_MIN           ; go do next (branch always)
7644		.9fb4																		LAB_MMEC
7645		.9fb4		c9 29						cmp #$29				      CMP   #')'              ; is it end of function?
7646		.9fb6		d0 05						bne $9fbd				      BNE   LAB_MMSE          ; if not do MAX MIN syntax error
7648		.9fb8		68							pla							      PLA                     ; dump return address low byte
7649		.9fb9		68							pla							      PLA                     ; dump return address high byte
7650		.9fba		4c bc 00				jmp $00bc				      JMP   LAB_IGBY          ; update BASIC execute pointer (to chr past ")")
7652		.9fbd																		LAB_MMSE
7653		.9fbd		4c 02 8c				jmp $8c02				      JMP   LAB_SNER          ; do syntax error then warm start
7658		.9fc0																		LAB_PHFA
7659		.9fc0		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; get next BASIC byte
7660		.9fc3		c9 2c						cmp #$2c				      CMP   #','              ; is there more ?
7661		.9fc5		d0 ed						bne $9fb4				      BNE   LAB_MMEC          ; if not go do end check
7664		.9fc7		20 e6 98				jsr $98e6				      JSR   LAB_27BA          ; round FAC1
7665		.9fca		a5 b0						lda $b0					      LDA   FAC1_s            ; get FAC1 sign
7666		.9fcc		09 7f						ora #$7f				      ORA   #$7F              ; set all non sign bits
7667		.9fce		25 ad						and $ad					      AND   FAC1_1            ; AND FAC1 mantissa1 (AND in sign bit)
7668		.9fd0		48							pha							      PHA                     ; push on stack
7669		.9fd1		a5 ae						lda $ae					      LDA   FAC1_2            ; get FAC1 mantissa2
7670		.9fd3		48							pha							      PHA                     ; push on stack
7671		.9fd4		a5 af						lda $af					      LDA   FAC1_3            ; get FAC1 mantissa3
7672		.9fd6		48							pha							      PHA                     ; push on stack
7673		.9fd7		a5 ac						lda $ac					      LDA   FAC1_e            ; get FAC1 exponent
7674		.9fd9		48							pha							      PHA                     ; push on stack
7676		.9fda		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; scan and get next BASIC byte (after ",")
7677		.9fdd		20 cd 8a				jsr $8acd				      JSR   LAB_EVNM          ; evaluate expression and check is numeric,
7681		.9fe0		68							pla							      PLA                     ; pop exponent
7682		.9fe1		85 b3						sta $b3					      STA   FAC2_e            ; save FAC2 exponent
7683		.9fe3		68							pla							      PLA                     ; pop mantissa3
7684		.9fe4		85 b6						sta $b6					      STA   FAC2_3            ; save FAC2 mantissa3
7685		.9fe6		68							pla							      PLA                     ; pop mantissa1
7686		.9fe7		85 b5						sta $b5					      STA   FAC2_2            ; save FAC2 mantissa2
7687		.9fe9		68							pla							      PLA                     ; pop sign/mantissa1
7688		.9fea		85 b4						sta $b4					      STA   FAC2_1            ; save FAC2 sign/mantissa1
7689		.9fec		85 b7						sta $b7					      STA   FAC2_s            ; save FAC2 sign
7692		.9fee		a9 b3						lda #$b3				      LDA   #<FAC2_e          ; set pointer low byte to FAC2
7693		.9ff0		a0 00						ldy #$00				      LDY   #>FAC2_e          ; set pointer high byte to FAC2
7694		.9ff2		4c 24 99				jmp $9924				      JMP   LAB_27F8          ; compare FAC1 with FAC2 (AY) and return
7701		.9ff5																		LAB_WDTH
7702		.9ff5		c9 2c						cmp #$2c				      CMP   #','              ; is next byte ","
7703		.9ff7		f0 1b						beq $a014				      BEQ   LAB_TBSZ          ; if so do tab size
7705		.9ff9		20 a0 94				jsr $94a0				      JSR   LAB_GTBY          ; get byte parameter
7706		.9ffc		8a							txa							      TXA                     ; copy width to A
7707		.9ffd		f0 0a						beq $a009				      BEQ   LAB_NSTT          ; branch if set for infinite line
7709		.9fff		e0 10						cpx #$10				      CPX   #$10              ; else make min width = 16d
7710		.a001		90 45						bcc $a048				      BCC   TabErr            ; if less do function call error and exit
7715		.a003		e4 64						cpx $64					      CPX   TabSiz            ; compare with tab size
7716		.a005		b0 02						bcs $a009				      BCS   LAB_NSTT          ; branch if >= tab size
7718		.a007		86 64						stx $64					      STX   TabSiz            ; else make tab size = terminal width
7719		.a009																		LAB_NSTT
7720		.a009		86 0f						stx $0f					      STX   TWidth            ; set the terminal width
7721		.a00b		20 c2 00				jsr $00c2				      JSR   LAB_GBYT          ; get BASIC byte back
7722		.a00e		f0 1a						beq $a02a				      BEQ   WExit             ; exit if no following
7724		.a010		c9 2c						cmp #$2c				      CMP   #','              ; else is it ","
7725		.a012		d0 a9						bne $9fbd				      BNE   LAB_MMSE          ; if not do syntax error
7727		.a014																		LAB_TBSZ
7728		.a014		20 9d 94				jsr $949d				      JSR   LAB_SGBY          ; scan and get byte parameter
7729		.a017		8a							txa							      TXA                     ; copy TAB size
7730		.a018		30 2e						bmi $a048				      BMI   TabErr            ; if >127 do function call error and exit
7732		.a01a		e0 01						cpx #$01				      CPX   #$01              ; compare with min-1
7733		.a01c		90 2a						bcc $a048				      BCC   TabErr            ; if <=1 do function call error and exit
7735		.a01e		a5 0f						lda $0f					      LDA   TWidth            ; set flags for width
7736		.a020		f0 06						beq $a028				      BEQ   LAB_SVTB          ; skip check if infinite line
7738		.a022		e4 0f						cpx $0f					      CPX   TWidth            ; compare TAB with width
7739		.a024		f0 02						beq $a028				      BEQ   LAB_SVTB          ; ok if =
7741		.a026		b0 20						bcs $a048				      BCS   TabErr            ; branch if too big
7743		.a028																		LAB_SVTB
7744		.a028		86 64						stx $64					      STX   TabSiz            ; save TAB size
7750		.a02a																		WExit
7751		.a02a		a5 0f						lda $0f					      LDA   TWidth            ; get width
7752		.a02c		f0 06						beq $a034				      BEQ   LAB_SULP          ; branch if infinite line
7754		.a02e		c5 64						cmp $64					      CMP   TabSiz            ; compare with tab size
7755		.a030		b0 03						bcs $a035				      BCS   LAB_WDLP          ; branch if >= tab size
7757		.a032		85 64						sta $64					      STA   TabSiz            ; else make tab size = terminal width
7758		.a034																		LAB_SULP
7759		.a034		38							sec							      SEC                     ; set carry for subtract
7760		.a035																		LAB_WDLP
7761		.a035		e5 64						sbc $64					      SBC   TabSiz            ; subtract tab size
7762		.a037		b0 fc						bcs $a035				      BCS   LAB_WDLP          ; loop while no borrow
7764		.a039		65 64						adc $64					      ADC   TabSiz            ; add tab size back
7765		.a03b		18							clc							      CLC                     ; clear carry for add
7766		.a03c		65 64						adc $64					      ADC   TabSiz            ; add tab size back again
7767		.a03e		85 10						sta $10					      STA   Iclim             ; save for now
7768		.a040		a5 0f						lda $0f					      LDA   TWidth            ; get width back
7769		.a042		38							sec							      SEC                     ; set carry for subtract
7770		.a043		e5 10						sbc $10					      SBC   Iclim             ; subtract remainder
7771		.a045		85 10						sta $10					      STA   Iclim             ; save tab column limit
7772		.a047																		LAB_NOSQ
7773		.a047		60							rts							      RTS
7775		.a048																		TabErr
7776		.a048		4c 37 8f				jmp $8f37				      JMP   LAB_FCER          ; do function call error then warm start
7780		.a04b																		LAB_SQR
7781		.a04b		a5 b0						lda $b0					      LDA   FAC1_s            ; get FAC1 sign
7782		.a04d		30 f9						bmi $a048				      BMI   TabErr            ; if -ve do function call error
7784		.a04f		a5 ac						lda $ac					      LDA   FAC1_e            ; get exponent
7785		.a051		f0 f4						beq $a047				      BEQ   LAB_NOSQ          ; if zero just return
7788		.a053		20 d7 98				jsr $98d7				      JSR   LAB_27AB          ; round and copy FAC1 to FAC2
7789		.a056		a9 00						lda #$00				      LDA   #$00              ; clear A
7791		.a058		85 77						sta $77					      STA   FACt_3            ; clear remainder
7792		.a05a		85 76						sta $76					      STA   FACt_2            ; ..
7793		.a05c		85 75						sta $75					      STA   FACt_1            ; ..
7794		.a05e		85 78						sta $78					      STA   TempB             ; ..
7796		.a060		85 af						sta $af					      STA   FAC1_3            ; clear root
7797		.a062		85 ae						sta $ae					      STA   FAC1_2            ; ..
7798		.a064		85 ad						sta $ad					      STA   FAC1_1            ; ..
7800		.a066		a2 18						ldx #$18				      LDX   #$18              ; 24 pairs of bits to do
7801		.a068		a5 b3						lda $b3					      LDA   FAC2_e            ; get exponent
7802		.a06a		4a							lsr a						      LSR                     ; check odd/even
7803		.a06b		b0 0e						bcs $a07b				      BCS   LAB_SQE2          ; if odd only 1 shift first time
7805		.a06d																		LAB_SQE1
7806		.a06d		06 b6						asl $b6					      ASL   FAC2_3            ; shift highest bit of number ..
7807		.a06f		26 b5						rol $b5					      ROL   FAC2_2            ; ..
7808		.a071		26 b4						rol $b4					      ROL   FAC2_1            ; ..
7809		.a073		26 77						rol $77					      ROL   FACt_3            ; .. into remainder
7810		.a075		26 76						rol $76					      ROL   FACt_2            ; ..
7811		.a077		26 75						rol $75					      ROL   FACt_1            ; ..
7812		.a079		26 78						rol $78					      ROL   TempB             ; .. never overflows
7813		.a07b																		LAB_SQE2
7814		.a07b		06 b6						asl $b6					      ASL   FAC2_3            ; shift highest bit of number ..
7815		.a07d		26 b5						rol $b5					      ROL   FAC2_2            ; ..
7816		.a07f		26 b4						rol $b4					      ROL   FAC2_1            ; ..
7817		.a081		26 77						rol $77					      ROL   FACt_3            ; .. into remainder
7818		.a083		26 76						rol $76					      ROL   FACt_2            ; ..
7819		.a085		26 75						rol $75					      ROL   FACt_1            ; ..
7820		.a087		26 78						rol $78					      ROL   TempB             ; .. never overflows
7822		.a089		06 af						asl $af					      ASL   FAC1_3            ; root = root * 2
7823		.a08b		26 ae						rol $ae					      ROL   FAC1_2            ; ..
7824		.a08d		26 ad						rol $ad					      ROL   FAC1_1            ; .. never overflows
7826		.a08f		a5 af						lda $af					      LDA   FAC1_3            ; get root low byte
7827		.a091		2a							rol a						      ROL                     ; *2
7828		.a092		85 5b						sta $5b					      STA   Temp3             ; save partial low byte
7829		.a094		a5 ae						lda $ae					      LDA   FAC1_2            ; get root low mid byte
7830		.a096		2a							rol a						      ROL                     ; *2
7831		.a097		85 5c						sta $5c					      STA   Temp3+1           ; save partial low mid byte
7832		.a099		a5 ad						lda $ad					      LDA   FAC1_1            ; get root high mid byte
7833		.a09b		2a							rol a						      ROL                     ; *2
7834		.a09c		85 5d						sta $5d					      STA   Temp3+2           ; save partial high mid byte
7835		.a09e		a9 00						lda #$00				      LDA   #$00              ; get root high byte (always $00)
7836		.a0a0		2a							rol a						      ROL                     ; *2
7837		.a0a1		85 5e						sta $5e					      STA   Temp3+3           ; save partial high byte
7840		.a0a3		a5 77						lda $77					      LDA   FACt_3            ; get remainder low byte
7841		.a0a5		e5 5b						sbc $5b					      SBC   Temp3             ; subtract partial low byte
7842		.a0a7		85 5b						sta $5b					      STA   Temp3             ; save partial low byte
7844		.a0a9		a5 76						lda $76					      LDA   FACt_2            ; get remainder low mid byte
7845		.a0ab		e5 5c						sbc $5c					      SBC   Temp3+1           ; subtract partial low mid byte
7846		.a0ad		85 5c						sta $5c					      STA   Temp3+1           ; save partial low mid byte
7848		.a0af		a5 75						lda $75					      LDA   FACt_1            ; get remainder high mid byte
7849		.a0b1		e5 5d						sbc $5d					      SBC   Temp3+2           ; subtract partial high mid byte
7850		.a0b3		a8							tay							      TAY                     ; copy partial high mid byte
7852		.a0b4		a5 78						lda $78					      LDA   TempB             ; get remainder high byte
7853		.a0b6		e5 5e						sbc $5e					      SBC   Temp3+3           ; subtract partial high byte
7854		.a0b8		90 0e						bcc $a0c8				      BCC   LAB_SQNS          ; skip sub if remainder smaller
7856		.a0ba		85 78						sta $78					      STA   TempB             ; save remainder high byte
7858		.a0bc		84 75						sty $75					      STY   FACt_1            ; save remainder high mid byte
7860		.a0be		a5 5c						lda $5c					      LDA   Temp3+1           ; get remainder low mid byte
7861		.a0c0		85 76						sta $76					      STA   FACt_2            ; save remainder low mid byte
7863		.a0c2		a5 5b						lda $5b					      LDA   Temp3             ; get partial low byte
7864		.a0c4		85 77						sta $77					      STA   FACt_3            ; save remainder low byte
7866		.a0c6		e6 af						inc $af					      INC   FAC1_3            ; increment root low byte (never any rollover)
7867		.a0c8																		LAB_SQNS
7868		.a0c8		ca							dex							      DEX                     ; decrement bit pair count
7869		.a0c9		d0 a2						bne $a06d				      BNE   LAB_SQE1          ; loop if not all done
7871		.a0cb		38							sec							      SEC                     ; set carry for subtract
7872		.a0cc		a5 b3						lda $b3					      LDA   FAC2_e            ; get exponent
7873		.a0ce		e9 80						sbc #$80				      SBC   #$80              ; normalise
7874		.a0d0		6a							ror a						      ROR                     ; /2 and re-bias to $80
7875		.a0d1		69 00						adc #$00				      ADC   #$00              ; add bit zero back in (allow for half shift)
7876		.a0d3		85 ac						sta $ac					      STA   FAC1_e            ; save it
7877		.a0d5		4c 41 96				jmp $9641				      JMP   LAB_24D5          ; normalise FAC1 and return
7881		.a0d8																		LAB_VARPTR
7882		.a0d8		20 bc 00				jsr $00bc				      JSR   LAB_IGBY          ; increment and scan memory
7883		.a0db		20 b8 8d				jsr $8db8				      JSR   LAB_GVAR          ; get var address
7884		.a0de		20 ef 8b				jsr $8bef				      JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
7885		.a0e1		a4 95						ldy $95					      LDY   Cvaral            ; get var address low byte
7886		.a0e3		a5 96						lda $96					      LDA   Cvarah            ; get var address high byte
7887		.a0e5		4c 67 90				jmp $9067				      JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
7891		.a0e8																		LAB_PI
7892		.a0e8		a9 cc						lda #$cc				      LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
7893		.a0ea		a0 a1						ldy #$a1				      LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
7894		.a0ec		20 8a 98				jsr $988a				      JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
7895		.a0ef		c6 ac						dec $ac					      DEC   FAC1_e            ; make result = PI
7896		.a0f1		60							rts							      RTS
7900		.a0f2																		LAB_TWOPI
7901		.a0f2		a9 cc						lda #$cc				      LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
7902		.a0f4		a0 a1						ldy #$a1				      LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
7903		.a0f6		4c 8a 98				jmp $988a				      JMP   LAB_UFAC          ; unpack memory (AY) into FAC1 and return
7908		.a0f9																		V_INPT
7909		.a0f9		6c 05 02				jmp ($0205)			      JMP   (VEC_IN)          ; non halting scan input device
7910		.a0fc																		V_OUTP
7911		.a0fc		6c 07 02				jmp ($0207)			      JMP   (VEC_OUT)         ; send byte to output device
7912		.a0ff																		V_LOAD
7913		.a0ff		6c 09 02				jmp ($0209)			      JMP   (VEC_LD)          ; load BASIC program
7914		.a102																		V_SAVE
7915		.a102		6c 0b 02				jmp ($020b)			      JMP   (VEC_SV)          ; save BASIC program
7921		.a105																		PG2_TABS
7922		>a105		00															      .byte $00               ; ctrl-c flag           -     $00 = enabled
7923		>a106		00															      .byte $00               ; ctrl-c byte           -     GET needs this
7924		>a107		00															      .byte $00               ; ctrl-c byte timeout   -     GET needs this
7925		>a108		b7 9e														      .word CTRLC             ; ctrl c check vector
7930		.a10a																		PG2_TABE
7947		.a10a																		LAB_2CEE
7948		.a10a		e6 c3						inc $c3					      INC   Bpntrl            ; increment BASIC execute pointer low byte
7949		.a10c		d0 02						bne $a110				      BNE   LAB_2CF4          ; branch if no carry
7951		.a10e		e6 c4						inc $c4					      INC   Bpntrh            ; increment BASIC execute pointer high byte
7956		.a110																		LAB_2CF4
7957		.a110		ad ff ff				lda $ffff				      LDA   $FFFF             ; get byte to scan (addr set by call routine)
7958		.a113		c9 ac						cmp #$ac				      CMP   #TK_ELSE          ; compare with the token for ELSE
7959		.a115		f0 0e						beq $a125				      BEQ   LAB_2D05          ; exit if ELSE, not numeric, carry set
7961		.a117		c9 3a						cmp #$3a				      CMP   #':'              ; compare with ":"
7962		.a119		b0 0a						bcs $a125				      BCS   LAB_2D05          ; exit if >= ":", not numeric, carry set
7964		.a11b		c9 20						cmp #$20				      CMP   #' '              ; compare with " "
7965		.a11d		f0 eb						beq $a10a				      BEQ   LAB_2CEE          ; if " " go do next
7967		.a11f		38							sec							      SEC                     ; set carry for SBC
7968		.a120		e9 30						sbc #$30				      SBC   #'0'              ; subtract "0"
7969		.a122		38							sec							      SEC                     ; set carry for SBC
7970		.a123		e9 d0						sbc #$d0				      SBC   #$D0              ; subtract -"0"
7972		.a125																		LAB_2D05
7973		.a125		60							rts							      RTS
7977		.a126																		StrTab
7978		>a126		4c															      .byte $4C               ; JMP opcode
7979		>a127		00 80														      .word LAB_COLD          ; initial warm start vector (cold start)
7981		>a129		00															      .byte $00               ; these bytes are not used by BASIC
7982		>a12a		00 00														      .word $0000             ;
7983		>a12c		00 00														      .word $0000             ;
7984		>a12e		00 00														      .word $0000             ;
7986		>a130		4c															      .byte $4C               ; JMP opcode
7987		>a131		37 8f														      .word LAB_FCER          ; initial user function vector ("Function call" error)
7988		>a133		00															      .byte $00               ; default NULL count
7989		>a134		00															      .byte $00               ; clear terminal position
7990		>a135		00															      .byte $00               ; default terminal width byte
7991		>a136		f2															      .byte $F2               ; default limit for TAB = 14
7992		>a137		00 03														      .word Ram_base          ; start of user RAM
7993		.a139																		EndTab
7995		.a139																		LAB_MSZM
7996		>a139		0d 0a 4d 65 6d 6f 72 79					      .text $0D,$0A,"Memory size ",$00
				>a141		20 73 69 7a 65 20 00
7998		.a148																		LAB_SMSG
7999		>a148		20 42 79 74 65 73 20 66					      .text " Bytes free",$0D,$0A,$0A
				>a150		72 65 65 0d 0a 0a
8000		>a156		45 6e 68 61 6e 63 65 64					      .text "Enhanced BASIC 2.22p5",$0A,$00
				>a15e		20 42 41 53 49 43 20 32 2e 32 32 70 35 0a 00
8005		.a16d																		LAB_25A0
8006		>a16d		02															      .byte $02               ; counter
8007		>a16e		80 19 56 62											      .byte $80,$19,$56,$62   ; 0.59898
8008		>a172		80 76 22 f3											      .byte $80,$76,$22,$F3   ; 0.96147
8010		>a176		82 38 aa 40											      .byte $82,$38,$AA,$40   ; 2.88539
8013		.a17a																		LAB_25AD
8014		>a17a		80 35 04 f3											      .byte $80,$35,$04,$F3   ; 0.70711   1/root 2
8015		.a17e																		LAB_25B1
8016		>a17e		81 35 04 f3											      .byte $81,$35,$04,$F3   ; 1.41421   root 2
8017		.a182																		LAB_25B5
8018		>a182		80 80 00 00											      .byte $80,$80,$00,$00   ; -0.5
8019		.a186																		LAB_25B9
8020		>a186		80 31 72 18											      .byte $80,$31,$72,$18   ; 0.69315   LOG(2)
8023		.a18a																		LAB_2947
8024		>a18a		91 43 4f f8											      .byte $91,$43,$4F,$F8   ; 99999.9375 (max value with at least one decimal)
8025		.a18e																		LAB_294B
8026		>a18e		94 74 23 f7											      .byte $94,$74,$23,$F7   ; 999999.4375 (max value before scientific notation)
8027		.a192																		LAB_294F
8028		>a192		94 74 24 00											      .byte $94,$74,$24,$00   ; 1000000
8031		.a196																		LAB_2AFA
8032		>a196		81 38 aa 3b											      .byte $81,$38,$AA,$3B   ; 1.4427    (1/LOG base 2 e)
8033		.a19a																		LAB_2AFE
8034		>a19a		06															      .byte $06               ; counter
8035		>a19b		74 63 90 8c											      .byte $74,$63,$90,$8C   ; 2.17023e-4
8036		>a19f		77 23 0c ab											      .byte $77,$23,$0C,$AB   ; 0.00124
8037		>a1a3		7a 1e 94 00											      .byte $7A,$1E,$94,$00   ; 0.00968
8038		>a1a7		7c 63 42 80											      .byte $7C,$63,$42,$80   ; 0.05548
8039		>a1ab		7e 75 fe d0											      .byte $7E,$75,$FE,$D0   ; 0.24023
8040		>a1af		80 31 72 15											      .byte $80,$31,$72,$15   ; 0.69315
8041		>a1b3		81 00 00 00											      .byte $81,$00,$00,$00   ; 1.00000
8054		.a1b7																		LAB_2C78
8055		>a1b7		81 49 0f db											      .byte $81,$49,$0F,$DB   ; 1.570796371 (pi/2) as floating #
8056		.a1bb																		LAB_2C84
8057		>a1bb		04															      .byte $04               ; counter
8058		>a1bc		86 1e d7 fb											      .byte $86,$1E,$D7,$FB   ; 39.7109
8060		>a1c0		87 99 26 65											      .byte $87,$99,$26,$65   ;-76.575
8062		>a1c4		87 23 34 58											      .byte $87,$23,$34,$58   ; 81.6022
8063		>a1c8		86 a5 5d e1											      .byte $86,$A5,$5D,$E1   ;-41.3417
8065		.a1cc																		LAB_2C7C
8066		>a1cc		83 49 0f db											      .byte $83,$49,$0F,$DB   ; 6.28319 (2*pi) as floating #
8069		.a1d0																		LAB_2CC9
8070		>a1d0		08															      .byte $08               ; counter
8071		>a1d1		78 3a c5 37											      .byte $78,$3A,$C5,$37   ; 0.00285
8072		>a1d5		7b 83 a2 5c											      .byte $7B,$83,$A2,$5C   ;-0.0160686
8073		>a1d9		7c 2e dd 4d											      .byte $7C,$2E,$DD,$4D   ; 0.0426915
8074		>a1dd		7d 99 b0 1e											      .byte $7D,$99,$B0,$1E   ;-0.0750429
8075		>a1e1		7d 59 ed 24											      .byte $7D,$59,$ED,$24   ; 0.106409
8076		>a1e5		7e 91 72 00											      .byte $7E,$91,$72,$00   ;-0.142036
8077		>a1e9		7e 4c b9 73											      .byte $7E,$4C,$B9,$73   ; 0.199926
8078		>a1ed		7f aa aa 53											      .byte $7F,$AA,$AA,$53   ;-0.333331
8090		=$a1f2																	LAB_1D96    = *+1             ; $00,$00 used for undefined variables
8091		.a1f1																		LAB_259C
8092		>a1f1		81 00 00 00											      .byte $81,$00,$00,$00   ; 1.000000, used for INC
8093		.a1f5																		LAB_2AFD
8094		>a1f5		81 80 00 00											      .byte $81,$80,$00,$00   ; -1.00000, used for DEC. must be on the same page as +1.00
8097		.a1f9																		LAB_1DF7
8098		>a1f9		90															      .byte $90               ;-32768 (uses first three bytes from 0.5)
8099		.a1fa																		LAB_2A96
8100		>a1fa		80 00 00 00											      .byte $80,$00,$00,$00   ; 0.5
8101		.a1fe																		LAB_2C80
8102		>a1fe		7f 00 00 00											      .byte $7F,$00,$00,$00   ; 0.25
8103		.a202																		LAB_26B5
8104		>a202		84 20 00 00											      .byte $84,$20,$00,$00   ; 10.0000 divide by 10 constant
8108		.a206																		LAB_2A9A
8109		=$a207																	LAB_2A9B = LAB_2A9A+1
8110		=$a208																	LAB_2A9C = LAB_2A9B+1
8111		>a206		fe 79 60												      .byte $FE,$79,$60       ; -100000
8112		>a209		00 27 10												      .byte $00,$27,$10       ; 10000
8113		>a20c		ff fc 18												      .byte $FF,$FC,$18       ; -1000
8114		>a20f		00 00 64												      .byte $00,$00,$64       ; 100
8115		>a212		ff ff f6												      .byte $FF,$FF,$F6       ; -10
8116		>a215		00 00 01												      .byte $00,$00,$01       ; 1
8118		.a218																		LAB_CTBL
8119		>a218		1c 85														      .word LAB_END-1         ; END
8120		>a21a		58 84														      .word LAB_FOR-1         ; FOR
8121		>a21c		64 8a														      .word LAB_NEXT-1        ; NEXT
8122		>a21e		89 86														      .word LAB_DATA-1        ; DATA
8123		>a220		47 89														      .word LAB_INPUT-1       ; INPUT
8124		>a222		6c 8d														      .word LAB_DIM-1         ; DIM
8125		>a224		66 89														      .word LAB_READ-1        ; READ
8126		>a226		b4 87														      .word LAB_LET-1         ; LET
8127		>a228		86 87														      .word LAB_DEC-1         ; DEC             new command
8128		>a22a		e8 85														      .word LAB_GOTO-1        ; GOTO
8129		>a22c		a7 85														      .word LAB_RUN-1         ; RUN
8130		>a22e		b7 86														      .word LAB_IF-1          ; IF
8131		>a230		3d 85														      .word LAB_RESTORE-1     ; RESTORE         modified command
8132		>a232		cb 85														      .word LAB_GOSUB-1       ; GOSUB
8133		>a234		73 9f														      .word LAB_RETIRQ-1      ; RETIRQ          new command
8134		>a236		7f 9f														      .word LAB_RETNMI-1      ; RETNMI          new command
8135		>a238		74 86														      .word LAB_RETURN-1      ; RETURN
8136		>a23a		1e 87														      .word LAB_REM-1         ; REM
8137		>a23c		1a 85														      .word LAB_STOP-1        ; STOP
8138		>a23e		27 87														      .word LAB_ON-1          ; ON              modified command
8139		>a240		7b 85														      .word LAB_NULL-1        ; NULL            modified command
8140		>a242		89 87														      .word LAB_INC-1         ; INC             new command
8141		>a244		95 95														      .word LAB_WAIT-1        ; WAIT
8142		>a246		fe a0														      .word V_LOAD-1          ; LOAD
8143		>a248		01 a1														      .word V_SAVE-1          ; SAVE
8144		>a24a		81 90														      .word LAB_DEF-1         ; DEF
8145		>a24c		1a 95														      .word LAB_POKE-1        ; POKE
8146		>a24e		36 95														      .word LAB_DOKE-1        ; DOKE            new command
8147		>a250		83 95														      .word LAB_CALL-1        ; CALL            new command
8148		>a252		b1 85														      .word LAB_DO-1          ; DO              new command
8149		>a254		1a 86														      .word LAB_LOOP-1        ; LOOP            new command
8150		>a256		55 88														      .word LAB_PRINT-1       ; PRINT
8151		>a258		81 85														      .word LAB_CONT-1        ; CONT
8152		>a25a		a3 83														      .word LAB_LIST-1        ; LIST
8153		>a25c		a0 83														      .word LAB_CLEAR-1       ; CLEAR
8154		>a25e		50 83														      .word LAB_NEW-1         ; NEW
8155		>a260		f4 9f														      .word LAB_WDTH-1        ; WIDTH           new command
8156		>a262		24 88														      .word LAB_GET-1         ; GET             new command
8157		>a264		5b 95														      .word LAB_SWAP-1        ; SWAP            new command
8158		>a266		8e 9d														      .word LAB_BITSET-1      ; BITSET          new command
8159		>a268		a2 9d														      .word LAB_BITCLR-1      ; BITCLR          new command
8160		>a26a		22 9f														      .word LAB_IRQ-1         ; IRQ             new command
8161		>a26c		25 9f														      .word LAB_NMI-1         ; NMI             new command
8165		.a26e																		LAB_FTPL
8166		=$a26f																	LAB_FTPM    = LAB_FTPL+$01
8167		>a26e		72 8c														      .word LAB_PPFN-1        ; SGN(n)    process numeric expression in ()
8168		>a270		72 8c														      .word LAB_PPFN-1        ; INT(n)          "
8169		>a272		72 8c														      .word LAB_PPFN-1        ; ABS(n)          "
8170		>a274		e8 8a														      .word LAB_EVEZ-1        ; USR(x)    process any expression
8171		>a276		eb 8b														      .word LAB_1BF7-1        ; FRE(x)          "
8172		>a278		eb 8b														      .word LAB_1BF7-1        ; POS(x)          "
8173		>a27a		72 8c														      .word LAB_PPFN-1        ; SQR(n)    process numeric expression in ()
8174		>a27c		72 8c														      .word LAB_PPFN-1        ; RND(n)          "
8175		>a27e		72 8c														      .word LAB_PPFN-1        ; LOG(n)          "
8176		>a280		72 8c														      .word LAB_PPFN-1        ; EXP(n)          "
8177		>a282		72 8c														      .word LAB_PPFN-1        ; COS(n)          "
8178		>a284		72 8c														      .word LAB_PPFN-1        ; SIN(n)          "
8179		>a286		72 8c														      .word LAB_PPFN-1        ; TAN(n)          "
8180		>a288		72 8c														      .word LAB_PPFN-1        ; ATN(n)          "
8181		>a28a		72 8c														      .word LAB_PPFN-1        ; PEEK(n)         "
8182		>a28c		72 8c														      .word LAB_PPFN-1        ; DEEK(n)         "
8183		>a28e		00 00														      .word $0000             ; SADD()    none
8184		>a290		6c 8c														      .word LAB_PPFS-1        ; LEN($)    process string expression in ()
8185		>a292		72 8c														      .word LAB_PPFN-1        ; STR$(n)   process numeric expression in ()
8186		>a294		6c 8c														      .word LAB_PPFS-1        ; VAL($)    process string expression in ()
8187		>a296		6c 8c														      .word LAB_PPFS-1        ; ASC($)          "
8188		>a298		6c 8c														      .word LAB_PPFS-1        ; UCASE$($)       "
8189		>a29a		6c 8c														      .word LAB_PPFS-1        ; LCASE$($)       "
8190		>a29c		72 8c														      .word LAB_PPFN-1        ; CHR$(n)   process numeric expression in ()
8191		>a29e		99 8c														      .word LAB_BHSS-1        ; HEX$(n)         "
8192		>a2a0		99 8c														      .word LAB_BHSS-1        ; BIN$(n)         "
8193		>a2a2		00 00														      .word $0000             ; BITTST()  none
8194		>a2a4		8b 9f														      .word LAB_MMPP-1        ; MAX()     process numeric expression
8195		>a2a6		8b 9f														      .word LAB_MMPP-1        ; MIN()           "
8196		>a2a8		78 8c														      .word LAB_PPBI-1        ; PI        advance pointer
8197		>a2aa		78 8c														      .word LAB_PPBI-1        ; TWOPI           "
8198		>a2ac		00 00														      .word $0000             ; VARPTR()  none
8199		>a2ae		7d 8c														      .word LAB_LRMS-1        ; LEFT$()   process string expression
8200		>a2b0		7d 8c														      .word LAB_LRMS-1        ; RIGHT$()        "
8201		>a2b2		7d 8c														      .word LAB_LRMS-1        ; MID$()          "
8205		.a2b4																		LAB_FTBL
8206		=$a2b5																	LAB_FTBM    = LAB_FTBL+$01
8207		>a2b4		03 99														      .word LAB_SGN-1         ; SGN()
8208		>a2b6		8d 99														      .word LAB_INT-1         ; INT()
8209		>a2b8		20 99														      .word LAB_ABS-1         ; ABS()
8210		>a2ba		59 9d														      .word LAB_USR-1         ; USR()
8211		>a2bc		52 90														      .word LAB_FRE-1         ; FRE()
8212		>a2be		71 90														      .word LAB_POS-1         ; POS()
8213		>a2c0		4a a0														      .word LAB_SQR-1         ; SQR()
8214		>a2c2		a9 9c														      .word LAB_RND-1         ; RND()           modified function
8215		>a2c4		07 97														      .word LAB_LOG-1         ; LOG()
8216		>a2c6		0b 9c														      .word LAB_EXP-1         ; EXP()
8217		>a2c8		dd 9c														      .word LAB_COS-1         ; COS()
8218		>a2ca		e4 9c														      .word LAB_SIN-1         ; SIN()
8219		>a2cc		2d 9d														      .word LAB_TAN-1         ; TAN()
8220		>a2ce		5f 9d														      .word LAB_ATN-1         ; ATN()
8221		>a2d0		0f 95														      .word LAB_PEEK-1        ; PEEK()
8222		>a2d2		23 95														      .word LAB_DEEK-1        ; DEEK()          new function
8223		>a2d4		68 94														      .word LAB_SADD-1        ; SADD()          new function
8224		>a2d6		81 94														      .word LAB_LENS-1        ; LEN()
8225		>a2d8		33 91														      .word LAB_STRS-1        ; STR$()
8226		>a2da		ae 94														      .word LAB_VAL-1         ; VAL()
8227		>a2dc		8c 94														      .word LAB_ASC-1         ; ASC()
8228		>a2de		46 94														      .word LAB_UCASE-1       ; UCASE$()        new function
8229		>a2e0		25 94														      .word LAB_LCASE-1       ; LCASE$()        new function
8230		>a2e2		97 93														      .word LAB_CHRS-1        ; CHR$()
8231		>a2e4		2f 9e														      .word LAB_HEXS-1        ; HEX$()          new function
8232		>a2e6		e0 9d														      .word LAB_BINS-1        ; BIN$()          new function
8233		>a2e8		b8 9d														      .word LAB_BTST-1        ; BITTST()        new function
8234		>a2ea		91 9f														      .word LAB_MAX-1         ; MAX()           new function
8235		>a2ec		a1 9f														      .word LAB_MIN-1         ; MIN()           new function
8236		>a2ee		e7 a0														      .word LAB_PI-1          ; PI              new function
8237		>a2f0		f1 a0														      .word LAB_TWOPI-1       ; TWOPI           new function
8238		>a2f2		d7 a0														      .word LAB_VARPTR-1      ; VARPTR()        new function
8239		>a2f4		a9 93														      .word LAB_LEFT-1        ; LEFT$()
8240		>a2f6		b2 93														      .word LAB_RIGHT-1       ; RIGHT$()
8241		>a2f8		e1 93														      .word LAB_MIDS-1        ; MID$()
8245		.a2fa																		LAB_OPPT
8246		>a2fa		79															      .byte $79               ; +
8247		>a2fb		cd 95														      .word LAB_ADD-1
8248		>a2fd		79															      .byte $79               ; -
8249		>a2fe		b2 95														      .word LAB_SUBTRACT-1
8250		>a300		7b															      .byte $7B               ; *
8251		>a301		48 97														      .word LAB_MULTIPLY-1
8252		>a303		7b															      .byte $7B               ; /
8253		>a304		10 98														      .word LAB_DIVIDE-1
8254		>a306		7f															      .byte $7F               ; ^
8255		>a307		c7 9b														      .word LAB_POWER-1
8256		>a309		50															      .byte $50               ; AND
8257		>a30a		e2 8c														      .word LAB_AND-1
8258		>a30c		46															      .byte $46               ; EOR             new operator
8259		>a30d		c8 8c														      .word LAB_EOR-1
8260		>a30f		46															      .byte $46               ; OR
8261		>a310		d5 8c														      .word LAB_OR-1
8262		>a312		56															      .byte $56               ; >>              new operator
8263		>a313		8e 8d														      .word LAB_RSHIFT-1
8264		>a315		56															      .byte $56               ; <<              new operator
8265		>a316		76 8d														      .word LAB_LSHIFT-1
8266		>a318		7d															      .byte $7D               ; >
8267		>a319		00 9c														      .word LAB_GTHAN-1
8268		>a31b		5a															      .byte $5A               ; =
8269		>a31c		16 8c														      .word LAB_EQUAL-1
8270		>a31e		64															      .byte $64               ; <
8271		>a31f		03 8d														      .word LAB_LTHAN-1
8276		.a321																		TAB_1STC
8277		>a321		2a															      .text "*"
8278		>a322		2b															      .text "+"
8279		>a323		2d															      .text "-"
8280		>a324		2f															      .text "/"
8281		>a325		3c															      .text "<"
8282		>a326		3d															      .text "="
8283		>a327		3e															      .text ">"
8284		>a328		3f															      .text "?"
8285		>a329		41															      .text "A"
8286		>a32a		42															      .text "B"
8287		>a32b		43															      .text "C"
8288		>a32c		44															      .text "D"
8289		>a32d		45															      .text "E"
8290		>a32e		46															      .text "F"
8291		>a32f		47															      .text "G"
8292		>a330		48															      .text "H"
8293		>a331		49															      .text "I"
8294		>a332		4c															      .text "L"
8295		>a333		4d															      .text "M"
8296		>a334		4e															      .text "N"
8297		>a335		4f															      .text "O"
8298		>a336		50															      .text "P"
8299		>a337		52															      .text "R"
8300		>a338		53															      .text "S"
8301		>a339		54															      .text "T"
8302		>a33a		55															      .text "U"
8303		>a33b		56															      .text "V"
8304		>a33c		57															      .text "W"
8305		>a33d		5e															      .text "^"
8306		>a33e		00															      .byte $00               ; table terminator
8310		.a33f																		TAB_CHRT
8311		>a33f		79 a3														      .word TAB_STAR          ; table for "*"
8312		>a341		7b a3														      .word TAB_PLUS          ; table for "+"
8313		>a343		7d a3														      .word TAB_MNUS          ; table for "-"
8314		>a345		7f a3														      .word TAB_SLAS          ; table for "/"
8315		>a347		81 a3														      .word TAB_LESS          ; table for "<"
8316		>a349		85 a3														      .word TAB_EQUL          ; table for "="
8317		>a34b		87 a3														      .word TAB_MORE          ; table for ">"
8318		>a34d		8b a3														      .word TAB_QEST          ; table for "?"
8319		>a34f		8d a3														      .word TAB_ASCA          ; table for "A"
8320		>a351		9d a3														      .word TAB_ASCB          ; table for "B"
8321		>a353		b6 a3														      .word TAB_ASCC          ; table for "C"
8322		>a355		cd a3														      .word TAB_ASCD          ; table for "D"
8323		>a357		e6 a3														      .word TAB_ASCE          ; table for "E"
8324		>a359		f5 a3														      .word TAB_ASCF          ; table for "F"
8325		>a35b		ff a3														      .word TAB_ASCG          ; table for "G"
8326		>a35d		0c a4														      .word TAB_ASCH          ; table for "H"
8327		>a35f		12 a4														      .word TAB_ASCI          ; table for "I"
8328		>a361		24 a4														      .word TAB_ASCL          ; table for "L"
8329		>a363		49 a4														      .word TAB_ASCM          ; table for "M"
8330		>a365		57 a4														      .word TAB_ASCN          ; table for "N"
8331		>a367		69 a4														      .word TAB_ASCO          ; table for "O"
8332		>a369		71 a4														      .word TAB_ASCP          ; table for "P"
8333		>a36b		86 a4														      .word TAB_ASCR          ; table for "R"
8334		>a36d		b5 a4														      .word TAB_ASCS          ; table for "S"
8335		>a36f		e0 a4														      .word TAB_ASCT          ; table for "T"
8336		>a371		f4 a4														      .word TAB_ASCU          ; table for "U"
8337		>a373		05 a5														      .word TAB_ASCV          ; table for "V"
8338		>a375		11 a5														      .word TAB_ASCW          ; table for "W"
8339		>a377		20 a5														      .word TAB_POWR          ; table for "^"
8349		.a379																		TAB_STAR
8350		>a379		b8 00														      .byte TK_MUL,$00        ; *
8351		.a37b																		TAB_PLUS
8352		>a37b		b6 00														      .byte TK_PLUS,$00       ; +
8353		.a37d																		TAB_MNUS
8354		>a37d		b7 00														      .byte TK_MINUS,$00      ; -
8355		.a37f																		TAB_SLAS
8356		>a37f		b9 00														      .byte TK_DIV,$00        ; /
8357		.a381																		TAB_LESS
8358		.a381																		LBB_LSHIFT
8359		>a381		3c bf														      .text "<",TK_LSHIFT     ; <<  note - "<<" must come before "<"
8360		>a383		c2															      .byte TK_LT             ; <
8361		>a384		00															      .byte $00
8362		.a385																		TAB_EQUL
8363		>a385		c1 00														      .byte TK_EQUAL,$00      ; =
8364		.a387																		TAB_MORE
8365		.a387																		LBB_RSHIFT
8366		>a387		3e be														      .text ">",TK_RSHIFT     ; >>  note - ">>" must come before ">"
8367		>a389		c0															      .byte TK_GT             ; >
8368		>a38a		00															      .byte $00
8369		.a38b																		TAB_QEST
8370		>a38b		9f 00														      .byte TK_PRINT,$00      ; ?
8371		.a38d																		TAB_ASCA
8372		.a38d																		LBB_ABS
8373		>a38d		42 53 28 c5											      .text "BS(",TK_ABS      ; ABS(
8374		.a391																		LBB_AND
8375		>a391		4e 44 bb												      .text "ND",TK_AND       ; AND
8376		.a394																		LBB_ASC
8377		>a394		53 43 28 d7											      .text "SC(",TK_ASC      ; ASC(
8378		.a398																		LBB_ATN
8379		>a398		54 4e 28 d0											      .text "TN(",TK_ATN      ; ATN(
8380		>a39c		00															      .byte $00
8381		.a39d																		TAB_ASCB
8382		.a39d																		LBB_BINS
8383		>a39d		49 4e 24 28 dc									      .text "IN$(",TK_BINS    ; BIN$(
8384		.a3a2																		LBB_BITCLR
8385		>a3a2		49 54 43 4c 52 a8								      .text "ITCLR",TK_BITCLR ; BITCLR
8386		.a3a8																		LBB_BITSET
8387		>a3a8		49 54 53 45 54 a7								      .text "ITSET",TK_BITSET ; BITSET
8388		.a3ae																		LBB_BITTST
8389		>a3ae		49 54 54 53 54 28 dd						      .text "ITTST(",TK_BITTST
8391		>a3b5		00															      .byte $00
8392		.a3b6																		TAB_ASCC
8393		.a3b6																		LBB_CALL
8394		>a3b6		41 4c 4c 9c											      .text "ALL",TK_CALL     ; CALL
8395		.a3ba																		LBB_CHRS
8396		>a3ba		48 52 24 28 da									      .text "HR$(",TK_CHRS    ; CHR$(
8397		.a3bf																		LBB_CLEAR
8398		>a3bf		4c 45 41 52 a2									      .text "LEAR",TK_CLEAR   ; CLEAR
8399		.a3c4																		LBB_CONT
8400		>a3c4		4f 4e 54 a0											      .text "ONT",TK_CONT     ; CONT
8401		.a3c8																		LBB_COS
8402		>a3c8		4f 53 28 cd											      .text "OS(",TK_COS      ; COS(
8403		>a3cc		00															      .byte $00
8404		.a3cd																		TAB_ASCD
8405		.a3cd																		LBB_DATA
8406		>a3cd		41 54 41 83											      .text "ATA",TK_DATA     ; DATA
8407		.a3d1																		LBB_DEC
8408		>a3d1		45 43 88												      .text "EC",TK_DEC       ; DEC
8409		.a3d4																		LBB_DEEK
8410		>a3d4		45 45 4b 28 d2									      .text "EEK(",TK_DEEK    ; DEEK(
8411		.a3d9																		LBB_DEF
8412		>a3d9		45 46 99												      .text "EF",TK_DEF       ; DEF
8413		.a3dc																		LBB_DIM
8414		>a3dc		49 4d 85												      .text "IM",TK_DIM       ; DIM
8415		.a3df																		LBB_DOKE
8416		>a3df		4f 4b 45 9b											      .text "OKE",TK_DOKE     ; DOKE note - "DOKE" must come before "DO"
8417		.a3e3																		LBB_DO
8418		>a3e3		4f 9d														      .text "O",TK_DO         ; DO
8419		>a3e5		00															      .byte $00
8420		.a3e6																		TAB_ASCE
8421		.a3e6																		LBB_ELSE
8422		>a3e6		4c 53 45 ac											      .text "LSE",TK_ELSE     ; ELSE
8423		.a3ea																		LBB_END
8424		>a3ea		4e 44 80												      .text "ND",TK_END       ; END
8425		.a3ed																		LBB_EOR
8426		>a3ed		4f 52 bc												      .text "OR",TK_EOR       ; EOR
8427		.a3f0																		LBB_EXP
8428		>a3f0		58 50 28 cc											      .text "XP(",TK_EXP      ; EXP(
8429		>a3f4		00															      .byte $00
8430		.a3f5																		TAB_ASCF
8431		.a3f5																		LBB_FN
8432		>a3f5		4e ae														      .text "N",TK_FN         ; FN
8433		.a3f7																		LBB_FOR
8434		>a3f7		4f 52 81												      .text "OR",TK_FOR       ; FOR
8435		.a3fa																		LBB_FRE
8436		>a3fa		52 45 28 c7											      .text "RE(",TK_FRE      ; FRE(
8437		>a3fe		00															      .byte $00
8438		.a3ff																		TAB_ASCG
8439		.a3ff																		LBB_GET
8440		>a3ff		45 54 a5												      .text "ET",TK_GET       ; GET
8441		.a402																		LBB_GOSUB
8442		>a402		4f 53 55 42 8d									      .text "OSUB",TK_GOSUB   ; GOSUB
8443		.a407																		LBB_GOTO
8444		>a407		4f 54 4f 89											      .text "OTO",TK_GOTO     ; GOTO
8445		>a40b		00															      .byte $00
8446		.a40c																		TAB_ASCH
8447		.a40c																		LBB_HEXS
8448		>a40c		45 58 24 28 db									      .text "EX$(",TK_HEXS    ; HEX$(
8449		>a411		00															      .byte $00
8450		.a412																		TAB_ASCI
8451		.a412																		LBB_IF
8452		>a412		46 8b														      .text "F",TK_IF         ; IF
8453		.a414																		LBB_INC
8454		>a414		4e 43 95												      .text "NC",TK_INC       ; INC
8455		.a417																		LBB_INPUT
8456		>a417		4e 50 55 54 84									      .text "NPUT",TK_INPUT   ; INPUT
8457		.a41c																		LBB_INT
8458		>a41c		4e 54 28 c4											      .text "NT(",TK_INT      ; INT(
8459		.a420																		LBB_IRQ
8460		>a420		52 51 a9												      .text "RQ",TK_IRQ       ; IRQ
8461		>a423		00															      .byte $00
8462		.a424																		TAB_ASCL
8463		.a424																		LBB_LCASES
8464		>a424		43 41 53 45 24 28 d9						      .text "CASE$(",TK_LCASES
8466		.a42b																		LBB_LEFTS
8467		>a42b		45 46 54 24 28 e3								      .text "EFT$(",TK_LEFTS  ; LEFT$(
8468		.a431																		LBB_LEN
8469		>a431		45 4e 28 d4											      .text "EN(",TK_LEN      ; LEN(
8470		.a435																		LBB_LET
8471		>a435		45 54 87												      .text "ET",TK_LET       ; LET
8472		.a438																		LBB_LIST
8473		>a438		49 53 54 a1											      .text "IST",TK_LIST     ; LIST
8474		.a43c																		LBB_LOAD
8475		>a43c		4f 41 44 97											      .text "OAD",TK_LOAD     ; LOAD
8476		.a440																		LBB_LOG
8477		>a440		4f 47 28 cb											      .text "OG(",TK_LOG      ; LOG(
8478		.a444																		LBB_LOOP
8479		>a444		4f 4f 50 9e											      .text "OOP",TK_LOOP     ; LOOP
8480		>a448		00															      .byte $00
8481		.a449																		TAB_ASCM
8482		.a449																		LBB_MAX
8483		>a449		41 58 28 de											      .text "AX(",TK_MAX      ; MAX(
8484		.a44d																		LBB_MIDS
8485		>a44d		49 44 24 28 e5									      .text "ID$(",TK_MIDS    ; MID$(
8486		.a452																		LBB_MIN
8487		>a452		49 4e 28 df											      .text "IN(",TK_MIN      ; MIN(
8488		>a456		00															      .byte $00
8489		.a457																		TAB_ASCN
8490		.a457																		LBB_NEW
8491		>a457		45 57 a3												      .text "EW",TK_NEW       ; NEW
8492		.a45a																		LBB_NEXT
8493		>a45a		45 58 54 82											      .text "EXT",TK_NEXT     ; NEXT
8494		.a45e																		LBB_NMI
8495		>a45e		4d 49 aa												      .text "MI",TK_NMI       ; NMI
8496		.a461																		LBB_NOT
8497		>a461		4f 54 b1												      .text "OT",TK_NOT       ; NOT
8498		.a464																		LBB_NULL
8499		>a464		55 4c 4c 94											      .text "ULL",TK_NULL     ; NULL
8500		>a468		00															      .byte $00
8501		.a469																		TAB_ASCO
8502		.a469																		LBB_OFF
8503		>a469		46 46 b5												      .text "FF",TK_OFF       ; OFF
8504		.a46c																		LBB_ON
8505		>a46c		4e 93														      .text "N",TK_ON         ; ON
8506		.a46e																		LBB_OR
8507		>a46e		52 bd														      .text "R",TK_OR         ; OR
8508		>a470		00															      .byte $00
8509		.a471																		TAB_ASCP
8510		.a471																		LBB_PEEK
8511		>a471		45 45 4b 28 d1									      .text "EEK(",TK_PEEK    ; PEEK(
8512		.a476																		LBB_PI
8513		>a476		49 e0														      .text "I",TK_PI         ; PI
8514		.a478																		LBB_POKE
8515		>a478		4f 4b 45 9a											      .text "OKE",TK_POKE     ; POKE
8516		.a47c																		LBB_POS
8517		>a47c		4f 53 28 c8											      .text "OS(",TK_POS      ; POS(
8518		.a480																		LBB_PRINT
8519		>a480		52 49 4e 54 9f									      .text "RINT",TK_PRINT   ; PRINT
8520		>a485		00															      .byte $00
8521		.a486																		TAB_ASCR
8522		.a486																		LBB_READ
8523		>a486		45 41 44 86											      .text "EAD",TK_READ     ; READ
8524		.a48a																		LBB_REM
8525		>a48a		45 4d 91												      .text "EM",TK_REM       ; REM
8526		.a48d																		LBB_RESTORE
8527		>a48d		45 53 54 4f 52 45 8c						      .text "ESTORE",TK_RESTORE
8529		.a494																		LBB_RETIRQ
8530		>a494		45 54 49 52 51 8e								      .text "ETIRQ",TK_RETIRQ ; RETIRQ
8531		.a49a																		LBB_RETNMI
8532		>a49a		45 54 4e 4d 49 8f								      .text "ETNMI",TK_RETNMI ; RETNMI
8533		.a4a0																		LBB_RETURN
8534		>a4a0		45 54 55 52 4e 90								      .text "ETURN",TK_RETURN ; RETURN
8535		.a4a6																		LBB_RIGHTS
8536		>a4a6		49 47 48 54 24 28 e4						      .text "IGHT$(",TK_RIGHTS
8538		.a4ad																		LBB_RND
8539		>a4ad		4e 44 28 ca											      .text "ND(",TK_RND      ; RND(
8540		.a4b1																		LBB_RUN
8541		>a4b1		55 4e 8a												      .text "UN",TK_RUN       ; RUN
8542		>a4b4		00															      .byte $00
8543		.a4b5																		TAB_ASCS
8544		.a4b5																		LBB_SADD
8545		>a4b5		41 44 44 28 d3									      .text "ADD(",TK_SADD    ; SADD(
8546		.a4ba																		LBB_SAVE
8547		>a4ba		41 56 45 98											      .text "AVE",TK_SAVE     ; SAVE
8548		.a4be																		LBB_SGN
8549		>a4be		47 4e 28 c3											      .text "GN(",TK_SGN      ; SGN(
8550		.a4c2																		LBB_SIN
8551		>a4c2		49 4e 28 ce											      .text "IN(",TK_SIN      ; SIN(
8552		.a4c6																		LBB_SPC
8553		>a4c6		50 43 28 af											      .text "PC(",TK_SPC      ; SPC(
8554		.a4ca																		LBB_SQR
8555		>a4ca		51 52 28 c9											      .text "QR(",TK_SQR      ; SQR(
8556		.a4ce																		LBB_STEP
8557		>a4ce		54 45 50 b2											      .text "TEP",TK_STEP     ; STEP
8558		.a4d2																		LBB_STOP
8559		>a4d2		54 4f 50 92											      .text "TOP",TK_STOP     ; STOP
8560		.a4d6																		LBB_STRS
8561		>a4d6		54 52 24 28 d5									      .text "TR$(",TK_STRS    ; STR$(
8562		.a4db																		LBB_SWAP
8563		>a4db		57 41 50 a6											      .text "WAP",TK_SWAP     ; SWAP
8564		>a4df		00															      .byte $00
8565		.a4e0																		TAB_ASCT
8566		.a4e0																		LBB_TAB
8567		>a4e0		41 42 28 ab											      .text "AB(",TK_TAB      ; TAB(
8568		.a4e4																		LBB_TAN
8569		>a4e4		41 4e 28 cf											      .text "AN(",TK_TAN      ; TAN(
8570		.a4e8																		LBB_THEN
8571		>a4e8		48 45 4e b0											      .text "HEN",TK_THEN     ; THEN
8572		.a4ec																		LBB_TO
8573		>a4ec		4f ad														      .text "O",TK_TO         ; TO
8574		.a4ee																		LBB_TWOPI
8575		>a4ee		57 4f 50 49 e1									      .text "WOPI",TK_TWOPI   ; TWOPI
8576		>a4f3		00															      .byte $00
8577		.a4f4																		TAB_ASCU
8578		.a4f4																		LBB_UCASES
8579		>a4f4		43 41 53 45 24 28 d8						      .text "CASE$(",TK_UCASES
8581		.a4fb																		LBB_UNTIL
8582		>a4fb		4e 54 49 4c b3									      .text "NTIL",TK_UNTIL   ; UNTIL
8583		.a500																		LBB_USR
8584		>a500		53 52 28 c6											      .text "SR(",TK_USR      ; USR(
8585		>a504		00															      .byte $00
8586		.a505																		TAB_ASCV
8587		.a505																		LBB_VAL
8588		>a505		41 4c 28 d6											      .text "AL(",TK_VAL      ; VAL(
8589		.a509																		LBB_VPTR
8590		>a509		41 52 50 54 52 28 e2						      .text "ARPTR(",TK_VPTR  ; VARPTR(
8591		>a510		00															      .byte $00
8592		.a511																		TAB_ASCW
8593		.a511																		LBB_WAIT
8594		>a511		41 49 54 96											      .text "AIT",TK_WAIT     ; WAIT
8595		.a515																		LBB_WHILE
8596		>a515		48 49 4c 45 b4									      .text "HILE",TK_WHILE   ; WHILE
8597		.a51a																		LBB_WIDTH
8598		>a51a		49 44 54 48 a4									      .text "IDTH",TK_WIDTH   ; WIDTH
8599		>a51f		00															      .byte $00
8600		.a520																		TAB_POWR
8601		>a520		ba 00														      .byte TK_POWER,$00      ; ^
8610		.a522																		LAB_KEYT
8611		>a522		03 45														      .byte 3,'E'
8612		>a524		ea a3														      .word LBB_END           ; END
8613		>a526		03 46														      .byte 3,'F'
8614		>a528		f7 a3														      .word LBB_FOR           ; FOR
8615		>a52a		04 4e														      .byte 4,'N'
8616		>a52c		5a a4														      .word LBB_NEXT          ; NEXT
8617		>a52e		04 44														      .byte 4,'D'
8618		>a530		cd a3														      .word LBB_DATA          ; DATA
8619		>a532		05 49														      .byte 5,'I'
8620		>a534		17 a4														      .word LBB_INPUT         ; INPUT
8621		>a536		03 44														      .byte 3,'D'
8622		>a538		dc a3														      .word LBB_DIM           ; DIM
8623		>a53a		04 52														      .byte 4,'R'
8624		>a53c		86 a4														      .word LBB_READ          ; READ
8625		>a53e		03 4c														      .byte 3,'L'
8626		>a540		35 a4														      .word LBB_LET           ; LET
8627		>a542		03 44														      .byte 3,'D'
8628		>a544		d1 a3														      .word LBB_DEC           ; DEC
8629		>a546		04 47														      .byte 4,'G'
8630		>a548		07 a4														      .word LBB_GOTO          ; GOTO
8631		>a54a		03 52														      .byte 3,'R'
8632		>a54c		b1 a4														      .word LBB_RUN           ; RUN
8633		>a54e		02 49														      .byte 2,'I'
8634		>a550		12 a4														      .word LBB_IF            ; IF
8635		>a552		07 52														      .byte 7,'R'
8636		>a554		8d a4														      .word LBB_RESTORE       ; RESTORE
8637		>a556		05 47														      .byte 5,'G'
8638		>a558		02 a4														      .word LBB_GOSUB         ; GOSUB
8639		>a55a		06 52														      .byte 6,'R'
8640		>a55c		94 a4														      .word LBB_RETIRQ        ; RETIRQ
8641		>a55e		06 52														      .byte 6,'R'
8642		>a560		9a a4														      .word LBB_RETNMI        ; RETNMI
8643		>a562		06 52														      .byte 6,'R'
8644		>a564		a0 a4														      .word LBB_RETURN        ; RETURN
8645		>a566		03 52														      .byte 3,'R'
8646		>a568		8a a4														      .word LBB_REM           ; REM
8647		>a56a		04 53														      .byte 4,'S'
8648		>a56c		d2 a4														      .word LBB_STOP          ; STOP
8649		>a56e		02 4f														      .byte 2,'O'
8650		>a570		6c a4														      .word LBB_ON            ; ON
8651		>a572		04 4e														      .byte 4,'N'
8652		>a574		64 a4														      .word LBB_NULL          ; NULL
8653		>a576		03 49														      .byte 3,'I'
8654		>a578		14 a4														      .word LBB_INC           ; INC
8655		>a57a		04 57														      .byte 4,'W'
8656		>a57c		11 a5														      .word LBB_WAIT          ; WAIT
8657		>a57e		04 4c														      .byte 4,'L'
8658		>a580		3c a4														      .word LBB_LOAD          ; LOAD
8659		>a582		04 53														      .byte 4,'S'
8660		>a584		ba a4														      .word LBB_SAVE          ; SAVE
8661		>a586		03 44														      .byte 3,'D'
8662		>a588		d9 a3														      .word LBB_DEF           ; DEF
8663		>a58a		04 50														      .byte 4,'P'
8664		>a58c		78 a4														      .word LBB_POKE          ; POKE
8665		>a58e		04 44														      .byte 4,'D'
8666		>a590		df a3														      .word LBB_DOKE          ; DOKE
8667		>a592		04 43														      .byte 4,'C'
8668		>a594		b6 a3														      .word LBB_CALL          ; CALL
8669		>a596		02 44														      .byte 2,'D'
8670		>a598		e3 a3														      .word LBB_DO            ; DO
8671		>a59a		04 4c														      .byte 4,'L'
8672		>a59c		44 a4														      .word LBB_LOOP          ; LOOP
8673		>a59e		05 50														      .byte 5,'P'
8674		>a5a0		80 a4														      .word LBB_PRINT         ; PRINT
8675		>a5a2		04 43														      .byte 4,'C'
8676		>a5a4		c4 a3														      .word LBB_CONT          ; CONT
8677		>a5a6		04 4c														      .byte 4,'L'
8678		>a5a8		38 a4														      .word LBB_LIST          ; LIST
8679		>a5aa		05 43														      .byte 5,'C'
8680		>a5ac		bf a3														      .word LBB_CLEAR         ; CLEAR
8681		>a5ae		03 4e														      .byte 3,'N'
8682		>a5b0		57 a4														      .word LBB_NEW           ; NEW
8683		>a5b2		05 57														      .byte 5,'W'
8684		>a5b4		1a a5														      .word LBB_WIDTH         ; WIDTH
8685		>a5b6		03 47														      .byte 3,'G'
8686		>a5b8		ff a3														      .word LBB_GET           ; GET
8687		>a5ba		04 53														      .byte 4,'S'
8688		>a5bc		db a4														      .word LBB_SWAP          ; SWAP
8689		>a5be		06 42														      .byte 6,'B'
8690		>a5c0		a8 a3														      .word LBB_BITSET        ; BITSET
8691		>a5c2		06 42														      .byte 6,'B'
8692		>a5c4		a2 a3														      .word LBB_BITCLR        ; BITCLR
8693		>a5c6		03 49														      .byte 3,'I'
8694		>a5c8		20 a4														      .word LBB_IRQ           ; IRQ
8695		>a5ca		03 4e														      .byte 3,'N'
8696		>a5cc		5e a4														      .word LBB_NMI           ; NMI
8700		>a5ce		04 54														      .byte 4,'T'
8701		>a5d0		e0 a4														      .word LBB_TAB           ; TAB
8702		>a5d2		04 45														      .byte 4,'E'
8703		>a5d4		e6 a3														      .word LBB_ELSE          ; ELSE
8704		>a5d6		02 54														      .byte 2,'T'
8705		>a5d8		ec a4														      .word LBB_TO            ; TO
8706		>a5da		02 46														      .byte 2,'F'
8707		>a5dc		f5 a3														      .word LBB_FN            ; FN
8708		>a5de		04 53														      .byte 4,'S'
8709		>a5e0		c6 a4														      .word LBB_SPC           ; SPC
8710		>a5e2		04 54														      .byte 4,'T'
8711		>a5e4		e8 a4														      .word LBB_THEN          ; THEN
8712		>a5e6		03 4e														      .byte 3,'N'
8713		>a5e8		61 a4														      .word LBB_NOT           ; NOT
8714		>a5ea		04 53														      .byte 4,'S'
8715		>a5ec		ce a4														      .word LBB_STEP          ; STEP
8716		>a5ee		05 55														      .byte 5,'U'
8717		>a5f0		fb a4														      .word LBB_UNTIL         ; UNTIL
8718		>a5f2		05 57														      .byte 5,'W'
8719		>a5f4		15 a5														      .word LBB_WHILE         ; WHILE
8720		>a5f6		03 4f														      .byte 3,'O'
8721		>a5f8		69 a4														      .word LBB_OFF           ; OFF
8725		>a5fa		01 2b														      .byte 1,'+'
8726		>a5fc		00 00														      .word $0000             ; +
8727		>a5fe		01 2d														      .byte 1,'-'
8728		>a600		00 00														      .word $0000             ; -
8729		>a602		01 2a														      .byte 1,'*'
8730		>a604		00 00														      .word $0000             ; *
8731		>a606		01 2f														      .byte 1,'/'
8732		>a608		00 00														      .word $0000             ; /
8733		>a60a		01 5e														      .byte 1,'^'
8734		>a60c		00 00														      .word $0000             ; ^
8735		>a60e		03 41														      .byte 3,'A'
8736		>a610		91 a3														      .word LBB_AND           ; AND
8737		>a612		03 45														      .byte 3,'E'
8738		>a614		ed a3														      .word LBB_EOR           ; EOR
8739		>a616		02 4f														      .byte 2,'O'
8740		>a618		6e a4														      .word LBB_OR            ; OR
8741		>a61a		02 3e														      .byte 2,'>'
8742		>a61c		87 a3														      .word LBB_RSHIFT        ; >>
8743		>a61e		02 3c														      .byte 2,'<'
8744		>a620		81 a3														      .word LBB_LSHIFT        ; <<
8745		>a622		01 3e														      .byte 1,'>'
8746		>a624		00 00														      .word $0000             ; >
8747		>a626		01 3d														      .byte 1,'='
8748		>a628		00 00														      .word $0000             ; =
8749		>a62a		01 3c														      .byte 1,'<'
8750		>a62c		00 00														      .word $0000             ; <
8754		>a62e		04 53														      .byte 4,'S'             ;
8755		>a630		be a4														      .word LBB_SGN           ; SGN
8756		>a632		04 49														      .byte 4,'I'             ;
8757		>a634		1c a4														      .word LBB_INT           ; INT
8758		>a636		04 41														      .byte 4,'A'             ;
8759		>a638		8d a3														      .word LBB_ABS           ; ABS
8760		>a63a		04 55														      .byte 4,'U'             ;
8761		>a63c		00 a5														      .word LBB_USR           ; USR
8762		>a63e		04 46														      .byte 4,'F'             ;
8763		>a640		fa a3														      .word LBB_FRE           ; FRE
8764		>a642		04 50														      .byte 4,'P'             ;
8765		>a644		7c a4														      .word LBB_POS           ; POS
8766		>a646		04 53														      .byte 4,'S'             ;
8767		>a648		ca a4														      .word LBB_SQR           ; SQR
8768		>a64a		04 52														      .byte 4,'R'             ;
8769		>a64c		ad a4														      .word LBB_RND           ; RND
8770		>a64e		04 4c														      .byte 4,'L'             ;
8771		>a650		40 a4														      .word LBB_LOG           ; LOG
8772		>a652		04 45														      .byte 4,'E'             ;
8773		>a654		f0 a3														      .word LBB_EXP           ; EXP
8774		>a656		04 43														      .byte 4,'C'             ;
8775		>a658		c8 a3														      .word LBB_COS           ; COS
8776		>a65a		04 53														      .byte 4,'S'             ;
8777		>a65c		c2 a4														      .word LBB_SIN           ; SIN
8778		>a65e		04 54														      .byte 4,'T'             ;
8779		>a660		e4 a4														      .word LBB_TAN           ; TAN
8780		>a662		04 41														      .byte 4,'A'             ;
8781		>a664		98 a3														      .word LBB_ATN           ; ATN
8782		>a666		05 50														      .byte 5,'P'             ;
8783		>a668		71 a4														      .word LBB_PEEK          ; PEEK
8784		>a66a		05 44														      .byte 5,'D'             ;
8785		>a66c		d4 a3														      .word LBB_DEEK          ; DEEK
8786		>a66e		05 53														      .byte 5,'S'             ;
8787		>a670		b5 a4														      .word LBB_SADD          ; SADD
8788		>a672		04 4c														      .byte 4,'L'             ;
8789		>a674		31 a4														      .word LBB_LEN           ; LEN
8790		>a676		05 53														      .byte 5,'S'             ;
8791		>a678		d6 a4														      .word LBB_STRS          ; STR$
8792		>a67a		04 56														      .byte 4,'V'             ;
8793		>a67c		05 a5														      .word LBB_VAL           ; VAL
8794		>a67e		04 41														      .byte 4,'A'             ;
8795		>a680		94 a3														      .word LBB_ASC           ; ASC
8796		>a682		07 55														      .byte 7,'U'             ;
8797		>a684		f4 a4														      .word LBB_UCASES        ; UCASE$
8798		>a686		07 4c														      .byte 7,'L'             ;
8799		>a688		24 a4														      .word LBB_LCASES        ; LCASE$
8800		>a68a		05 43														      .byte 5,'C'             ;
8801		>a68c		ba a3														      .word LBB_CHRS          ; CHR$
8802		>a68e		05 48														      .byte 5,'H'             ;
8803		>a690		0c a4														      .word LBB_HEXS          ; HEX$
8804		>a692		05 42														      .byte 5,'B'             ;
8805		>a694		9d a3														      .word LBB_BINS          ; BIN$
8806		>a696		07 42														      .byte 7,'B'             ;
8807		>a698		ae a3														      .word LBB_BITTST        ; BITTST
8808		>a69a		04 4d														      .byte 4,'M'             ;
8809		>a69c		49 a4														      .word LBB_MAX           ; MAX
8810		>a69e		04 4d														      .byte 4,'M'             ;
8811		>a6a0		52 a4														      .word LBB_MIN           ; MIN
8812		>a6a2		02 50														      .byte 2,'P'             ;
8813		>a6a4		76 a4														      .word LBB_PI            ; PI
8814		>a6a6		05 54														      .byte 5,'T'             ;
8815		>a6a8		ee a4														      .word LBB_TWOPI         ; TWOPI
8816		>a6aa		07 56														      .byte 7,'V'             ;
8817		>a6ac		09 a5														      .word LBB_VPTR          ; VARPTR
8818		>a6ae		06 4c														      .byte 6,'L'             ;
8819		>a6b0		2b a4														      .word LBB_LEFTS         ; LEFT$
8820		>a6b2		07 52														      .byte 7,'R'             ;
8821		>a6b4		a6 a4														      .word LBB_RIGHTS        ; RIGHT$
8822		>a6b6		05 4d														      .byte 5,'M'             ;
8823		>a6b8		4d a4														      .word LBB_MIDS          ; MID$
8827		.a6ba																		LAB_BAER
8828		>a6ba		de a6														      .word ERR_NF            ;$00 NEXT without FOR
8829		>a6bc		ef a6														      .word ERR_SN            ;$02 syntax
8830		>a6be		f6 a6														      .word ERR_RG            ;$04 RETURN without GOSUB
8831		>a6c0		0b a7														      .word ERR_OD            ;$06 out of data
8832		>a6c2		17 a7														      .word ERR_FC            ;$08 function call
8833		>a6c4		25 a7														      .word ERR_OV            ;$0A overflow
8834		>a6c6		2e a7														      .word ERR_OM            ;$0C out of memory
8835		>a6c8		3c a7														      .word ERR_US            ;$0E undefined statement
8836		>a6ca		50 a7														      .word ERR_BS            ;$10 array bounds
8837		>a6cc		5d a7														      .word ERR_DD            ;$12 double dimension array
8838		>a6ce		6e a7														      .word ERR_D0            ;$14 divide by 0
8839		>a6d0		7d a7														      .word ERR_ID            ;$16 illegal direct
8840		>a6d2		8c a7														      .word ERR_TM            ;$18 type mismatch
8841		>a6d4		9a a7														      .word ERR_LS            ;$1A long string
8842		>a6d6		aa a7														      .word ERR_ST            ;$1C string too complex
8843		>a6d8		bd a7														      .word ERR_CN            ;$1E continue error
8844		>a6da		cc a7														      .word ERR_UF            ;$20 undefined function
8845		>a6dc		df a7														      .word ERR_LD            ;$22 LOOP without DO
8856		>a6de		4e 45 58 54 20 77 69 74					ERR_NF      .text "NEXT without FOR",$00
				>a6e6		68 6f 75 74 20 46 4f 52 00
8857		>a6ef		53 79 6e 74 61 78 00						ERR_SN      .text "Syntax",$00
8858		>a6f6		52 45 54 55 52 4e 20 77					ERR_RG      .text "RETURN without GOSUB",$00
				>a6fe		69 74 68 6f 75 74 20 47 4f 53 55 42 00
8859		>a70b		4f 75 74 20 6f 66 20 44					ERR_OD      .text "Out of DATA",$00
				>a713		41 54 41 00
8860		>a717		46 75 6e 63 74 69 6f 6e					ERR_FC      .text "Function call",$00
				>a71f		20 63 61 6c 6c 00
8861		>a725		4f 76 65 72 66 6c 6f 77					ERR_OV      .text "Overflow",$00
				>a72d		00
8862		>a72e		4f 75 74 20 6f 66 20 6d					ERR_OM      .text "Out of memory",$00
				>a736		65 6d 6f 72 79 00
8863		>a73c		55 6e 64 65 66 69 6e 65					ERR_US      .text "Undefined statement",$00
				>a744		64 20 73 74 61 74 65 6d 65 6e 74 00
8864		>a750		41 72 72 61 79 20 62 6f					ERR_BS      .text "Array bounds",$00
				>a758		75 6e 64 73 00
8865		>a75d		44 6f 75 62 6c 65 20 64					ERR_DD      .text "Double dimension",$00
				>a765		69 6d 65 6e 73 69 6f 6e 00
8866		>a76e		44 69 76 69 64 65 20 62					ERR_D0      .text "Divide by zero",$00
				>a776		79 20 7a 65 72 6f 00
8867		>a77d		49 6c 6c 65 67 61 6c 20					ERR_ID      .text "Illegal direct",$00
				>a785		64 69 72 65 63 74 00
8868		>a78c		54 79 70 65 20 6d 69 73					ERR_TM      .text "Type mismatch",$00
				>a794		6d 61 74 63 68 00
8869		>a79a		53 74 72 69 6e 67 20 74					ERR_LS      .text "String too long",$00
				>a7a2		6f 6f 20 6c 6f 6e 67 00
8870		>a7aa		53 74 72 69 6e 67 20 74					ERR_ST      .text "String too complex",$00
				>a7b2		6f 6f 20 63 6f 6d 70 6c 65 78 00
8871		>a7bd		43 61 6e 27 74 20 63 6f					ERR_CN      .text "Can't continue",$00
				>a7c5		6e 74 69 6e 75 65 00
8872		>a7cc		55 6e 64 65 66 69 6e 65					ERR_UF      .text "Undefined function",$00
				>a7d4		64 20 66 75 6e 63 74 69 6f 6e 00
8873		>a7df		4c 4f 4f 50 20 77 69 74					ERR_LD      .text "LOOP without DO",$00
				>a7e7		68 6f 75 74 20 44 4f 00
8881		>a7ef		0d 0a 42 72 65 61 6b 00					LAB_BMSG    .text $0D,$0A,"Break",$00
8882		>a7f7		20 45 72 72 6f 72 00						LAB_EMSG    .text " Error",$00
8883		>a7fe		20 69 6e 20 6c 69 6e 65					LAB_LMSG    .text " in line ",$00
				>a806		20 00
8884		>a808		0d 0a 52 65 61 64 79 0d					LAB_RMSG    .text $0D,$0A,"Ready",$0D,$0A,$00
				>a810		0a 00
8886		>a812		20 45 78 74 72 61 20 69					LAB_IMSG    .text " Extra ignored",$0D,$0A,$00
				>a81a		67 6e 6f 72 65 64 0d 0a 00
8887		>a823		20 52 65 64 6f 20 66 72					LAB_REDO    .text " Redo from start",$0D,$0A,$00
				>a82b		6f 6d 20 73 74 61 72 74 0d 0a 00
8889		.a836																		AA_end_basic
8890		=1																			CLOCK_MHZ   = 1 ; // clock frequency in MHz
8893		=$7f20																	ACIA_BASE   = $7f20
8894		=32544																	ACIA_DATA   = ACIA_BASE + 0
8895		=32545																	ACIA_STATUS = ACIA_BASE + 1
8896		=32546																	ACIA_CMD    = ACIA_BASE + 2
8897		=32547																	ACIA_CTL    = ACIA_BASE + 3
8900		=$e2																		TEMP        = $e2 ; general purpose byte, always assume that subroutines will change this
8903		.a836																		serial_init:
8904		.a836		a9 10						lda #$10				        lda #%00010000 ; 1 stop bit, 8 data bits, 115200bps, internal clock
8905		.a838		8d 23 7f				sta $7f23				        sta ACIA_CTL
8906		.a83b		a9 0b						lda #$0b				        lda #%00001011 ; no parity, no echo, no TX interrupts, /RTS=low, no RX interrupts, /DTR=low
8907		.a83d		8d 22 7f				sta $7f22				        sta ACIA_CMD
8908		.a840		60							rts							        rts
8913		.a841																		serial_out:
8914		.a841		8d 20 7f				sta $7f20				        sta ACIA_DATA
8915		.a844		20 5b a8				jsr $a85b				        jsr wait100us ; 115200bps -> 87us/character
8916		.a847		60							rts							        rts
8921		.a848																		serial_in:
8922		.a848		ad 21 7f				lda $7f21				        lda  ACIA_STATUS
8923		.a84b		29 08						and #$08				        and #%00001000 ; bit3 = Receiver Data Register Full
8924		.a84d		f0 05						beq $a854				        beq _empty
8925		.a84f		ad 20 7f				lda $7f20				        lda ACIA_DATA
8926		.a852		38							sec							        sec
8927		.a853		60							rts							        rts
8928		.a854																		_empty:
8929		.a854		18							clc							        clc
8930		.a855		60							rts							        rts
8933		.a856																		wait20clk:
8934		.a856		ea							nop							        nop ; CYC=2
8935		.a857		ea							nop							        nop ; CYC=2
8936		.a858		ea							nop							        nop ; CYC=2
8937		.a859		ea							nop							        nop ; CYC=2
8938		.a85a		60							rts							        rts ; CYC=12 (jsr+rts)
8942		.a85b																		wait100us:
8943		.a85b		84 e2						sty $e2					        sty TEMP           ; CYC=3
8944		.a85d		a0 03						ldy #$03				        ldy #4*CLOCK_MHZ-1 ; CYC=2
8945		.a85f																		_loop:
8946		.a85f		20 56 a8				jsr $a856				        jsr wait20clk
8947		.a862		88							dey							        dey         ; CYC=2
8948		.a863		d0 fa						bne $a85f				        bne _loop   ; CYC=3
8949		.a865		ea							nop							        nop         ; CYC=2
8950		.a866		ea							nop							        nop         ; CYC=2
8951		.a867		ea							nop							        nop         ; CYC=2
8952		.a868		a4 e2						ldy $e2					        ldy TEMP    ; CYC=4
8953		.a86a		60							rts							        rts         ; CYC=12 (jsr+rts)
8955		.a86b																		reset:
8956		.a86b		d8							cld							        cld         ; clear decimal mode
8957		.a86c		a2 ff						ldx #$ff				        ldx #$ff    ; empty stack
8958		.a86e		9a							txs							        txs         ; set the stack
8959		.a86f		20 36 a8				jsr $a836				        jsr serial_init
8961		.a872		a0 08						ldy #$08				        ldy #size(vectors)
8962		.a874																		_loop:
8963		.a874		b9 82 a8				lda $a882,y			        lda   vectors-1,y
8964		.a877		99 04 02				sta $0204,y			        sta   VEC_IN-1,y        ; save to RAM
8965		.a87a		88							dey							        dey
8966		.a87b		d0 f7						bne $a874				        bne _loop
8968		.a87d		4c 00 80				jmp $8000				        jmp LAB_COLD
8970		.a880																		ignore:
8971		.a880		60							rts							        rts
8973		.a881																		nmi:
8974		.a881		40							rti							        rti
8975		.a882																		irq:
8976		.a882		40							rti							        rti
8978		>a883		48 a8 41 a8 80 a8 80 a8					vectors: .word serial_in, serial_out, ignore, ignore
8981		>fffa		81 a8														        .word nmi   ; NMI
8982		>fffc		6b a8														        .word reset ; RESET
8983		>fffe		82 a8														        .word irq   ; IRQ/BRK

;******  End of listing
